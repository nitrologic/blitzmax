Authors
=======

Names below are sorted alphabetically.

Author
------

- Bruce A Henderson <woollybah@gmail.com>


Contributors
------------

- Ronny Otto
' Copyright (c) 2013-2016 Ronny Otto
' 
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
' 
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
' 
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
' 
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
' 
'    3. This notice may not be removed or altered from any source
'    distribution.
' 
SuperStrict

Import BRL.Map
Import BRL.FileSystem
Import BRL.Standardio

Type TConfigMap
	Field values:TMap = CreateMap()
	Field fileUri:String = ""


	Method Init:TConfigMap( configFile:String="" )
		If configFile <> "" Then LoadFromFile(configFile)

		Return Self
	End Method


	'clear all key->value pairs
	Method Reset:Int()
		values.Clear()
		Return True
	End Method


	'create another configMap with the same values
	Method Copy:TConfigMap()
		Local copyObj:TConfigMap = New TConfigMap

		'copy values
		For Local key:String = EachIn values.Keys()
			copyObj.Add(key, Get(key))
		Next
		Return copyObj
	End Method


	'create a merged configMap of all given configurations (eg. base + extension)
	Function CreateMerged:TConfigMap( configs:TConfigMap[], reversed:Int = False )
		If configs.length = 0 Then Return Null

		If reversed
			Local newConfigs:TConfigMap[]
			For Local i:Int = 1 To configs.length
				newConfigs :+ [configs[configs.length - i]]
			Next
			configs = newConfigs
		EndIf


		Local result:TConfigMap = configs[0].copy()
		For Local i:Int = 1 To configs.length-1
			'overwrite values or add new if not existing
			For Local key:String = EachIn configs[i].values.Keys()
				Local value:Object = configs[i].Get(key)
				If value Then result.Add(key, value)
			Next
		Next
		Return result
	End Function

	'try to load the configuration from a file
	Method LoadFromFile:Int( fileUri:String )
		'skip resetting and loading if the file is not existing
		If FileSize(fileUri) < 0 Then Return False

		Self.fileUri = fileUri

		'remove old values
		Reset()

		Local file:TStream = ReadFile(fileUri)
		If Not file
			'RuntimeError("ERROR: could not open file ~q"+fileUri+"~q for reading.")
			Print "ERROR: could not open file ~q"+fileUri+"~q for reading."
			Return False
		EndIf

		Local line:String = ""
		Local splitPos:Int = 0
		Local key:String, value:String
		While Not Eof(file)
			line = ReadLine(file)

			'skip #comments
			If line.Trim().Find("#") = 0 Then Continue

			'find first "=" (later ones could come from arguments/params)
			splitPos = line.Find("=")
			'no splitter means no assignment
			If splitPos < 0 Then Continue

			key = line[..splitPos].Trim()
			value = line[splitPos+1..].Trim()

			Add(key, value)
		Wend

		file.Close()
		Return True
	End Method


	Method ToString:String()
		Local result:String = "TConfigMap"+"~n"
		result :+ "-> file: "+Self.fileUri+"~n"
		result :+ "-> keys:"+"~n"
		For Local key:String = EachIn values.Keys()
			result :+ "  -> "+key+" : "+String(values.ValueForKey(key))+"~n"
		Next
		Return result
	End Method


	Method Add:TConfigMap( key:String, data:Object )
		values.insert(key, data)
		Return Self
	End Method


	Method AddString:TConfigMap( key:String, data:String )
		Add(key, Object(data))
		Return Self
	End Method


	Method AddNumber:TConfigMap( key:String, data:Float )
		Add( key, Object( String(data) ) )
		Return Self
	End Method


	Method Get:Object( key:String, defaultValue:Object=Null )
		Local result:Object = values.ValueForKey(key)
		If result Then Return result
		Return defaultValue
	End Method


	Method GetString:String( key:String, defaultValue:String=Null )
		Local result:Object = Get(key)
		If result Then Return String( result )
		Return defaultValue
	End Method


	Method GetInt:Int( key:String, defaultValue:Int = Null )
		Local result:Object = Get(key)
		If result Then Return Int( Float( String( result ) ) )
		Return defaultValue
	End Method
End Type' Copyright (c) 2014-2016 Bruce A Henderson
' Copyright (c) 2014-2016 Ronny Otto
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import "transform.c"

Import "stringbuffer_core.bmx"

Extern
	Function transform:Byte Ptr(i:Int)
End Extern

Type TStringHelper
	'this function replaces non-alphanumerical characters with
	'the string "replaceInvalidCharsWith"
	'certain characters (German umlauts, French accents) are replaced
	'with their basic characters (Ã© = e)

	Function Sanitize:String(value:String, replaceInvalidCharsWith:String="_", requiresAlphaPrefix:Int = False)
		Local result:TStringBuffer = New TStringBuffer

		For Local i:Int = 0 Until value.length

			Local c:Byte Ptr = transform(value[i])

			'append the char - or the replacement
			If c
				If Not i Then
					Local n:Int = c[0]
					If n >= Asc("0") And n <= Asc("9") Then
						result.Append(replaceInvalidCharsWith)
					End If
				End If
				result.AppendCString(c)
			Else
				result.Append(replaceInvalidCharsWith)
			EndIf
		Next

		Return result.ToString()
	End Function

End Type
' Brucey's Blitz Code Compiler
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Framework brl.StandardIO

Import "ctranslator.bmx"

Local args:String[] = ParseArgs(AppArgs[1..])

If args.length = 0 Then
	Print "bbcc Release Version " + version
	End
End If

If args.length <> 1 Then
	CmdError("Command line error")
End If

opt_filepath = args[0]


If opt_buildtype = BUILDTYPE_MODULE Then
	If opt_filepath.ToLower() = ModuleSource(opt_modulename).ToLower() Then
		opt_ismain = True
	End If
End If

Local app:TAppDecl 
Local trans:TCTranslator 
Try
	If opt_verbose Then
		Print "Parsing..."
	End If

	app = ParseApp(opt_filepath)

	If opt_verbose Then
		Print "Semanting..."
	End If

	app.Semant()

	trans = New TCTranslator

	trans.TransApp(app)
Catch error:String
	WriteStderr error
	exit_(-1) ' return a non-zero exit code
End Try

Local makeApp:Int = False
If opt_apptype Then
	makeApp = True
End If

Local mung:String = FileMung(makeApp)

SaveInterface(opt_filepath, trans, mung)
SaveHeader(opt_filepath, trans, mung)
SaveSource(opt_filepath, trans, mung)
SaveIncBinHeader(opt_filepath, trans, FileMung(False), app)


Function SaveInterface(file:String, trans:TCTranslator, mung:String)

	If opt_verbose Then
		Print "Generating interface..."
	End If

	Local path:String

	If opt_buildtype = BUILDTYPE_MODULE Then

		If opt_ismain Then
			' module interface
			path = ModuleInterface(opt_modulename, mung)
		Else
			' file interface
			path = OutputFilePath(file, mung, "i")
		End If

	Else

		' file interface
		path = OutputFilePath(file, mung, "i")

	End If

	SaveText(trans.JoinLines("interface"), path)

End Function

Function SaveHeader(file:String, trans:TCTranslator, mung:String)

	If opt_verbose Then
		Print "Generating header..."
	End If

	Local path:String = OutputFilePath(file, mung, "h")

	Local header:String = BuildHeaderName(path).ToUpper()
	Local text:String = HeaderComment()
	text :+ "#ifndef " + header + "~n"
	text :+ "#define " + header + "~n~n"

	If opt_buildtype = BUILDTYPE_MODULE And opt_modulename = "brl.blitz" Then
		text :+ "#include <brl.mod/blitz.mod/blitz.h>~n"
	End If

	text :+ trans.JoinLines("head")
	text :+ "~n~n#endif~n"

	SaveText(text, path)

End Function

Function SaveSource(file:String, trans:TCTranslator, mung:String)

	If opt_verbose Then
		Print "Generating source..."
	End If

	Local path:String = OutputFilePath(file, mung, "c")

	Local pre:String = trans.JoinLines("pre_source")
	Local src:String = trans.JoinLines("source")

	SaveText(pre + "~n" + src, path)

End Function

Function SaveIncBinHeader(file:String, trans:TCTranslator, mung:String, app:TAppDecl)

	If app.genIncBinHeader Then
		Local path:String = OutputFilePath(file, mung, "incbin.h")

		SaveText(trans.JoinLines("incbin"), path)
	End If

End Function
# It is generally recommended NOT to have a bbcc.conf file in the same folder as
# your bcc binary.
#
# However, when debugging bcc, usually your debugger has a different BMXPATH to
# that of the bcc you are debugging. This can cause problems, like accessing
# modules from the debugger's BlitzMax rather than those of the bcc you are
# debugging.
# You can override the BMXPATH environment variable inherited from your debugger
# by copying this file as "bbc.conf" next to your bcc-binary and uncomment
# the following lines, adjusting the path accordingly :
#
#BMXPATH=YOUR/PATH/TO/BLITZMAX
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import BRL.LinkedList
Import BRL.Map
Import BRL.FileSystem

Import "options.bmx"
Import "base.stringhelper.bmx"


' debugging help
Const DEBUG:Int = False
Const ABORT_ON_NULL:Int = True
Const PROFILER:Int = False
Const DEBUGSTOP_ON_ERROR:Int = False

Global ENV_LANG$

Global _errInfo$
Global _errStack:TList = New TList

' bytes offset to the first field
Global OBJECT_BASE_OFFSET:Int = 8
' 4 bytes on 32-bit, 8 bytes on 64-bit
Global POINTER_SIZE:Int = 4

Global _symbols$[]=[ "..","[]",":*",":/",":+",":-",":|",":&",":~~",":shr",":shl",":sar",":mod"]
Global _symbols_map$[]=[ "..","[]","*=","/=","+=","-=","|=","&=","^=",">>=", "<<=",">>=","%=" ]

Function PushErr( errInfo$ )
	_errStack.AddLast _errInfo
	_errInfo=errInfo
End Function

Function PopErr()
	_errInfo=String(_errStack.RemoveLast())
End Function

Function Err( err$ )
	If DEBUGSTOP_ON_ERROR Then
		DebugStop ' useful for debugging!
	End If
	Throw "Compile Error: "+err + "~n" + _errInfo + "~n"
End Function

Function Warn( err$ )
	'If DEBUGSTOP_ON_ERROR Then
	'	DebugStop ' useful for debugging!
	'End If
	Print "Compile Warning: "+err + "~n" + _errInfo + "~n"
End Function

Function FormatError:String(path:String, line:Int, char:Int)
	Return "[" + path + ";" + line + ";" + char + "]"
End Function

Function InternalErr()
	If DEBUGSTOP_ON_ERROR Then
		DebugStop ' useful for debugging!
	End If
	Throw "Internal Error.~n" + _errInfo + "~n"
End Function

Function IsSpace:Int( ch:Int )
	Return ch<=Asc(" ") Or ch=$A0 ' NO-BREAK SPACE (U+00A0)
End Function

Function IsDigit:Int( ch:Int )
	Return ch>=Asc("0") And ch<=Asc("9")
End Function

Function IsAlpha:Int( ch:Int )
	Return (ch>=Asc("A") And ch<=Asc("Z")) Or (ch>=Asc("a") And ch<=Asc("z"))
End Function

Function IsBinDigit:Int( ch:Int )
	Return ch=Asc("0") Or ch=Asc("1")
End Function

Function IsHexDigit:Int( ch:Int )
	Return IsDigit(ch) Or (ch>=Asc("A") And ch<=Asc("F")) Or (ch>=Asc("a") And ch<=Asc("f"))
End Function

Function Todo() 
	Err "TODO!"
End Function

Function IsStandardFunc:Int(func:String)
	func = func.ToLower()
	
	Global funcs:String = ";isalnum;isalpha;isascii;isblank;iscntrl;isdigit;isgraph;islower;isprint;ispunct;isspace;isupper;isxdigit;" + ..
		"strlen;_wgetenv;_wputenv;"
	
	Return funcs.Find(func) > 0
End Function

Function mapSymbol:String(sym:String)
	For Local i:Int = 0 Until _symbols.length
		If sym = _symbols[i] Then
			Return _symbols_map[i]
		End If
	Next
	Return sym
End Function


'enquote depending on ENV_LANG
'
Function LangEnquote$( str$ )
	str=EscapeString(str)
'	str=str.Replace( "~0","\0" )	'Fix me?
	For Local i:Int=0 Until str.Length
		If str[i]>=32 And str[i]<128 Continue
		Local t$,n:Int=str[i]
		While n
			Local c:Int=(n&15)+48
			If c>=58 c:+97-58
			t=Chr( c )+t
			n=(n Shr 4) & $0fffffff
		Wend
		If Not t t="0"
		If ENV_LANG = "cpp" Then
		'Case "cpp"
			t="~q~q\x"+t+"~q~q"
		Else
			t="\u"+("0000"+t)[-4..]
		End If
		str=str[..i]+t+str[i+1..]
		i:+t.Length-1
	Next
	str="~q"+str+"~q"
	If ENV_LANG="cpp" str="L"+str
	Return str
End Function

Function EscapeString$(str$)
	str=str.Replace( "\","\\" )
	str=str.Replace( "~q","\~q" )
	str=str.Replace( "~n","\n" )
	str=str.Replace( "~r","\r" )
	str=str.Replace( "~t","\t" )
	Return str
End Function

Function BmxEnquote$( str$ )
	str=str.Replace( "~~","~~~~" )
	str=str.Replace( "~q","~~q" )
	str=str.Replace( "~n","~~n" )
	str=str.Replace( "~r","~~r" )
	str=str.Replace( "~t","~~t" )
	str=str.Replace( "~0","~~0" )
	str="~q"+str+"~q"
	Return str
End Function

Function BmxUnquote$( str$, unicodeConvert:Int = False )
	If str.length = 1 Or str[str.length - 1] <> Asc("~q") Then
		Err "Expecting expression but encountered malformed string literal"
	End If
	str=str[1..str.Length-1]
	If unicodeConvert Then
		Local pos:Int = str.Find("~~")
		While pos <> -1
			If pos + 1 < str.length Then
				If str[pos + 1] >= Asc("1") And str[pos + 1] <= Asc("9") Then
					Local p2:Int = str.Find("~~", pos + 1)
					If p2 <> -1 Then
						Local s:String = Chr(str[pos + 1.. p2].ToInt())
						str = str[..pos] + s + str[p2 + 1..]
					End If
				End If
			End If
		
			pos = str.Find("~~", pos + 1)
		Wend
	End If
	str=str.Replace( "~~~~","~~z" )	'a bit dodgy - uses bad esc sequence ~z 
	str=str.Replace( "~~q","~q" )
	str=str.Replace( "~~n","~n" )
	str=str.Replace( "~~r","~r" )
	str=str.Replace( "~~t","~t" )
	str=str.Replace( "~~0","~0" )
	str=str.Replace( "~~z","~~" )
	Return str
End Function

Type TStack Extends TList

	Method Push(obj:Object)
		AddFirst(obj)
	End Method

	Method Length:Int()
		Return count()
	End Method
	
	Method Get:Object(index:Int)
		Return ValueAtIndex(index)
	End Method
	
	Method Pop:Object()
		Return RemoveFirst()
	End Method
	
End Type

Type TStringList Extends TList
	Method Join:String(s:String)
		Local arr:String[] = New String[count()]
		Local index:Int
		For Local t:String = EachIn Self
			arr[index] = t
			index :+ 1
		Next
		
		Return s.Join(arr)
	End Method
End Type

Type TKeyValue
	Field key:Object
	Field value:Object
	
	Method Create:TKeyValue(key:Object,value:Object)
		Self.key = key
		Self.value = value
		Return Self
	End Method
	
	Method Compare:Int(other:Object)
		If Not TKeyValue(other) Return 0
		Return key.Compare(TKeyValue(other).key)
	End Method
	
End Type

Type TUnorderedMap

	Field list:TList = New TList
	Field map:TMap = New TMap
	
	Field valuesList:TList = New TList

	Method Insert( key:Object,value:Object )
		list.AddLAst(New TKeyValue.Create(key, value))
		valuesList.AddLast(value)
		map.Insert(key, value)
	End Method
	
	Method Keys:TList()
		Local klist:TList = New TList
		For Local kv:TKeyValue = EachIn list
			klist.AddLast(kv.key)
		Next
		Return klist
	End Method
	
	Method Values:TList()
		'Local vlist:TList = New TList
		'For Local kv:TKeyValue = EachIn list
		'	vlist.AddLast(kv.value)
		'Next
		Return valuesList
	End Method
	
	Method Contains:Int( key:Object )
		Return map.Contains(key)
	End Method
	
	Method ValueForKey:Object( key:Object )
		Return map.ValueForKey(key)
	End Method
End Type

Function MakeKeywords:String()
	Local keywords:String
	
	keywords :+ "import brl.classes~n"
	keywords :+ "Asc%(v$)=~qbrl_blitz_keywords_asc~q~n"
	keywords :+ "Sgn#(v#)=~qbrl_blitz_keywords_sgn~q~n"
	keywords :+ "Chr$(v%)=~qbrl_blitz_keywords_chr~q~n"
	keywords :+ "Len%(v:Object)=~qbrl_blitz_keywords_len~q~n"
	keywords :+ "Min%(v1%,v2%)=~qbrl_blitz_keywords_min~q~n"
	keywords :+ "Max%(v1%,v2%)=~qbrl_blitz_keywords_max~q~n"
	'keywords :+ "SizeOf%(v%)=~qbrl_blitz_keywords_sizeof~q~n"
	'keywords :+ "Incbin(v$)=~qbrl_blitz_keywords_incbin~q~n"
	keywords :+ "IncbinPtr@*(v$)=~qbbIncbinPtr~q~n"
	keywords :+ "IncbinLen%(v$)=~qbbIncbinLen~q~n"
 
	Return keywords
End Function

Function FilePath:String(path:String)
	Local baseDir:String = ExtractDir(path)
	Local bmxDir:String = baseDir + "/.bmx"
	
	If FileType(bmxDir) <> FILETYPE_DIR Then
		Throw "Missing : " + bmxDir
	End If
	
	Return bmxDir
End Function

Function BuildHeaderName:String(path:String)
	If opt_buildtype = BUILDTYPE_MODULE Then
		path = opt_modulename + "_" + StripDir(path)
	Else
		Local dir:String = ExtractDir(path).ToLower().Replace("/.bmx","")
		dir = dir[dir.findLast("/") + 1..]
		If dir.EndsWith(".mod") Then
			dir = dir.Replace(".mod", "")
		End If
		Local file:String = StripDir(path).ToLower()
		path = dir + "_" + file
	End If
	
	Return TStringHelper.Sanitize(path, , True)
End Function

Rem
bbdoc: Get the header file name from a given module ident, optionally with include path.
End Rem
Function ModuleHeaderFromIdent:String(ident:String, includePath:Int = False)
	Local ns:String = ident[..ident.find(".")]
	Local name:String = ident[ident.find(".") + 1..]
	
	Local file:String = name + ".bmx" + FileMung() + ".h"
	
	If includePath Then
		file = ns + ".mod/" + name + ".mod/.bmx/" + file
	End If
	
	Return file
End Function

Function HeaderFile:String(path:String, mung:String)
	Local fileDir:String = FilePath(path)
	Local file:String = StripDir(path)
	
	Return fileDir + "/" + file + mung + ".h"
End Function

Function OutputFilePath:String(path:String, mung:String, suffix:String, bmxDir:Int = False)
	Local fileDir:String = FilePath(path)
	If bmxDir Then
		fileDir :+ "/.bmx"
	End If
	Local file:String = StripDir(path)
	
	Return fileDir + "/" + file + mung + "." + suffix
End Function

Function FileMung:String(makeApp:Int = False)
	Local m:String = "."
	
	If makeApp Then
		Select opt_apptype
			Case APPTYPE_CONSOLE
				m :+ "console."
			Case APPTYPE_GUI
				m :+ "gui."
		End Select
	End If
	
	If opt_release Then
		m :+ "release"
	Else
		m :+ "debug"
	End If
	
	If opt_threaded Then
		m :+ ".mt"
	End If
	
	m :+ "." + opt_platform
	
	m :+ "." + opt_arch
	
	Return m
End Function

Function HeaderComment:String()
	' TODO
End Function
Copyright (c) 2013-2015 Bruce A Henderson

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import "parser.bmx"

Type TCTranslator Extends TTranslator

	'Field stringConstCount:Int

	Field prefix:String
	
	Field reserved_methods:String = ",New,Delete,ToString,Compare,SendMessage,_reserved1_,_reserved2_,_reserved3_,".ToLower()
	
	Method New()
		_trans = Self
	End Method

	Method TransSPointer$( ty:TType, withVar:Int = False )
		Local p:String
		
		If ty

			If withVar And (ty._flags & TType.T_VAR) Then
				p:+ "*"
			End If

			If ty._flags & TType.T_PTR Then
				p:+ "*"
			Else If ty._flags & TType.T_PTRPTR Then
				p:+ "**"
			Else If ty._flags & TType.T_PTRPTRPTR Then
				p:+ "***"
			End If

		End If
		
		Return p
	End Method

	Method TransArrayType$( ty:TType)
		Local p:String = TransSPointer(ty)
		
		If TBoolType( ty ) Return "~q" + p + "i~q"
		If TByteType( ty ) Return "~q" + p + "b~q"
		If TShortType( ty ) Return "~q" + p + "s~q"
		If TIntType( ty ) Return "~q" + p + "i~q"
		If TUIntType( ty ) Return "~q" + p + "u~q"
		If TFloatType( ty ) Return "~q" + p + "f~q"
		If TDoubleType( ty ) Return "~q" + p + "d~q"
		If TLongType( ty ) Return "~q" + p + "l~q"
		If TULongType( ty ) Return "~q" + p + "y~q"
		If TSizeTType( ty ) Return "~q" + p + "z~q"
		If TWParamType( ty ) Return "~q" + p + "w~q"
		If TLParamType( ty ) Return "~q" + p + "x~q"
		If TStringType( ty ) Return "~q$~q"
		If TInt128Type( ty ) Return "~q" + p + "j~q"
		If TFloat128Type( ty ) Return "~q" + p + "k~q"
		If TDouble128Type( ty ) Return "~q" + p + "m~q"
		If TFloat64Type( ty ) Return "~q" + p + "h~q"
		If TArrayType( ty ) Then
			Local s:String = "["
			For Local i:Int = 0 Until TArrayType( ty ).dims - 1
				s:+ ","
			Next
			s:+ "]"
			s:+ TransArrayType(TArrayType( ty ).elemType)
			Return Enquote(s.Replace("~q", ""))
		End If
		If TObjectType( ty ) Then
			If TObjectType( ty ).classdecl.IsStruct()
				Return "~q" + p + "@" + TObjectType(ty).classDecl.ident + "~q"
			Else
				If Not TObjectType( ty ).classdecl.IsExtern()
					Return "~q:" + TObjectType(ty).classDecl.ident + "~q"
				Else
					If TObjectType( ty ).classdecl.IsInterface() Then
						Return "~q" + p + "*#" + TObjectType(ty).classDecl.ident + "~q"
				'	ElseIf TObjectType( ty ).classdecl.IsStruct()
'						Return "~q" + p + "@" + TObjectType(ty).classDecl.ident + "~q"
					Else
						Return "~q" + p + "#" + TObjectType(ty).classDecl.ident + "~q"
					End If
				End If
			End If
		End If
		If TFunctionPtrType( ty ) Return "~q(~q"

	End Method

	Method TransDefDataType$( ty:TType)
		If TByteType( ty ) Return "~qb~q"
		If TShortType( ty ) Return "~qs~q"
		If TIntType( ty ) Return "~qi~q"
		If TUIntType( ty ) Return "~qu~q"
		If TFloatType( ty ) Return "~qf~q"
		If TDoubleType( ty ) Return "~qd~q"
		If TLongType( ty ) Return "~ql~q"
		If TULongType( ty ) Return "~qy~q"
		If TSizeTType( ty ) Return "~qz~q"
		If TStringType( ty ) Return "~q$~q"
		If TWParamType( ty ) Return "~qw~q"
		If TLParamType( ty ) Return "~qx~q"
	End Method

	Method TransDefDataConversion$(ty:TType)
		If TByteType( ty ) Return "bbConvertToInt"
		If TShortType( ty ) Return "bbConvertToInt"
		If TIntType( ty ) Return "bbConvertToInt"
		If TUIntType( ty ) Return "bbConvertToUInt"
		If TFloatType( ty ) Return "bbConvertToFloat"
		If TDoubleType( ty ) Return "bbConvertToDouble"
		If TLongType( ty ) Return "bbConvertToLong"
		If TULongType( ty ) Return "bbConvertToULong"
		If TSizeTType( ty ) Return "bbConvertToSizet"
		If TStringType( ty ) Return "bbConvertToString"
	End Method

	Method TransDefDataUnionType$(ty:TType)
		If TByteType( ty ) Return "b"
		If TShortType( ty ) Return "s"
		If TIntType( ty ) Return "i"
		If TUIntType( ty ) Return "u"
		If TFloatType( ty ) Return "f"
		If TDoubleType( ty ) Return "d"
		If TLongType( ty ) Return "l"
		If TULongType( ty ) Return "y"
		If TSizeTType( ty ) Return "z"
		If TWParamType( ty ) Return "w"
		If TLParamType( ty ) Return "x"
		If TStringType( ty ) Return "t"
	End Method
	
	Method TransDebugScopeType$(ty:TType)
		Local p:String = TransSPointer(ty)

		If TByteType( ty ) Return p + "b"
		If TShortType( ty ) Return p + "s"
		If TIntType( ty ) Return p + "i"
		If TUIntType( ty ) Return p + "u"
		If TFloatType( ty ) Return p + "f"
		If TDoubleType( ty ) Return p + "d"
		If TLongType( ty ) Return p + "l"
		If TULongType( ty ) Return p + "y"
		If TSizeTType( ty ) Return p + "t"
		If TWParamType( ty ) Return p + "W"
		If TLParamType( ty ) Return p + "X"
		If TInt128Type( ty ) Return p + "j"
		If TFloat128Type( ty ) Return p + "k"
		If TDouble128Type( ty ) Return p + "m"
		If TFloat64Type( ty ) Return p + "h"
		If TStringType( ty ) Return "$"
		If TArrayType( ty ) Then
			Local s:String = "["
			For Local i:Int = 0 Until TArrayType( ty ).dims - 1
				s:+ ","
			Next
			s:+ "]"
			Return s + TransDebugScopeType(TArrayType( ty ).elemType)
		End If
		If TObjectType( ty ) Then
			If TObjectType( ty ).classdecl.IsStruct() Then
					Return p + "@" + TObjectType(ty).classDecl.ident
			Else If Not TObjectType( ty ).classdecl.IsExtern()
				Return ":" + TObjectType( ty ).classDecl.ident
			Else
				If TObjectType( ty ).classdecl.IsInterface() Then
					Return p + "*#" + TObjectType(ty).classDecl.ident
				Else
					Return p + "#" + TObjectType(ty).classDecl.ident
				End If
			End If
		End If
		If TFunctionPtrType( ty ) Then
			Local func:TFuncDecl = TFunctionPtrType( ty ).func
			Local s:String = "("
			For Local i:Int = 0 Until func.argDecls.length
				If i Then
					s :+ ","
				End If
				s :+ TransDebugScopeType(func.argDecls[i].ty)
			Next
			Return s + ")" + TransDebugScopeType(func.retType)
		End If

	End Method

	Method TransType$( ty:TType, ident:String, fpReturnTypeFunctionArgs:String = Null, fpReturnTypeClassFunc:Int = False)
		Local p:String = TransSPointer(ty, True)
		
		If TVoidType( ty ) Or Not ty Then
			Return "void"
		End If
		If TBoolType( ty ) Return "BBINT" + p
		If TByteType( ty ) Return "BBBYTE" + p
		If TShortType( ty ) Return "BBSHORT" + p
		If TIntType( ty ) Return "BBINT" + p
		If TUIntType( ty ) Return "BBUINT" + p
		If TFloatType( ty ) Return "BBFLOAT" + p
		If TDoubleType( ty ) Return "BBDOUBLE" + p
		If TLongType( ty ) Return "BBLONG" + p
		If TULongType( ty ) Return "BBULONG" + p
		If TSizeTType( ty ) Return "BBSIZET" + p
		If TWParamType( ty ) Return "WPARAM" + p
		If TLParamType( ty ) Return "LPARAM" + p
		If TInt128Type( ty ) Return "BBINT128" + p
		If TFloat128Type( ty ) Return "BBFLOAT128" + p
		If TDouble128Type( ty ) Return "BBDOUBLE128" + p
		If TFloat64Type( ty ) Return "BBFLOAT64" + p
		If TStringType( ty ) Then
			If ty._flags & TType.T_CHAR_PTR Then
				Return "BBBYTE *"
			Else If ty._flags & TType.T_SHORT_PTR Then
				Return "BBSHORT *"
			End If
			Return "BBSTRING" + p
		End If
		If TArrayType( ty ) Return "BBARRAY" + p
		If TObjectType( ty ) Then
			Return TransObject(TObjectType(ty).classdecl) + p
		End If

		If TFunctionPtrType( ty ) Then

			TFunctionPtrType(ty).func.Semant

			Local retType:String = TransType(TFunctionPtrType(ty).func.retType, "")
			Local api:String
			If TFunctionPtrType(ty).func.attrs & DECL_API_WIN32 Then
				api = " __stdcall "
			End If
			Local args:String
			For Local arg:TArgDecl = EachIn TFunctionPtrType(ty).func.argDecls
				arg.Semant()
				If args Then
					args :+ ","
				End If

				args :+ TransType(arg.ty, "")
			Next
			Local ret:String = ""
			If fpReturnTypeFunctionArgs Then
				ret = Bra(fpReturnTypeFunctionArgs)
			End If
			If fpReturnTypeClassFunc Then
				' typedef for function pointer return type
				Return ident + "x" + Bra(api + p +"* " + ident) + Bra(args)
			Else
				Return retType + Bra(api + p +"* " + ident + ret) + Bra(args)
			End If
		End If

		If TExternObjectType( ty ) Return "struct " + TExternObjectType( ty ).classDecl.munged + p

		InternalErr
	End Method

	Method TransIfcType$( ty:TType, isSuperStrict:Int = False )
		Local p:String = TransSPointer(ty)
		If ty And (ty._flags & TType.T_VAR) Then
			p :+ " Var"
		End If
		
		If Not ty Then
			If opt_issuperstrict Or isSuperStrict Then
				Return p
			Else
				Return "%" + p
			End If
		End If
		If TVoidType( ty ) Then
			Return p
		End If
		If TByteType( ty ) Return "@" + p
		If TShortType( ty ) Return "@@" + p
		If TIntType( ty ) Return "%" + p
		If TUIntType( ty ) Return "|" + p
		If TFloatType( ty ) Return "#" + p
		If TDoubleType( ty ) Return "!" + p
		If TLongType( ty ) Return "%%" + p
		If TULongType( ty ) Return "||" + p
		If TSizeTType( ty ) Return "%z" + p
		If TWParamType( ty ) Return "%w" + p
		If TLParamType( ty ) Return "%x" + p
		If TInt128Type( ty ) Return "%j" + p
		If TFloat128Type( ty ) Return "!k" + p
		If TDouble128Type( ty ) Return "!m" + p
		If TFloat64Type( ty ) Return "!h" + p
		If TStringType( ty ) Then
			If ty._flags & TType.T_CHAR_PTR Then
				Return "$z"
			Else If ty._flags & TType.T_SHORT_PTR Then
				Return "$w"
			End If
			Return "$" + p
		End If
		If TArrayType( ty )  Then
			Local s:String = TransIfcType(TArrayType( ty ).elemType) + "&["
			For Local i:Int = 0 Until TArrayType( ty ).dims - 1
				s:+ ","
			Next
			Return s + "]" + p
		End If
		If TObjectType( ty ) Then
			Local t:String = ":"
			If TObjectType(ty).classDecl.IsExtern() Then
				If TObjectType(ty).classDecl.IsInterface() Then
					t = "??"
				ElseIf TObjectType(ty).classDecl.IsStruct() Then
					t = "~~"
				Else
					t = "?"
				End If
			End If
			Local cdecl:TClassDecl = TObjectType(ty).classDecl
			' find first type in hierarchy that isn't private
			While cdecl.IsPrivate() And cdecl.superClass <> Null
				cdecl = cdecl.superClass
			Wend
			Return t + cdecl.ident + p
		End If
		If TFunctionPtrType( ty ) Return TransIfcType(TFunctionPtrType(ty).func.retType, TFunctionPtrType(ty).func.ModuleScope().IsSuperStrict()) + TransIfcArgs(TFunctionPtrType(ty).func)
		If TExternObjectType( ty ) Return ":" + TExternObjectType(ty).classDecl.ident + p
		InternalErr
	End Method

	Method TransRefType$( ty:TType, ident:String )
		Return TransType( ty, ident )
	End Method

	Method TransValue$( ty:TType,value$ )
		If value
			If IsPointerType(ty, 0, TType.T_POINTER) Return value
			If TBoolType( ty ) Return "1"
			If TShortType( ty ) Return value
			If TIntType( ty ) Return value
			If TUIntType( ty ) Return value+"U"
			If TLongType( ty ) Return value+"LL"
			If TULongType( ty ) Return value+"ULL"
			If TSizeTType( ty ) Return value
			If TWParamType( ty ) Return value
			If TLParamType( ty ) Return value
			If TInt128Type( ty ) Return value
			If TFloatType( ty ) Then
				If value = "nan" Or value = "1.#IND0000" Then
					Return "bbPOSNANf"
				Else If value="-nan" Or value = "-1.#IND0000" Then
					Return "bbNEGNANf"
				Else If value = "inf" Or value = "1.#INF0000" Then
					Return "bbPOSINFf"
				Else If value = "-inf" Or value = "-1.#INF0000" Then
					Return "bbNEGINFf"
				Else
					If value.ToLower().Find("e")>=0 Then
						Return value
					End If
					If value.Find(".") < 0 Then
						value :+ ".0"
					End If
					Return value+"f"
				End If
			End If
			If TDoubleType( ty ) Or TFloat128Type(ty) Or TDouble128Type(ty) Or TFloat64Type(ty) Then
				If value = "nan" Or value = "1.#IND0000" Then
					Return "bbPOSNANd"
				Else If value="-nan" Or value = "-1.#IND0000" Then
					Return "bbNEGNANd"
				Else If value = "inf" Or value = "1.#INF0000" Then
					Return "bbPOSINFd"
				Else If value = "-inf" Or value = "-1.#INF0000" Then
					Return "bbNEGINFd"
				Else
					If value.ToLower().Find("e") >=0 Then
						Return value
					End If
					If value.Find(".") < 0 Then
						value :+ ".0"
					End If
					Return value
				End If
			End If
			If TStringType( ty ) Return TransStringConst(value )
			If TByteType( ty ) Return value
		Else
			If TBoolType( ty ) Return "0"
			If TIntrinsicType( ty) Then
				If IsPointerType(ty, 0, TType.T_POINTER) Then
					Return "0"
				Else
					Return "{}"
				End If
			End If
			If TNumericType( ty ) Return "0" ' numeric and pointers
			If TStringType( ty ) Return "&bbEmptyString"
			If TArrayType( ty ) Return "&bbEmptyArray"
			If TObjectType( ty ) Then
				If TObjectType( ty ).classDecl.IsExtern() Or TObjectType( ty ).classDecl.IsStruct() Then
					If TObjectType( ty ).classDecl.IsInterface() Or IsPointerType(ty) Or (Not TObjectType( ty ).classDecl.IsStruct()) Then
						Return "0"
					Else
						Return "{}"
					End If
				Else
					Return "&bbNullObject"
				End If
			End If
			If TFunctionPtrType( ty) Return "&brl_blitz_NullFunctionError" ' todo ??
		EndIf
		InternalErr
	End Method
	
	Method TransArgs$( args:TExpr[],decl:TFuncDecl, objParam:String = Null )
'If decl.ident="AddS" DebugStop

		Local t$
		If objParam And (decl.IsMethod() Or decl.isCtor()) And ((Not decl.IsExtern()) Or (decl.IsExtern() And TClassDecl(decl.scope) And Not TClassDecl(decl.scope).IsStruct())) Then
			t:+ objParam
		End If
		For Local i:Int=0 Until decl.argDecls.Length
			Local ty:TType = TArgDecl(decl.argDecls[i].actual).ty
		
			If t t:+","
			If i < args.length
				Local arg:TExpr = args[i]
				
				If TNullExpr(arg) Then
					t :+ TransValue(ty, Null)
					Continue
				Else If TIndexExpr(arg) And (ty._flags & TType.T_VAR) Then
						t:+ "&"
				Else If TStringType(ty) And (ty._flags & TType.T_VAR) Then
					If TCastExpr(arg) And TStringType(TCastExpr(arg).expr.exprType) Then
						t:+ "&"
					End If
				Else If TArrayType(ty) And (ty._flags & TType.T_VAR) Then
					If (TVarExpr(arg) And TArrayType(TVarExpr(arg).exprType) Or (TMemberVarExpr(arg) And TArrayType(TMemberVarExpr(arg).exprType))) And Not (arg.exprType._flags & TType.T_VAR) Then
						t:+ "&"
					End If
				Else If TObjectType(ty) And (ty._flags & TType.T_VAR) Then
					If (TVarExpr(arg) Or TMemberVarExpr(arg)) And TObjectType(arg.exprType) And Not (arg.exprType._flags & TType.T_VAR) Then
						t:+ "&"
					End If
				Else If TFunctionPtrType(ty) Or IsPointerType(ty, TType.T_BYTE) Then

					If TFunctionPtrType(ty) And (ty._flags & TType.T_VAR) Then
						t:+ "&"
					End If

					If TInvokeExpr(arg) And Not TInvokeExpr(arg).decl.IsMethod() Then
						If IsPointerType(ty, TType.T_BYTE) Then
							t:+ TInvokeExpr(arg).Trans()
						Else
							' need to test scopes to see if we need to use the current instance's function or not
							' use the "actual", not the copy we made for the function pointer.
							Local fdecl:TFuncDecl = TFuncDecl(TInvokeExpr(arg).decl.actual)
							If Not fdecl.munged Then
								MungDecl fdecl
								TInvokeExpr(arg).decl.munged = fdecl.munged
							End If

							If TClassDecl(fdecl.scope) Then
								' current scope is related to function scope?
								If _env.ClassScope() And _env.FuncScope() And _env.FuncScope().IsMethod() Then
									If _env.ClassScope().ExtendsClass(TClassDecl(fdecl.scope)) Then
										Local scope:TScopeDecl = _env.scope
										Local obj:String = Bra("struct " + scope.munged + "_obj*")
										Local class:String = "o->clas"
				
										t:+ class + "->f_" + fdecl.ident + MangleMethod(fdecl)
									Else
										t:+ fdecl.munged
									End If
								Else
									t:+ fdecl.munged
								End If
							Else
								t:+ fdecl.munged
							End If
						End If
						Continue
					End If
					' some cases where we are passing a function pointer via a void* parameter.
					If TCastExpr(arg) And TInvokeExpr(TCastExpr(arg).expr) And Not TInvokeExpr(TCastExpr(arg).expr).invokedWithBraces Then
						If Not TInvokeExpr(TCastExpr(arg).expr).decl.munged Then
							t:+ TInvokeExpr(TCastExpr(arg).expr).decl.actual.munged
						Else
							t:+ TInvokeExpr(TCastExpr(arg).expr).decl.munged
						End If
						Continue
					End If

					' Object -> Byte Ptr
					If IsPointerType(ty, TType.T_BYTE) And TObjectType(arg.exprType) Then
						t:+ Bra(Bra("(BBBYTE*)" + Bra(arg.Trans())) + "+" + Bra("sizeof(void*)"))
						Continue
					End If

				Else If IsNumericType(ty)  Then
					If TObjectType(arg.exprType) 'And TObjectType(args[i].exprType).classDecl = TClassDecl.nullObjectClass Then
					err "NULL"
						t:+ "0"
						Continue
					End If
				End If
				
				If decl.argDecls[i].castTo Then
					t:+ Bra(decl.argDecls[i].castTo) + arg.Trans()
				Else

					Local tc:String = TransTemplateCast( ty,arg.exprType,arg.Trans() )
				
					' *sigh*
					' if var is going to var, remove any leading dereference character.
					' rather hacky. Would be better to cast variable to varptr during semanting (well done if you can work out where!)
					If arg.exprType.EqualsType( ty.ActualType() ) And (ty._flags & TType.T_VAR) And (arg.exprType._flags & TType.T_VAR) Then
						If tc.startswith("*") Then
							tc = tc[1..]
						End If
					End If

					t:+ tc
				
					't:+TransTemplateCast( ty,args[i].exprType,args[i].Trans() )
				End If
			Else
				decl.argDecls[i].Semant()
				' default values
				Local init:TExpr = decl.argDecls[i].init
				If init Then
					If TConstExpr(init) Then
						If TObjectType(TConstExpr(init).exprType) Then
t:+"NULLNULLNULL"
						' And TNullDecl(TObjectType(TConstExpr(init).exprType).classDecl)) Or (TConstExpr(init).value = "bbNullObject") Then
							If TStringType(decl.argDecls[i].ty) Then
								t :+ "&bbEmptyString"
							Else If TArrayType(decl.argDecls[i].ty) Then
								t :+ "&bbEmptyArray"
							Else
								t :+ "&bbNullObject"
							End If
						Else
							t:+ decl.argDecls[i].init.Trans()
						End If
					Else If TFunctionPtrType(ty) Then
						If TInvokeExpr(init) Then
							t:+ TInvokeExpr(init).decl.munged
						End If
					Else
						t:+ decl.argDecls[i].init.Trans()
					End If
				End If
			End If
		Next

		Return Bra(t)
	End Method

	Method TransArgsTypes$( args:TExpr[],declArgTypes:TType[])
		Local t$
		For Local i:Int=0 Until args.Length
			If t t:+","
			t:+TransTemplateCast( declArgTypes[i],args[i].exprType,args[i].Trans() )
		Next
		Return Bra(t)
	End Method

	Method TransPtrCast$( ty:TType,src:TType,expr$,cast$ )
		If IsPointerType(ty, 0, TType.T_POINTER | TType.T_VARPTR | TType.T_VAR) Or TFunctionPtrType(ty) Then
			' TODO : pointer stuff
			If TNullType(src) Return TransValue(ty, Null)
			Return expr
		End If
'If expr = "NULL" DebugStop
'		If TIntType(ty) And TStringType(src) Then
'DebugStop
'			Return "bbObjectDowncast" + Bra(expr + ",&" + TStringType(src).cDecl.munged)
'		End If

		If TNullType(src)
			Return TransValue(ty, Null)
		End If

		If TStringType(ty) And TObjectType(src) Then
			If Not TStringType(ty).cDecl Then
				ty.Semant()
			End If
			'If TNullDecl(TObjectType(src).classDecl) Then
			'	Return "&bbEmptyString"
			'End If
			Return Bra("(BBString *)bbObjectDowncast" + Bra(expr + ",&" + TStringType(ty).cDecl.munged))
		End If

		'If TArrayType(ty) And TObjectType(src) Then
		'	If TNullDecl(TObjectType(src).classDecl) Then
		'		Return "&bbEmptyArray"
		'	End If
		'End If

		If TVarPtrType(src) And TNumericType(ty) Then
			Return "*" + expr
		End If

		If TIntType(ty) And TStringType(src) Then
			Return Bra(expr + " != &bbEmptyString")
		End If

'		If TIntType(ty) And TObjectType(src) Then
'			Return Bra(expr + " != &bbNullObject")
'		End If
		If TObjectType(ty) And TStringType(src) Then
			Return expr
		End If

		If Not TObjectType(ty) Or Not TObjectType(src) Then
			DebugStop
			InternalErr
		End If

		Local t$=TransType(ty, "TODO: TransPtrCast")

		If src.GetClass().IsInterface() Or ty.GetClass().IsInterface() cast="dynamic"

		If src.GetClass().IsInterface() And Not ty.GetClass().IsInterface() Then
			Return cast+"_cast<"+TransType(ty, "TODO: TransPtrCast")+">"+Bra( expr )
		End If

		'upcast?
		If src.GetClass().ExtendsClass( ty.GetClass() ) Return expr
		If TObjectType(ty) Then
			Return Bra(Bra(TransObject(TObjectType(ty).classDecl)) + "bbObjectDowncast" + Bra(expr + ",&" + TObjectType(ty).classDecl.munged))
		End If

		Return cast+"_cast<"+TransType(ty, "TODO: TransPtrCast")+">"+Bra( expr )

	End Method

	'***** Utility *****

	Method TransLocalDecl$( decl:TLocalDecl,init:TExpr, declare:Int = False, outputInit:Int = True )
		Local initTrans:String
		If outputInit Then
			initTrans = "=" + init.Trans()
		End If
	
		If Not declare And opt_debug Then
			Local ty:TType = decl.ty
			If Not TObjectType( ty ) Or (TObjectType( ty ) And Not TObjectType( ty ).classDecl.IsStruct()) Then
				If TIntrinsicType(ty) Then
					If Not TConstExpr(init) Then
						Return decl.munged + initTrans
					End If
				Else
					Return decl.munged + initTrans
				End If
			Else If TObjectType( ty ) And TObjectType( ty ).classDecl.IsStruct() Then
				If Not TConstExpr(init) Then
					Return decl.munged + initTrans
				End If
			End If
		Else
			If TFunctionPtrType(decl.ty) Then
				If TInvokeExpr(init) And Not TInvokeExpr(init).invokedWithBraces Then
					Return TransType( decl.ty, decl.munged ) + " = " + TInvokeExpr(init).decl.munged
				Else
					Return TransType( decl.ty, decl.munged ) + initTrans
				End If
			Else
				Local ty:TType = decl.ty
				If TVoidType( ty ) Or Not ty Then
					ty = init.exprType
				End If
				If TObjectType(ty) Then
					If TObjectType(ty).classdecl.IsExtern() Then
						If TObjectType(ty).classdecl.IsInterface() Then
							Return TransType( ty, decl.munged )+" "+decl.munged + initTrans
						Else
							Return TransType( ty, decl.munged )+" "+decl.munged + initTrans
						End If
					Else
						If TObjectType(ty).classdecl.IsStruct() Then
							Return TransType( ty, decl.munged )+" "+decl.munged + initTrans
						Else
							If decl.volatile Then
								Return TransType( ty, decl.munged )+" volatile "+decl.munged + initTrans
							Else
								Return TransType( ty, decl.munged )+" "+decl.munged + initTrans
							End If
						End If
					End If
				Else
					Return TransType( ty, decl.munged )+" "+decl.munged + initTrans
				End If
			End If
		End If
	End Method

	Method TransLocalDeclNoInit$( decl:TVarDecl )
		If TFunctionPtrType(decl.ty) Then
			Return TransType( decl.ty, decl.munged ) + "=" + TransValue(decl.ty, "")
		Else
			If TObjectType(decl.ty) Then
				If TObjectType(decl.ty).classdecl.IsExtern() Then
					If Not TObjectType(decl.ty).classdecl.IsStruct() Then
						Return TransType( decl.ty, decl.munged )+" "+decl.munged+"=" + TransValue(decl.ty, "")
					Else
						Return TransType( decl.ty, decl.munged )+" "+decl.munged
					End If
				Else
					If Not TObjectType(decl.ty).classdecl.IsStruct() Then
						If TLocalDecl(decl) And TLocalDecl(decl).volatile Then
							Return TransType( decl.ty, decl.munged )+" volatile "+decl.munged + "=" + TransValue(decl.ty, "")
						Else
							Return TransType( decl.ty, decl.munged )+" "+decl.munged + "=" + TransValue(decl.ty, "")
						End If
					Else
						Return TransType( decl.ty, decl.munged )+" "+decl.munged + "=" + TransValue(decl.ty, "")
					End If
				End If
			Else
				Return TransType( decl.ty, decl.munged )+" "+decl.munged + "=" + TransValue(decl.ty, "")
			End If
		End If
	End Method

	Method TransGlobalDecl$( gdecl:TGlobalDecl )
		Local glob:String

		If Not gdecl.funcGlobal Then
			If Not (gdecl.attrs & DECL_INITONLY) Then
				glob :+"static " + TransType( gdecl.init.exprType, gdecl.munged )+" "
			End If
	
			glob :+ gdecl.munged+"="
	
			If (TNewObjectExpr(gdecl.init) Or TNewArrayExpr(gdecl.init)) And Not (gdecl.attrs & DECL_INITONLY) Then
				glob :+ "0;~n"
				glob :+ indent + "if (" + gdecl.munged + "==0) {~n"
				glob :+ indent + "~t" + gdecl.munged + "=" + gdecl.init.Trans() + ";~n"
				glob :+ indent + "}"
			Else If TArrayExpr(gdecl.init) And Not (gdecl.attrs & DECL_INITONLY) Then
				glob :+ "0;~n"
				Emit glob
				Emit "if (" + gdecl.munged + "==0) {"
				
				glob = gdecl.munged + "=" + gdecl.init.Trans() + ";"
				Emit glob
				Emit "}"
				glob = ""
			Else
				If gdecl.init Then
					If TFunctionPtrType(gdecl.ty) Then
						If TInvokeExpr(gdecl.init) And Not TInvokeExpr(gdecl.init).invokedWithBraces Then
							glob :+ TInvokeExpr(gdecl.init).decl.munged
						Else
							glob :+ gdecl.init.Trans()
						End If
					Else If Not TConstExpr(gdecl.init) And Not (gdecl.attrs & DECL_INITONLY) Then
						' for non const, we need to add an initialiser
						glob :+ TransValue(gdecl.ty, "") + ";~n"
						glob :+ indent +"static int _" + gdecl.munged + "_inited = 0;~n"
						glob :+ indent + "if (!_" + gdecl.munged + "_inited) {~n"
						glob :+ indent + "~t_" + gdecl.munged + "_inited = 1;~n"
						glob :+ indent + "~t" + gdecl.munged + " = " + gdecl.init.Trans() + ";~n"
						glob :+ indent + "}"
					Else
						glob :+ gdecl.init.Trans()
					End If
				Else
					If TFunctionPtrType(gdecl.ty) Then
						glob :+ "&brl_blitz_NullFunctionError"
					Else
						glob :+ "0"
					End If
				End If
			End If
		Else
			glob :+ "static int _" + gdecl.munged + "_inited = 0;~n"
			glob :+ indent + "if (!_" + gdecl.munged + "_inited) {~n"
			glob :+ indent + "~t_" + gdecl.munged + "_inited = 1;~n"
			glob :+ indent + "~t" + gdecl.munged + " = " 
			If gdecl.init Then
				glob :+ gdecl.init.Trans()
			Else
				glob :+ TransValue(gdecl.ty, "")
			End If
			glob :+ ";~n"
			glob :+ indent + "}"
		End If

		Return glob
	End Method

	Method CreateLocal2$( ty:TType, t$ )
		Local tmp:TLocalDecl=New TLocalDecl.Create( "", ty,Null, True )
		MungDecl tmp
		If TShortType(ty) Then
			Emit TransType(ty, "") + " " + tmp.munged + " = bbStringToWString" + Bra(t)+ ";"
		Else
			Emit TransType(ty, "") + " " + tmp.munged + " = bbStringToCString" + Bra(t)+ ";"
		End If
		customVarStack.Push(tmp.munged)
		Return tmp.munged
	End Method

	Method EmitPushErr()
		Emit "pushErr();"
	End Method

	Method EmitSetErr( info$ )
		Emit "errInfo=~q"+info.Replace( "\","/" )+"~q;"
	End Method

	Method EmitPopErr()
		Emit "popErr();"
	End Method

	'***** Declarations *****

	Method TransStatic$( decl:TDecl )
		If decl.IsExtern() Then
			If Not decl.munged
				Return decl.ident
			End If
			Return decl.munged
		Else If _env And decl.scope And decl.scope=_env.ClassScope()
			' calling a class function from a method?
			If TFuncDecl(decl) And _env.ClassScope() And _env.FuncScope() And _env.FuncScope().IsMethod() And Not (decl.attrs & FUNC_PTR) Then
				Local scope:TScopeDecl = _env.ClassScope()
				Local obj:String = Bra("struct " + scope.munged + "_obj*")
				Local class:String = "o->clas"
				Return class + "->f_" + decl.ident + MangleMethod(TFuncDecl(decl))
			Else
				Return decl.munged
			End If
		Else If TClassDecl( decl.scope )
			'Return decl.scope.munged+"::"+decl.munged
			Return decl.munged
		Else If TModuleDecl( decl.scope )
			Return decl.munged
		Else If TFuncDecl(decl.scope)
			Return decl.munged
		Else If TGlobalDecl(decl)
			Return decl.munged
		Else If TBlockDecl(decl.scope)
			Return decl.munged
		EndIf
		InternalErr
	End Method

	Method TransTemplateCast$( ty:TType,src:TType,expr$ )

		' *sigh*
		' if var is going to var, remove any leading dereference character.
		' rather hacky. Would be better to cast variable to varptr during semanting (well done if you can work out where!)
		'If src.EqualsType( ty.ActualType() ) And (ty._flags & TType.T_VAR) And (src._flags & TType.T_VAR) Then
		'	If expr.startswith("*") Then
		'		expr = expr[1..]
		'	End If
		'End If

		If ty=src Return expr

		ty=ty.ActualType()
		'src=src.ActualType()

		If src.EqualsType( ty ) Return expr

		Return TransPtrCast( ty,src,expr,"static" )

	End Method

	Method TransGlobal$( decl:TGlobalDecl )
		Return TransStatic( decl )
	End Method

	Method TransField$( decl:TFieldDecl,lhs:TExpr )

		If lhs Then
			Return TransFieldRef(decl, TransSubExpr( lhs ), lhs.exprType)
		Else
			Return TransFieldRef(decl, "o", Null)
		End If
'		Local swiz$
'		If TObjectType( decl.ty )
'			If TObjectType( decl.ty ).classDecl.IsInterface() swiz=".p"
'		EndIf
'		If lhs Return TransSubExpr( lhs )+"->"+decl.munged+swiz
'		Return decl.munged+swiz
	End Method

	Method TransFunc$( decl:TFuncDecl,args:TExpr[],lhs:TExpr, sup:Int = False, scope:TScopeDecl = Null )
'If decl.ident = "eventfilter" DebugStop
		' for calling the super class method instead
		Local tSuper:String
		If sup Then
			tSuper = "->super"
		End If

		If Not decl.munged
			MungDecl decl
		End If

		'If decl.IsMethod()
			If lhs And Not TSelfExpr(lhs) Then
				If TStringType(lhs.exprType) Then
					Return decl.munged + TransArgs(args, decl, TransSubExpr( lhs ))
				End If

				If TStmtExpr(lhs) Then
					lhs.Trans()
					lhs = TStmtExpr(lhs).expr
				End If

				If TVarExpr(lhs) Then
					Local cdecl:TClassDecl
					If TObjectType(TVarExpr(lhs).decl.ty) Then
						cdecl = TObjectType(TVarExpr(lhs).decl.ty).classDecl
					Else If TArrayType(TVarExpr(lhs).decl.ty) Then
						Return decl.munged+TransArgs( args,decl, TransSubExpr( lhs ) )
					End If

					If decl.attrs & FUNC_PTR Then
						'Return "(" + obj + TransSubExpr( lhs ) + ")->" + decl.munged+TransArgs( args,decl, Null)
						Return TransSubExpr( lhs ) + "->" + decl.munged+TransArgs( args,decl, Null)
					Else
						'Local lvar:String = CreateLocal(lhs, False)
						'Local lvarInit:String = Bra(lvar + " = " + lhs.Trans())
						
						If decl.scope.IsExtern()
							If Not cdecl.IsStruct()  Then
								'Return decl.munged + Bra(TransArgs( args,decl, TransSubExpr( lhs ) ))
								Return Bra(TransSubExpr( lhs )) + "->vtbl->" + decl.munged + Bra(TransArgs( args,decl, TransSubExpr( lhs ) ))
								'Return Bra(lvarInit) + "->vtbl->" + decl.munged + Bra(TransArgs( args,decl, lvar ))
							End If
							Err "TODO extern types not allowed methods"
						Else
							If cdecl.IsInterface() And Not equalsBuiltInFunc(cdecl, decl) Then
								Local ifc:String = Bra("(struct " + cdecl.munged + "_methods*)" + Bra("bbObjectInterface(" + TransSubExpr( lhs ) + ", " + "&" + cdecl.munged + "_ifc)"))
								Return ifc + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, TransSubExpr( lhs ) )
'								Local ifc:String = Bra("(struct " + cdecl.munged + "_methods*)" + Bra("bbObjectInterface(" + lvarInit + ", " + "&" + cdecl.munged + "_ifc)"))
'								Return ifc + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
							Else
								If cdecl.IsStruct() Then
									If Not isPointerType(lhs.exprType) Then
										Return "_" + decl.munged+TransArgs( args,decl, "&" + TransSubExpr( lhs ) )
									Else
										Return "_" + decl.munged+TransArgs( args,decl, TransSubExpr( lhs ) )
									End If
								Else
									Local class:String = Bra(TransSubExpr( lhs )) + "->clas" + tSuper
									Return class + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, TransSubExpr( lhs ) )
'									Local class:String = Bra(lvarInit) + "->clas" + tSuper
'									Return class + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
								End If
							End If
						End If
					End If
				Else If TNewObjectExpr(lhs) Then
					Local cdecl:TClassDecl = TNewObjectExpr(lhs).classDecl
					If cdecl.IsStruct() Then
						' create a local variable of the inner invocation
						Local lvar:String = CreateLocal(lhs)
						Return "_" + decl.munged+TransArgs( args,decl, "&" + lvar )
					Else
						Local class:String = cdecl.munged
						Return class + "." + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, TransSubExpr( lhs ) )
					End If
				Else If TCastExpr(lhs) Then
					' create a local variable of the inner invocation
					Local lvar:String = CreateLocal(lhs, False, False)
					Local lvarInit:String = Bra(lvar + " = " + lhs.Trans())

					Local cdecl:TClassDecl = TObjectType(TCastExpr(lhs).ty).classDecl
					Local obj:String = Bra(TransObject(cdecl))
					If decl.attrs & FUNC_PTR Then
						Return "(" + obj + TransSubExpr( lhs ) + ")->" + decl.munged+TransArgs( args,decl, Null)
					Else
						' Null test
						If opt_debug Then
							lvarInit = TransDebugNullObjectError(lvarInit, cdecl)
						End If

						If cdecl.IsInterface() And Not equalsBuiltInFunc(cdecl, decl) Then
							Local ifc:String = Bra("(struct " + cdecl.munged + "_methods*)" + Bra("bbObjectInterface(" + obj + lvarInit + ", " + "&" + cdecl.munged + "_ifc)"))
							Return ifc + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
						Else
							Local class:String = Bra("(" + obj + lvarInit + ")->clas" + tSuper)
							Return class + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
						End If
					End If

				Else If TMemberVarExpr(lhs) Then
					If TObjectType(TMemberVarExpr(lhs).decl.ty) Then
						Local cdecl:TClassDecl = TObjectType(TMemberVarExpr(lhs).decl.ty).classDecl
						Local obj:String = Bra(TransObject(cdecl))
					
						If decl.scope.IsExtern()
							If TClassDecl(decl.scope) And Not TClassDecl(decl.scope).IsStruct() Then
								Local lvar:String = CreateLocal(lhs, False, False)
								Local lvarInit:String = Bra(lvar + " = " + lhs.Trans())
									
								Return Bra(lvarInit) + "->vtbl->" + decl.munged + Bra(TransArgs( args,decl, lvar ))
							Else
								Return decl.munged + Bra(TransArgs( args,decl, TransSubExpr( lhs ) ))
							End If
						Else
							If cdecl.IsStruct() Then

								' baaaaaaaaaaaaaaaaa
								If Not isPointerType(lhs.exprType) Then
									Return "_" + decl.munged+TransArgs( args,decl, "&" + TransSubExpr( lhs ) )
								Else
									Return "_" + decl.munged+TransArgs( args,decl, TransSubExpr( lhs ) )
								End If
							
							Else
								If decl.attrs & FUNC_PTR Then
									Return "(" + obj + TransSubExpr( lhs ) + ")->" + decl.munged+TransArgs( args,decl, Null)
								Else
									Local lvar:String = CreateLocal(lhs, False, False)
									Local lvarInit:String = Bra(lvar + " = " + lhs.Trans())
									
									' Null test
									If opt_debug Then
										lvarInit = TransDebugNullObjectError(lvarInit, cdecl)
									End If
		
									Local class:String = Bra("(" + obj + lvarInit + ")->clas" + tSuper)
									Return class + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
								End If
							End If
						End If
						
					Else If TArrayType(TMemberVarExpr(lhs).decl.ty) Then
						Return decl.munged+TransArgs( args,decl, TransSubExpr( lhs ) )
					End If

				Else If TInvokeExpr(lhs) Then

					If TClassDecl(decl.scope) And TClassDecl(decl.scope).IsStruct() Then
						' create a local variable of the inner invocation
						Local lvar:String = CreateLocal(lhs, True)

						If Not isPointerType(lhs.exprType) Then
							Return "_" + decl.munged+TransArgs( args,decl, "&" + lvar )
						Else
							Return "_" + decl.munged+TransArgs( args,decl, lvar)
						End If
					Else
						' create a local variable of the inner invocation
						Local lvar:String = CreateLocal(lhs, False, False)
						Local lvarInit:String = Bra(lvar + " = " + lhs.Trans())

						' Null test
						If opt_debug Then
							Local cdecl:TClassDecl = TClassDecl(decl.scope)
							lvarInit = TransDebugNullObjectError(lvarInit, cdecl)
						End If
	
						Local obj:String = Bra(TransObject(decl.scope))
						Local class:String = Bra("(" + obj + lvarInit +")->clas" + tSuper)
						Return class + "->" + TransFuncPrefix(decl.scope, decl)+ FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )

					End If
					'Local obj:String = Bra("struct " + decl.scope.munged + "_obj*")
					'Local class:String = Bra("(" + obj + TransSubExpr( lhs ) +")->clas" + tSuper)
					'Local class:String = Bra("&" + decl.scope.munged)
					'Return class + "->" + TransFuncPrefix(decl.scope, decl.ident) + decl.ident+TransArgs( args,decl, TransSubExpr( lhs ) )
				Else If TInvokeMemberExpr(lhs)
					' create a local variable of the inner invocation
					
					Local lvar:String
					Local lvarInit:String
					
					If Not decl.scope.IsExtern() And TClassDecl(decl.scope) And TClassDecl(decl.scope).IsStruct() Then
						lvar = CreateLocal(lhs, True)
					Else
						lvar = CreateLocal(lhs, False, False)
						lvarInit = Bra(lvar + " = " + lhs.Trans())
					End If

					If decl.scope.IsExtern()
						If TClassDecl(decl.scope) And Not TClassDecl(decl.scope).IsStruct() Then
							Return Bra(lvarInit) + "->vtbl->" + decl.munged + Bra(TransArgs( args,decl, lvar ))
						End If
						
						Return "// TODO"
					Else
						If TClassDecl(decl.scope) And TClassDecl(decl.scope).IsStruct() Then
							If Not isPointerType(lhs.exprType) Then
								Return "_" + decl.munged+TransArgs( args,decl, "&" + lvar )
							Else
								Return "_" + decl.munged+TransArgs( args,decl, lvar )
							End If
						Else
							Local cdecl:TClassDecl = TClassDecl(decl.scope)
							' Null test
							If opt_debug Then
								lvarInit = TransDebugNullObjectError(lvarInit, cdecl)
							End If
							If cdecl.IsInterface() And Not equalsBuiltInFunc(cdecl, decl) Then
								Local obj:String = Bra(TransObject(cdecl))
								Local ifc:String = Bra("(struct " + cdecl.munged + "_methods*)" + Bra("bbObjectInterface(" + obj + lvarInit + ", " + "&" + cdecl.munged + "_ifc)"))
								Return ifc + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
							Else
								Local obj:String = lvarInit + "->clas" + tSuper
								Return obj + "->" + TransFuncPrefix(decl.scope, decl)+ FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
							End If
						End If
					End If

				Else If TIndexExpr(lhs) Then
					Local lvar:String = CreateLocal(lhs, False, False)
					Local lvarInit:String = Bra(lvar + " = " + lhs.Trans())
				
'					Local loc:String = CreateLocal(lhs)
					Local obj:String = Bra(TransObject(decl.scope))

					Local cdecl:TClassDecl = TClassDecl(decl.scope)

					' Null test
					If opt_debug Then
						lvarInit = TransDebugNullObjectError(lvarInit, cdecl)
					End If

					If decl.attrs & FUNC_PTR Then
						Return lhs.Trans() + "->" + decl.munged+TransArgs( args,decl, Null)
					Else
						If decl.scope.IsExtern()
							'Local cdecl:TClassDecl = TClassDecl(decl.scope)
							
							If Not cdecl.IsStruct()  Then
								Return Bra(lvarInit) + "->vtbl->" + decl.munged + Bra(TransArgs( args,decl, lvar ))
							End If
							Err "TODO extern types not allowed methods"
						Else
							'Local cdecl:TClassDecl = TClassDecl(decl.scope)
	
							If cdecl And (cdecl.IsInterface() And Not equalsBuiltInFunc(cdecl, decl)) Then
								Local ifc:String = Bra("(struct " + cdecl.munged + "_methods*)" + Bra("bbObjectInterface(" + obj + lvarInit + ", " + "&" + cdecl.munged + "_ifc)"))
								Return ifc + "->" + TransFuncPrefix(cdecl, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
							Else					
								Local class:String = Bra(lvarInit + "->clas" + tSuper)
								Return class + "->" + TransFuncPrefix(decl.scope, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, lvar )
							End If
						End If
					End If
				Else
					InternalErr
				End If
				'Return TransSubExpr( lhs )+"->"+decl.munged+TransArgs( args,decl )
				'Return decl.munged+TransArgs( args,decl, TransSubExpr( lhs ) )
			End If

			' ((brl_standardio_TCStandardIO_obj*)o->clas)->md_Read(o, xxx, xxx)
		If decl.IsMethod() Then
			If  Not (decl.attrs & FUNC_PTR) Then

				Local class:String
				
				If Not scope Then
					scope = decl.scope

					If TClassDecl(scope) And Not TClassDecl(scope).IsStruct() Then
						Local obj:String = Bra(TransObject(scope))
						class = "(" + obj + "o)->clas" + tSuper

						' Null test
						If opt_debug Then
							Emit TransDebugNullObjectError("o", TClassDecl(scope)) + ";"
						End If
					End If
				Else

					class = Bra("&" + scope.munged) + tSuper

				End If
				
				'Local obj:String = Bra("struct " + scope.munged + "_obj*")
				'Local class:String = Bra("(" + obj + "o)->clas" + tSuper)
				'Local class:String = Bra("&" + decl.scope.munged)
				If TClassDecl(scope).IsStruct() Then
					Return "_" + decl.munged+TransArgs( args,decl, "o" )
				Else
					Return class + "->" + TransFuncPrefix(scope, decl) + FuncDeclMangleIdent(decl)+TransArgs( args,decl, "o" )
				End If
			Else
				' Null test
				If opt_debug Then
					Emit TransDebugNullObjectError("o", TClassDecl(decl.scope)) + ";"
				End If
				
				Local obj:String
				If TClassDecl(scope) And Not TClassDecl(scope).IsStruct() Then
					obj = Bra(TransObject(decl.scope))
				End If
				Return Bra(obj + "o") + "->" + decl.munged+TransArgs( args,decl )
			End If
		End If
		
		Return TransStatic( decl )+TransArgs( args,decl )
	End Method

	Method TransObject:String(decl:TScopeDecl, this:Int = False)
		If decl.ident = "Object"
			Return "BBOBJECT"
		Else
			If TClassDecl(decl) And TClassDecl(decl).IsStruct() Then
				Local t:String = "struct "
				If decl.IsExtern() Then
					t :+ decl.ident
				Else
					t :+ decl.munged
				End If
				
				If this Then
					Return t + "*"
				Else
					Return t
				End If

			Else
				If decl.IsExtern() Then
					Return "struct " + decl.ident + "*"
				Else
					Return "struct " + decl.munged + "_obj*"
				End If
			End If
		End If
	End Method

	Method TransFuncClass:String(decl:TClassDecl)
		If decl.ident = "Object"
			Return Bra("&bbObjectClass")
		Else
			Return Bra("&" + decl.munged)
		End If
	End Method

	Method TransFuncPrefix:String(decl:TScopeDecl, fdecl:TFuncDecl)
		Local ident:String = fdecl.ident

		If Not decl Or decl.ident = "Object" Or equalsBuiltInFunc(fdecl.ClassScope(), fdecl)
			Return ""
		Else
			If fdecl.IsMethod() Then
				Return "m_"
			Else
				Return "f_"
			End If
		End If
	End Method

	Method TransSuperFunc$( decl:TFuncDecl,args:TExpr[], scope:TScopeDecl )
		Return TransFunc(decl, args, Null, True, scope)
'		If decl.IsMethod()
'			Return decl.ClassScope().munged+".md_"+decl.ident+TransArgs( args,decl, "o" )
'		Else
'			Return decl.ClassScope().munged+".fn_"+decl.ident+TransArgs( args,decl)
'		End If
	End Method

	Method TransMinExpr:String(expr:TMinExpr)
		Local s:String
		If TDecimalType(expr.exprType) Then
			s = "bbFloatMin"
		Else If TLongType(expr.exprType) Then
			s = "bbLongMin"
		Else If TSizeTType(expr.exprType) Then
			s = "bbSizetMin"
		Else If TUIntType(expr.exprType) Then
			s = "bbUIntMin"
		Else If TULongType(expr.exprType) Then
			s = "bbULongMin"
		Else
			s = "bbIntMin"
		End If

		Return s + Bra(expr.expr.trans() + "," + expr.expr2.Trans())
	End Method

	Method TransMaxExpr:String(expr:TMaxExpr)
		Local s:String
		If TDecimalType(expr.exprType) Then
			s = "bbFloatMax"
		Else If TLongType(expr.exprType) Then
			s = "bbLongMax"
		Else If TSizeTType(expr.exprType) Then
			s = "bbSizetMax"
		Else If TUIntType(expr.exprType) Then
			s = "bbUIntMax"
		Else If TULongType(expr.exprType) Then
			s = "bbULongMax"
		Else
			s = "bbIntMax"
		End If
		Return s + Bra(expr.expr.trans() + "," + expr.expr2.Trans())
	End Method

	Method TransAscExpr:String(expr:TAscExpr)
		Return "bbStringAsc" + Bra(expr.expr.Trans())
	End Method

	Method TransChrExpr:String(expr:TChrExpr)
		Return "bbStringFromChar" + Bra(expr.expr.Trans())
	End Method

	Method TransSgnExpr:String(expr:TSgnExpr)
		Local s:String
		If TFloatType(expr.expr.exprType) Or TDoubleType(expr.expr.exprType)
			'decl.ident contains "sgn", same like "bbFloatSng"
			s = "bbFloatSgn"
		Else If TLongType(expr.expr.exprType) Then
			s = "bbLongSgn"
		Else If TSizeTType(expr.expr.exprType) Then
			s = "bbSizetSgn"
		Else If TUIntType(expr.expr.exprType) Then
			s = "bbUIntSgn"
		Else If TULongType(expr.expr.exprType) Then
			s = "bbULongSgn"
		Else
			s = "bbIntSgn"
		End If
		Return s + Bra(expr.expr.Trans())
	End Method

	Method TransAbsExpr:String(expr:TAbsExpr)
		Local s:String
		If TDecimalType(expr.exprType) Then
			s = "bbFloatAbs"
		Else If TLongType(expr.exprType)
			s = "bbLongAbs"
		Else If TSizeTType(expr.exprType)
			s = "bbSizetAbs"
		Else If TUIntType(expr.exprType)
			s = "bbUIntAbs"
		Else If TULongType(expr.exprType)
			s = "bbULongAbs"
		Else
			s = "bbIntAbs"
		End If
		Return s + Bra(expr.expr.Trans())
	End Method

	Method TransLenExpr:String(expr:TLenExpr)
		'constant strings do not have "->length", so we use the
		'precalculated value
		If TConstExpr(expr.expr) Then
			If TStringType(expr.expr.exprType) Then
				Return TConstExpr(expr.expr).value.Length
			End If
		End If
		
		If TStringType(expr.expr.exprType) Then
			Return Bra(expr.expr.Trans()) + "->length"
		Else If TArrayType(expr.expr.exprType) Then
			Return Bra(expr.expr.Trans()) + "->scales[0]"
		Else If TCastExpr(expr.expr) Then
			If TArrayType(TCastExpr(expr.expr).expr.exprType) Then
				Return Bra(TCastExpr(expr.expr).expr.Trans()) + "->scales[0]"
			End If
		'other types just have a length of "1"
		Else
			Return "1"
		End If
	End Method

	Method TransSizeOfExpr:String(expr:TSizeOfExpr)
		Local cexpr:TConstExpr = TConstExpr(expr.expr)
		If cexpr Then
			If TNumericType(cexpr.exprType) Then
				Return "sizeof" + Bra(TransType(cexpr.exprType, ""))

			' strings
			Else If TStringType(cexpr.exprType) Then
				' length of const string * 2 bytes per char
				Return Len(cexpr.value) * 2
			End If
		Else
			If TNumericType(expr.expr.exprType) Then
				' remove Var-ness first, if any
				Local t:TType = expr.expr.exprType.Copy()
				If t._flags & TType.T_VAR Then
					t._flags :~ TType.T_VAR
				End If

				Return "sizeof" + Bra(TransType(t, ""))

			' strings
			Else If TStringType(expr.expr.exprType) Then
				'unicode chars each take 2 bytes
				Return Bra(expr.expr.Trans()) + "->length * 2"

			' arrays
			Else If TArrayType(expr.expr.exprType) Then
				'normal exprType is something like "int[]" that
				'is why it has to be checked against elemType
				Local elemType:TType = TArrayType( expr.expr.exprType ).elemType

				' numerics - including numeric pointers
				If TNumericType(elemType) Then
					'multiply element count * size of element type
					Return Bra(expr.expr.Trans()) + "->scales[0] * sizeof" + Bra(TransType(elemType, ""))

				' everything else : string, array, object, function pointer - are all pointers
				Else
					'arrays of objects are of size: elementCount * pointerSize
					Return  Bra(expr.expr.Trans()) + "->scales[0] * sizeof(void*)"
				EndIf
			
			' objects
			Else If TObjectType(expr.expr.exprType) Then
				If TObjectType( expr.expr.exprType ).classDecl.ident = "Object" Then
					Return "0"
				Else
					Local cdecl:TClassDecl = TObjectType( expr.expr.exprType ).classDecl
					
					If cdecl.IsStruct() Then
						If TIdentTypeExpr(expr.expr) Then
							If cdecl.IsExtern() Then
								Return "sizeof" + Bra("struct " + cdecl.ident)
							Else
								Return "sizeof" + Bra("struct " + cdecl.munged)
							End If
						Else
							Return "sizeof" + Bra(expr.expr.Trans())
						End If
					Else
					
						If TIdentTypeExpr(expr.expr) Then
							Return Bra(Bra(TransFuncClass(cdecl)) + "->obj_size")
						Else
							Return Bra(Bra(expr.expr.Trans()) + "->clas->obj_size")
						End If
						
					End If
				End If
			End If
		End If

		InternalErr
	End Method

	'***** Expressions *****

	Method TransConstExpr$( expr:TConstExpr )
		If TStringType(expr.exprType) Then
			Return TransStringConst(expr.value)
		Else
			Return TransValue( expr.exprType,expr.value )
		End If
	End Method

	Field stringMap:TMap = New TMap

	Method TransStringConst:String(value:String)
		If value Then
			_appInstance.mapStringConsts(value)
		End If
		Local sc:TStringConst = TStringConst(_app.stringConsts.ValueForKey(value))
		Local s:String

		If Not sc Then
			s = "bbEmptyString"
		Else
			If Not sc.count Then
				sc.count :+ 1
			End If
			s = sc.id
		End If

		Return "&" + s
	End Method

	Method TransNewObjectExpr$( expr:TNewObjectExpr )
		Local t$

		If Not expr.classDecl.IsStruct() And (Not expr.ctor.argDecls Or expr.ctor.argDecls.length = 0) Then
			If expr.instanceExpr Then
				t = "bbObjectNew(" + Bra(expr.instanceExpr.Trans()) + "->clas)"
			Else
				If ClassHasObjectField(expr.classDecl) Then
					t = "bbObjectNew(&" + expr.classDecl.actual.munged + ")"
				Else
					t = "bbObjectAtomicNew(&" + expr.classDecl.actual.munged + ")"
				End If
			End If
		Else

			Local ctorMunged:String
			
			If expr.classDecl = expr.ctor.scope Then
				ctorMunged = expr.ctor.munged
			Else
				ctorMunged = expr.classDecl.actual.munged + "_" + expr.ctor.ident + MangleMethod(expr.ctor)
			End If

			If expr.instanceExpr Then
				t = "_" + ctorMunged + "_ObjectNew" + TransArgs( expr.args,expr.ctor, Bra(expr.instanceExpr.Trans()) + "->clas" )
			Else
				If ClassHasObjectField(expr.classDecl) And Not expr.classDecl.IsStruct() Then
					t = "_" + ctorMunged + "_ObjectNew" + TransArgs( expr.args,expr.ctor, "&" + expr.classDecl.actual.munged )
				Else
					If expr.classDecl.IsStruct() Then
						t = "_" + ctorMunged + "_ObjectNew" + TransArgs( expr.args,expr.ctor)
					Else
						t = "_" + ctorMunged + "_ObjectNew" + TransArgs( expr.args,expr.ctor, "&" + expr.classDecl.actual.munged)
					End If
				End If
			End If
		End If
		'Local t$="(new "+expr.classDecl.actual.munged+")"
		'If expr.ctor t:+"->"+expr.ctor.actual.munged+TransArgs( expr.args,expr.ctor )
		Return t
	End Method

	Method TransNewArrayExpr$( expr:TNewArrayExpr )

		If expr.expr.length = 1 Then
			If TObjectType(expr.ty) And TObjectType(expr.ty).classdecl.IsStruct() And Not IsPointerType(expr.ty) Then
				Return "bbArrayNew1DStruct" + Bra(TransArrayType(expr.ty) + ", " + expr.expr[0].Trans() + ", sizeof" + Bra(TransObject(TObjectType(expr.ty).classdecl)))
			Else
				Return "bbArrayNew1D" + Bra(TransArrayType(expr.ty) + ", " + expr.expr[0].Trans())
			End If
		Else
			' multiple array
			Local s:String

			For Local i:Int = 0 Until expr.expr.length
				If i Then
					s:+ ", "
				End If

				s:+ expr.expr[i].Trans()
			Next

			Return "bbArrayNew" + Bra(TransArrayType(expr.ty) + ", " + expr.expr.length + ", " + s)
		End If

	End Method

	Method TransSelfExpr$( expr:TSelfExpr )
		Return "o"
	End Method

	Method TransIdentTypeExpr:String(expr:TIdentTypeExpr)
		Return "struct " + expr.cdecl.munged + "_obj"
	End Method

	Method TransCastExpr$( expr:TCastExpr )

		Local t$= expr.expr.Trans()

		Local dst:TType=expr.exprType
		Local src:TType=expr.expr.exprType
		
		If TNumericType(src) And (src._flags & TType.T_VAR) Then
			' var number being cast to a varptr 
			If (dst._flags & TType.T_VARPTR) Then
				Return "&" + Bra(t)
			End If
		End If

		If (dst._flags & TType.T_VARPTR) Or (dst._flags & TType.T_VAR) Then
			If Not TConstExpr(expr.expr) Then
				If TInvokeExpr(expr.expr) Return t

				If TByteType( src) Return Bra("&"+t)
				If TShortType( src) Return Bra("&"+t)
				If TFloatType( src) Return Bra("&"+t)
				If TIntType( src) Return Bra("&"+t)
				If TUIntType( src) Return Bra("&"+t)
				If TLongType( src) Return Bra("&"+t)
				If TULongType( src) Return Bra("&"+t)
				If TSizeTType( src) Return Bra("&"+t)
				If TDoubleType( src) Return Bra("&"+t)
				If TInt128Type( src) Return Bra("&"+t)
				If TFloat128Type( src) Return Bra("&"+t)
				If TDouble128Type( src) Return Bra("&"+t)
				If TFloat64Type( src) Return Bra("&"+t)
				If TWParamType( src) Return Bra("&"+t)
				If TLParamType( src) Return Bra("&"+t)

				If TObjectType(src) Then
					If TObjectType(src).classDecl.IsExtern() Or (dst._flags & TType.T_VARPTR) Then
						Return Bra("&" + t)
					Else
						If TObjectType(dst) Then
							Return Bra("&" + t)
						Else
							Return Bra(Bra("(BBBYTE*)" + Bra("&" + t)) + "+" + Bra("sizeof(void*)"))
						End If
					End If
				End If
				
				If TFunctionPtrType(src) Return Bra("&"+t)
				'If TPointerType( src) Return Bra("&"+t)
			Else
				Return Bra(TransValue(TConstExpr(expr.expr).ty, TConstExpr(expr.expr).value))
			End If
		Else If IsPointerType( dst, 0, TType.T_POINTER | TType.T_CHAR_PTR | TType.T_SHORT_PTR )

			If TArrayType(src) Then
				Return Bra(Bra(TransType(dst, "")) + "BBARRAYDATA(" + t + "," + t + "->dims)")
			End If
			'If TByteType(src) And Not IsPointerType(src, TType.T_BYTE, TType.T_POINTER) Return Bra("&"+t)

			If TStringType(src) Then
				Local tmp:String

				If IsPointerType( dst, 0, TType.T_SHORT_PTR ) Or IsPointerType( dst, TType.T_SHORT, TType.T_PTR ) Then
					tmp = CreateLocal2(NewPointerType(TType.T_SHORT), t)
				Else
					tmp = CreateLocal2(NewPointerType(TType.T_BYTE), t)
				End If

				Return tmp
			End If
			
			If (TStringType(dst) And IsPointerType( dst, 0, TType.T_CHAR_PTR | TType.T_SHORT_PTR )) And TNullType(src) Then
				Return "0"
			End If

			If TObjectType(src) Then
				If TObjectType(src).classDecl.IsExtern() Or (src._flags & TType.T_VARPTR) Then
					Return Bra(t)
				Else
					Return Bra(Bra("(BBBYTE*)" + t) + "+" + Bra("sizeof(void*)"))
				End If
			End If

			Local p:String = TransSPointer(dst)
			If TByteType( dst )
				If IsPointerType(src, TType.T_BYTE, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBBYTE" + p + ")"+t)
			Else If TShortType( dst )
				If IsPointerType(src, TType.T_SHORT, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBSHORT" + p + ")"+t)
			Else If TIntType( dst )
				If IsPointerType(src, TType.T_INT, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBINT" + p + ")"+t)
			Else If TUIntType( dst )
				If IsPointerType(src, TType.T_UINT, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBUINT" + p + ")"+t)
			Else If TFloatType( dst )
				If IsPointerType(src, TType.T_FLOAT, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBFLOAT" + p + ")"+t)
			Else If TDoubleType( dst )
				If IsPointerType(src, TType.T_DOUBLE, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBDOUBLE" + p + ")"+t)
			Else If TLongType( dst )
				If IsPointerType(src, TType.T_LONG, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBLONG" + p + ")"+t)
			Else If TULongType( dst )
				If IsPointerType(src, TType.T_ULONG, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBULONG" + p + ")"+t)
			Else If TSizeTType( dst )
				If IsPointerType(src, TType.T_SIZET, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBSIZET" + p + ")"+t)
			Else If TWParamType( dst )
				If IsPointerType(src, TType.T_WPARAM, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(WPARAM" + p + ")"+t)
			Else If TLParamType( dst )
				If IsPointerType(src, TType.T_LPARAM, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(LPARAM" + p + ")"+t)
			Else If TInt128Type( dst )
				If IsPointerType(src, TType.T_INT128, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBINT128" + p + ")"+t)
			Else If TFloat128Type( dst )
				If IsPointerType(src, TType.T_FLOAT128, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBFLOAT128" + p + ")"+t)
			Else If TDouble128Type( dst )
				If IsPointerType(src, TType.T_DOUBLE128, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBDOUBLE128" + p + ")"+t)
			Else If TFloat64Type( dst )
				If IsPointerType(src, TType.T_FLOAT64, TType.T_POINTER & dst._flags) Return t
				If TNumericType( src ) Return Bra("(BBFLOAT64" + p + ")"+t)
				
			'Else If TIntPtrPtrType( dst )
			'	If TBytePtrType( src) Return Bra("(BBINT**)"+t)
			'	If TShortPtrType( src ) Return Bra("(BBINT**)"+t)
			'	If TIntPtrType( src ) Return Bra("(BBINT**)"+t)
			'	If TFloatPtrType( src ) Return Bra("(BBINT**)"+t)
			'	If TDoublePtrType( src ) Return Bra("(BBINT**)"+t)
			'	If TLongPtrType( src ) Return Bra("(BBINT**)"+t)
			'	If TNumericType( src ) Return Bra("(BBINT**)"+t)
			End If
		Else If TBoolType( dst )
			If TFunctionPtrType(src) Return Bra(Bra( t+"!=0" ) + " && " + Bra( t+"!=&brl_blitz_NullFunctionError" ))
			'If TFunctionPtrType(src) Return Bra( t+"!=0" )
			If IsPointerType( src, 0, TType.T_POINTER ) Return Bra( t )
			If TBoolType( src ) Return t
			If TByteType( src ) Return Bra( t+"!=0" )
			If TShortType( src ) Return Bra( t+"!=0" )
			If TIntType( src ) Return Bra( t+"!=0" )
			If TUIntType( src ) Return Bra( t+"!=0" )
			If TFloatType( src ) Return Bra( t+"!=0.0f" )
			'If TCastExpr(expr.expr) And (TArrayType( src ) Or TStringType( src ) Or TObjectType( src )) Then
			'	Return Bra( t+"!= &bbNullObject" )
			'End If
			If TLongType( src ) Return Bra( t+"!=0" )
			If TULongType( src ) Return Bra( t+"!=0" )
			If TSizeTType( src ) Return Bra( t+"!=0" )
			If TWParamType( src ) Return Bra( t+"!=0" )
			If TLParamType( src ) Return Bra( t+"!=0" )
			If TDoubleType( src ) Return Bra( t+"!=0.0f" )
			If TArrayType( src ) Return Bra( t+"!= &bbEmptyArray" )
			If TStringType( src ) Return Bra( t+"!= &bbEmptyString" )
			If TObjectType( src ) Then
				If TObjectType(src).classDecl.IsExtern() Then
					If Not TObjectType(src).classDecl.IsStruct() Then
						Return Bra( t+"!=0" )
					Else
						Return Bra("1")
					End If
				Else
					Return Bra( t+"!= &bbNullObject" )
				End If
			End If
		Else If TIntType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src) Return Bra("(BBINT)"+t)
			If TShortType( src) Return Bra("(BBINT)"+t)
			If TBoolType( src ) Return t
			If TIntType( src ) Return t
			If TUIntType( src ) Return Bra("(BBINT)"+t)
			If TFloatType( src ) Return Bra("(BBINT)"+t)
			If TDoubleType( src ) Return Bra("(BBINT)"+t)
			If TLongType( src ) Return Bra("(BBINT)"+t)
			If TULongType( src ) Return Bra("(BBINT)"+t)
			If TSizeTType( src ) Return Bra("(BBINT)"+t)
			If TWParamType( src ) Return Bra("(BBINT)"+t)
			If TLParamType( src ) Return Bra("(BBINT)"+t)
			If TStringType( src ) Return "bbStringToInt" + Bra(t)
			'If TIntVarPtrType( src ) Return Bra("*" + t)
			If IsPointerType(src,0,TType.T_POINTER) Return Bra("(BBINT)"+t)
			'If TPointerType( src ) Return Bra("(BBINT)"+t)
		 Else If TLongType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src) Return Bra("(BBLONG)"+t)
			If TShortType( src) Return Bra("(BBLONG)"+t)
			If TIntType( src) Return Bra("(BBLONG)"+t)
			If TUIntType( src) Return Bra("(BBLONG)"+t)
			If TLongType( src ) Return t
			If TULongType( src ) Return Bra("(BBLONG)"+t)
			If TSizeTType( src ) Return Bra("(BBLONG)"+t)
			If TWParamType( src ) Return Bra("(BBLONG)"+t)
			If TLParamType( src ) Return Bra("(BBLONG)"+t)
			If TFloatType( src ) Return Bra("(BBLONG)"+t)
			If TDoubleType( src ) Return Bra("(BBLONG)"+t)
			If TStringType( src ) Return "bbStringToLong" + Bra(t)
			If IsPointerType(src,0,TType.T_POINTER) Return Bra("(BBLONG)"+t)
			If TFloat64Type( src ) Return Bra("(BBLONG)"+t)
			'If TPointerType( src ) Return Bra("(BBLONG)"+t)
		 Else If TSizeTType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src) Return Bra("(BBSIZET)"+t)
			If TShortType( src) Return Bra("(BBSIZET)"+t)
			If TIntType( src) Return Bra("(BBSIZET)"+t)
			If TUIntType( src) Return Bra("(BBSIZET)"+t)
			If TLongType( src) Return Bra("(BBSIZET)"+t)
			If TULongType( src) Return Bra("(BBSIZET)"+t)
			If TSizeTType( src ) Return t
			If TWParamType( src ) Return Bra("(BBSIZET)"+t)
			If TLParamType( src ) Return Bra("(BBSIZET)"+t)
			If TFloatType( src ) Return Bra("(BBSIZET)"+t)
			If TDoubleType( src ) Return Bra("(BBSIZET)"+t)
			If TStringType( src ) Return "bbStringToSizet" + Bra(t)
			If IsPointerType(src,0,TType.T_POINTER) Return Bra("(BBSIZET)"+t)
			If TFloat64Type( src ) Return Bra("(BBSIZET)"+t)
			'If TPointerType( src ) Return Bra("(BBLONG)"+t)
		Else If TFloatType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src ) Return Bra("(BBFLOAT)"+t)
			If TIntType( src ) Return Bra("(BBFLOAT)"+t)
			If TUIntType( src ) Return Bra("(BBFLOAT)"+t)
			If TShortType( src ) Return Bra("(BBFLOAT)"+t)
			If TFloatType( src ) Return t
			If TDoubleType( src ) Return Bra("(BBFLOAT)"+t)
			If TLongType( src ) Return Bra("(BBFLOAT)"+t)
			If TULongType( src ) Return Bra("(BBFLOAT)"+t)
			If TSizeTType( src ) Return Bra("(BBFLOAT)"+t)
			If TWParamType( src ) Return Bra("(BBFLOAT)"+t)
			If TLParamType( src ) Return Bra("(BBFLOAT)"+t)
			If TStringType( src ) Return "bbStringToFloat" + Bra(t)
			'If TFloatVarPtrType( src ) Return Bra("*" + t)
			'If TPointerType( src ) Return Bra("(BBFLOAT)"+t)
		Else If TDoubleType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src ) Return Bra("(BBDOUBLE)"+t)
			If TIntType( src ) Return Bra("(BBDOUBLE)"+t)
			If TUIntType( src ) Return Bra("(BBDOUBLE)"+t)
			If TShortType( src ) Return Bra("(BBDOUBLE)"+t)
			If TDoubleType( src ) Return t
			If TFloatType( src ) Return Bra("(BBDOUBLE)"+t)
			If TLongType( src ) Return Bra("(BBDOUBLE)"+t)
			If TULongType( src ) Return Bra("(BBDOUBLE)"+t)
			If TSizeTType( src ) Return Bra("(BBDOUBLE)"+t)
			If TWParamType( src ) Return Bra("(BBDOUBLE)"+t)
			If TLParamType( src ) Return Bra("(BBDOUBLE)"+t)
			If TStringType( src ) Return "bbStringToDouble" + Bra(t)
			'If TDoubleVarPtrType( src ) Return Bra("*" + t)
			'If TPointerType( src ) Return Bra("(BBDOUBLE)"+t)
		Else If TStringType( dst )
			If IsPointerType(src, 0, TType.T_POINTER) Return "bbStringFromSizet"+Bra( t )
			If TBoolType( src ) Return "bbStringFromInt"+Bra( t )
			If TByteType( src ) Return "bbStringFromInt"+Bra( t )
			If TShortType( src ) Return "bbStringFromInt"+Bra( t )
			If TIntType( src ) Return "bbStringFromInt"+Bra( t )
			If TUIntType( src ) Return "bbStringFromUInt"+Bra( t )
			If TLongType( src ) Return "bbStringFromLong"+Bra( t )
			If TULongType( src ) Return "bbStringFromULong"+Bra( t )
			If TSizeTType( src ) Return "bbStringFromSizet"+Bra( t )
			If TWParamType( src ) Return "bbStringFromWParam"+Bra( t )
			If TLParamType( src ) Return "bbStringFromLParam"+Bra( t )
			If TFloatType( src ) Return "bbStringFromFloat"+Bra( t )
			If TDoubleType( src ) Return "bbStringFromDouble"+Bra( t )
			If TStringType( src ) Then
				If src._flags & TType.T_CHAR_PTR Then
					Return "bbStringFromCString"+Bra( t )
				End If
				If src._flags & TType.T_SHORT_PTR Then
					Return "bbStringFromWString"+Bra( t )
				End If
				If src._flags & TType.T_VAR Then
					If TSliceExpr( expr.expr ) Then
						Return "&" + Bra(t)
					End If
					Return t
				End If
				Return t
			End If
			'If TStringVarPtrType( src ) Then
			'	If TSliceExpr( expr.expr ) Then
			'		Return t
			'	End If
			'	Return "*" + t
			'End If
			'If TStringCharPtrType( src ) Return "bbStringFromCString"+Bra( t )
		'Else If TStringVarPtrType( dst )
'DebugStop
		Else If TByteType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src) Return t
			If TShortType( src ) Return Bra("(BBBYTE)"+t)
			If TIntType( src ) Return Bra("(BBBYTE)"+t)
			If TUIntType( src ) Return Bra("(BBBYTE)"+t)
			If TFloatType( src ) Return Bra("(BBBYTE)"+t)
			If TDoubleType( src ) Return Bra("(BBBYTE)"+t)
			If TLongType( src ) Return Bra("(BBBYTE)"+t)
			If TULongType( src ) Return Bra("(BBBYTE)"+t)
			If TSizeTType( src ) Return Bra("(BBBYTE)"+t)
			If TWParamType( src ) Return Bra("(BBBYTE)"+t)
			If TLParamType( src ) Return Bra("(BBBYTE)"+t)
			If TStringType( src ) Return "bbStringToInt" + Bra(t)
			'If TByteVarPtrType( src ) Return Bra("*" + t)
		Else If TShortType( dst )
			If TBoolType( src ) Return Bra( t )
			If TShortType( src) Return t
			If TByteType( src) Return Bra("(BBSHORT)"+t)
			If TIntType( src ) Return Bra("(BBSHORT)"+t)
			If TUIntType( src ) Return Bra("(BBSHORT)"+t)
			If TFloatType( src ) Return Bra("(BBSHORT)"+t)
			If TDoubleType( src ) Return Bra("(BBSHORT)"+t)
			If TLongType( src ) Return Bra("(BBSHORT)"+t)
			If TULongType( src ) Return Bra("(BBSHORT)"+t)
			If TSizeTType( src ) Return Bra("(BBSHORT)"+t)
			If TWParamType( src ) Return Bra("(BBSHORT)"+t)
			If TLParamType( src ) Return Bra("(BBSHORT)"+t)
			If TStringType( src ) Return "bbStringToInt" + Bra(t)
			'If TShortVarPtrType( src ) Return Bra("*" + t)
		Else If TUIntType( dst )
			If TBoolType( src ) Return Bra( t )
			If TShortType( src ) Return Bra("(BBUINT)"+t)
			If TByteType( src) Return Bra("(BBUINT)"+t)
			If TIntType( src ) Return Bra("(BBUINT)"+t)
			If TUIntType( src) Return t
			If TFloatType( src ) Return Bra("(BBUINT)"+t)
			If TDoubleType( src ) Return Bra("(BBUINT)"+t)
			If TLongType( src ) Return Bra("(BBUINT)"+t)
			If TULongType( src ) Return Bra("(BBUINT)"+t)
			If TSizeTType( src ) Return Bra("(BBUINT)"+t)
			If TWParamType( src ) Return Bra("(BBUINT)"+t)
			If TLParamType( src ) Return Bra("(BBUINT)"+t)
			If TStringType( src ) Return "bbStringToUInt" + Bra(t)
		Else If TULongType( dst )
			If TBoolType( src ) Return Bra( t )
			If TShortType( src ) Return Bra("(BBULONG)"+t)
			If TByteType( src) Return Bra("(BBULONG)"+t)
			If TIntType( src ) Return Bra("(BBULONG)"+t)
			If TUIntType( src ) Return Bra("(BBULONG)"+t)
			If TFloatType( src ) Return Bra("(BBULONG)"+t)
			If TDoubleType( src ) Return Bra("(BBULONG)"+t)
			If TLongType( src ) Return Bra("(BBULONG)"+t)
			If TULongType( src) Return t
			If TSizeTType( src ) Return Bra("(BBULONG)"+t)
			If TWParamType( src ) Return Bra("(BBULONG)"+t)
			If TLParamType( src ) Return Bra("(BBULONG)"+t)
			If TStringType( src ) Return "bbStringToULong" + Bra(t)
			If TFloat64Type( src ) Return Bra("(BBULONG)"+t)
		Else If TFloat64Type( dst )
			If TFloat64Type( src) Return t
			If TLongType( src ) Return Bra("(BBFLOAT64)"+t)
			If TULongType( src ) Return Bra("(BBFLOAT64)"+t)
			If TSizeTType( src ) Return Bra("(BBFLOAT64)"+t)
		Else If TInt128Type( dst )
			If TInt128Type( src) Return t
			If TFloat128Type( src ) Return Bra("(BBINT128)"+t)
			If TDouble128Type( src ) Return Bra("(BBINT128)"+t)
		Else If TFloat128Type( dst )
			If TFloat128Type( src) Return t
			If TInt128Type( src ) Return Bra("(BBFLOAT128)"+t)
			If TDouble128Type( src ) Return Bra("(BBFLOAT128)"+t)
		Else If TDouble128Type( dst )
			If TDouble128Type( src) Return t
			If TInt128Type( src ) Return Bra("(BBDOUBLE128)"+t)
			If TFloat128Type( src ) Return Bra("(BBDOUBLE128)"+t)
		 Else If TWParamType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src) Return Bra("(WPARAM)"+t)
			If TShortType( src) Return Bra("(WPARAM)"+t)
			If TIntType( src) Return Bra("(WPARAM)"+t)
			If TUIntType( src) Return Bra("(WPARAM)"+t)
			If TLongType( src) Return Bra("(WPARAM)"+t)
			If TULongType( src) Return Bra("(WPARAM)"+t)
			If TSizeTType( src ) Return Bra("(WPARAM)"+t)
			If TWParamType( src ) Return t
			If TLParamType( src ) Return Bra("(WPARAM)"+t)
			If TFloatType( src ) Return Bra("(WPARAM)"+t)
			If TDoubleType( src ) Return Bra("(WPARAM)"+t)
			If TStringType( src ) Return "bbStringToWParam" + Bra(t)
			If IsPointerType(src,0,TType.T_POINTER) Return Bra("(WPARAM)"+t)
		 Else If TLParamType( dst )
			If TBoolType( src ) Return Bra( t )
			If TByteType( src) Return Bra("(LPARAM)"+t)
			If TShortType( src) Return Bra("(LPARAM)"+t)
			If TIntType( src) Return Bra("(LPARAM)"+t)
			If TUIntType( src) Return Bra("(LPARAM)"+t)
			If TLongType( src) Return Bra("(LPARAM)"+t)
			If TULongType( src) Return Bra("(LPARAM)"+t)
			If TSizeTType( src ) Return Bra("(LPARAM)"+t)
			If TWParamType( src ) Return Bra("(LPARAM)"+t)
			If TLParamType( src ) Return t
			If TFloatType( src ) Return Bra("(LPARAM)"+t)
			If TDoubleType( src ) Return Bra("(LPARAM)"+t)
			If TStringType( src ) Return "bbStringToLParam" + Bra(t)
			If IsPointerType(src,0,TType.T_POINTER) Return Bra("(LPARAM)"+t)

		Else If TArrayType( dst )
			If TArrayType( src ) Then
				If TObjectType( TArrayType( dst ).elemType ) And TObjectType( TArrayType( dst ).elemType ).classDecl.ident = "Object" Then
					' if we are casting to Object[], don't actually cast.
					Return Bra(t)
				Else
					Return "bbArrayCastFromObject" + Bra(t + "," + TransArrayType(TArrayType( dst ).elemType))
				End If
			End If
			
			If TObjectType( src) And (TObjectType( src ).classDecl.ident = "___Array" Or TObjectType( src ).classDecl.ident = "Object") Then
				Return "bbArrayCastFromObject" + Bra(t + "," + TransArrayType(TArrayType( dst ).elemType))
			End If
		Else If TObjectType( dst )
			'If TArrayType( src ) Return Bra("(BBOBJECT)"+t)
			'If TStringType( src ) Return Bra("(BBOBJECT)"+t)
			'If TObjectType( src ) Return t
			If Not TObjectType( dst ).classDecl.IsExtern() Then
				If TNullType( src ) Return "&bbNullObject"
				If TObjectType(dst).classDecl.IsInterface() Then
					Return Bra(Bra(TransObject(TObjectType(dst).classDecl)) + "bbInterfaceDowncast" + Bra(t + ",&" + TObjectType(dst).classDecl.munged + "_ifc"))
				Else
					' no need to downcast to BBObject, as all objects extend it...
					If TObjectType( dst ).classDecl.ident = "Object" Then
						Return t
					Else
						Return Bra(Bra(TransObject(TObjectType(dst).classDecl)) + "bbObjectDowncast" + Bra(t + ",&" + TObjectType(dst).classDecl.munged))
					End If
				End If
			Else
				If TObjectType( dst ).classDecl.IsInterface() Then
					Return t
				Else
					Return "" ' TODO??
				End If
			End If
		End If

		Return TransPtrCast( dst,src,t,"dynamic" )

		Err "C++ translator can't convert "+src.ToString()+" to "+dst.ToString()
	End Method

	Method TransUnaryExpr$( expr:TUnaryExpr )
		Local pri:Int=ExprPri( expr )
		Local t_expr$

		If TVarExpr(expr.expr) Then
			If TObjectType(TVarExpr(expr.expr).exprType) Then
				t_expr = Bra( expr.expr.Trans() + "!= &bbNullObject")
			Else If TStringType(TVarExpr(expr.expr).exprType)  Then
				t_expr = Bra( expr.expr.Trans() + "!= &bbEmptyString")
			Else
				t_expr = TransSubExpr( expr.expr,pri )
			End If
		Else
			t_expr = TransSubExpr( expr.expr,pri )
		End If

'		TransSubExpr( expr.expr,pri )
		Return TransUnaryOp( expr.op )+t_expr
	End Method

	Method TransBinaryExpr$( expr:TBinaryExpr )
		Local pri:Int=ExprPri( expr )
		
		Local t_lhs$=TransSubExpr( expr.lhs,pri )
'		If TVarPtrType(expr.lhs.exprType) Then
'			t_lhs = "*" + t_lhs
'		End If

		Local t_rhs$=TransSubExpr( expr.rhs,pri-1 )
'		If TVarPtrType(expr.rhs.exprType) Then
'			t_rhs = "*" + t_rhs
'		End If

		If expr.op = "+" Then
			If TStringType(expr.exprType) Then
				Return "bbStringConcat(" + t_lhs + "," + t_rhs + ")"
			Else If TArrayType(expr.exprType) Then
				Return "bbArrayConcat(" + TransArrayType(TArrayType(expr.lhs.exprType).elemType) + "," + t_lhs + "," + t_rhs + ")"
			End If
		End If
		
		If expr.op = "^" Then
			Return "pow" + Bra(t_lhs + ", " + t_rhs)
		End If
		
		If expr.op = "mod" Or expr.op = "%" Then
			If TDecimalType(expr.lhs.exprType) Or TDecimalType(expr.rhs.exprType) Then
				Return "fmod" + Bra(t_lhs + ", " + t_rhs)
			End If
		End If
		
		If (expr.op = "shr" Or expr.op = "&" Or expr.op = "|") And TIntType(expr.exprType) Then
			t_lhs = "(unsigned int)(" + t_lhs + ")"
		End If

		If TBinaryCompareExpr(expr) Then
			If TStringType(TBinaryCompareExpr(expr).ty) Then
				If t_lhs="&bbNullObject" Then
					err "NULL"
					t_lhs = "&bbEmptyString"
				End If
				If t_rhs="&bbNullObject" Then
					err "NULL"
					t_rhs = "&bbEmptyString"
				End If
				If t_lhs <> "&bbEmptyString" And t_rhs <> "&bbEmptyString" Then
					Return "bbStringCompare" + Bra(t_lhs + ", " + t_rhs) + TransBinaryOp(expr.op, "") + "0"
				End If
			End If
			If IsPointerType(TBinaryCompareExpr(expr).ty, 0, TType.T_POINTER) Then
				If t_lhs="&bbNullObject" Then
					t_lhs = "0"
				End If
				If t_rhs="&bbNullObject" Then
					t_rhs = "0"
				End If
			End If
			If TArrayType(TBinaryCompareExpr(expr).ty) Then
				If t_lhs="&bbNullObject" Then
					err "NULL"
					t_lhs = "&bbEmptyArray"
				End If
				If t_rhs="&bbNullObject" Then
					err "NULL"
					t_rhs = "&bbEmptyArray"
				End If
			End If
		End If

		Return bra(t_lhs+TransBinaryOp( expr.op,t_rhs )+t_rhs)
	End Method

	Method TransIndexExpr$( expr:TIndexExpr )

		Local t_expr$=TransSubExpr( expr.expr )

		Local t_index$
		If expr.index.length = 1 Then
			If TArraySizeExpr(expr.index[0]) Then
				Local sizes:TArraySizeExpr = TArraySizeExpr(expr.index[0])
				sizes.Trans()
				Local v:String = sizes.val.munged
				Local i:Int = 0
				For i = 0 Until sizes.index.length - 1
					If i Then
						t_index :+ " + "
					End If
					t_index :+ "(*(" + v
					If i Then
						t_index :+ "+" + i
					End If
					t_index :+ ")) * " + sizes.index[i].Trans()
				Next
				t_index :+ " + " + sizes.index[i].Trans()
				' (*(v+0)) * var1 + (*(v+1)) * var2 + var3
'DebugStop
			Else
				t_index=expr.index[0].Trans()
			End If
		End If

		If TStringType( expr.expr.exprType ) Then
			Return Bra(t_expr) + "->buf[" + t_index + "]"
			'Return "(BBINT)"+t_expr+"["+t_index+"]"
		End If

		If TArrayType( expr.expr.exprType ) Then
			If TFunctionPtrType(TArrayType( expr.expr.exprType ).elemType) Then
				If opt_debug Then
					Return Bra(Bra(TransType(TArrayType( expr.expr.exprType).elemType, "*")) + Bra("BBARRAYDATAINDEX(" + Bra(t_expr) + "," + Bra(t_expr) + "->dims," + t_index + ")")) + "[" + t_index + "]"
				Else
					Return Bra(Bra(TransType(TArrayType( expr.expr.exprType).elemType, "*")) + Bra("BBARRAYDATA(" + Bra(t_expr) + "," + Bra(t_expr) + "->dims)")) + "[" + t_index + "]"
				End If
			Else
				If opt_debug Then
					Return Bra("(" + TransType(expr.exprType, "") + "*)BBARRAYDATAINDEX(" + Bra(t_expr) + "," + Bra(t_expr) + "->dims," + t_index + ")") + "[" + t_index + "]"
				Else
					Return Bra("(" + TransType(expr.exprType, "") + "*)BBARRAYDATA(" + Bra(t_expr) + "," + Bra(t_expr) + "->dims)") + "[" + t_index + "]"
				End If
			End If
		End If

		'Local swiz$
		'If TObjectType( expr.exprType )And expr.exprType.GetClass().IsInterface() swiz=".p"

		'If ENV_CONFIG="debug" Return t_expr+".At("+t_index+")"+swiz

		Return t_expr+"["+t_index+"]"
	End Method

	Method TransSliceExpr$( expr:TSliceExpr )
'DebugStop
		Local t_expr:String=TransSubExpr( expr.expr )
		Local t_args$
		If expr.from Then
			t_args=expr.from.Trans()
		Else
			t_args = "0"
		End If
		If expr.term Then
			t_args:+","+expr.term.Trans()
		Else
			If TArrayType(expr.exprType) Then
				t_args :+ "," + Bra(t_expr) + "->scales[0]"
			'Else If TStringVarPtrType(expr.exprType) Then
			'	t_args :+ ",(*" + t_expr + ")->length"
			Else
				t_args :+ "," + Bra(t_expr) + "->length"
			End If
		End If

		If TArrayType(expr.exprType) Then
			Return "bbArraySlice" + Bra(TransArrayType(TArrayType(expr.exprType).elemType) + "," + t_expr + "," + t_args)
		'Else If TStringVarPtrType(expr.exprType) Then
		'	Return "bbStringSlice" + Bra("*" + t_expr + "," + t_args)
		Else
			Return "bbStringSlice" + Bra(t_expr + "," + t_args)
		End If
		'Return t_expr+".Slice("+t_args+")"
	End Method

	Method TransArrayExpr$( expr:TArrayExpr )
		Local elemType:TType=TArrayType( expr.exprType ).elemType

		Local tmpData:TLocalDecl =New TLocalDecl.Create( "",TType.voidType,Null )
		MungDecl tmpData

		Local tmpArray:TLocalDecl =New TLocalDecl.Create( "",TType.voidType,Null )
		MungDecl tmpArray

		Local t$
		Local count:Int
		For Local elem:TExpr=EachIn expr.exprs
			If t t:+","
			t:+elem.Trans()
			count :+ 1
		Next

		Local tt$
'		If Not _env tt="static "

		If Not TFunctionPtrType(elemType) Then
			tt :+ TransType( elemType, tmpData.munged ) + " "+tmpData.munged + "[]"
		Else
			tt :+ TransType( elemType, tmpData.munged + "[]" ) 
		End If
		Emit tt+"={"+t+"};"
		Emit "BBARRAY " + tmpArray.munged + " = bbArrayFromData" + Bra(TransArrayType(elemType) + "," + count + "," + tmpData.munged ) + ";"

		Return tmpArray.munged
		'Return "bbArrayFromData" + Bra(TransArrayType(elemType) + "," + count + "," + tmp.munged )
		'Return "Array<"+TransRefType( elemType, "MM" )+" >("+tmp.munged+","+expr.exprs.Length+")"
	End Method

	Method TransArraySizeExpr$ ( expr:TArraySizeExpr )
		' scales[0] is the total size of the array
		' we start from [1] because it is the size of the next full dimension.
		' in the case of a 2-dimensional array, [1] represents the length of a row.
		Return Bra("(BBARRAY)" + expr.expr.Trans()) + "->scales + 1"
	End Method

	Method TransIntrinsicExpr$( decl:TDecl,expr:TExpr,args:TExpr[] )
		Local texpr$,arg0$,arg1$,arg2$

		If expr texpr=TransSubExpr( expr )

		If args.Length>0 And args[0] arg0=args[0].Trans()
		If args.Length>1 And args[1] arg1=args[1].Trans()
		If args.Length>2 And args[2] arg2=args[2].Trans()

		Local id$=decl.munged[1..]
		Local id2$=id[..1].ToUpper()+id[1..]

		Select id
		'
		'global functions
		Case "print" Return "Print"+Bra( arg0 )
		Case "error" Return "Error"+Bra( arg0 )
		'
		'string/array methods
		Case "length" Return texpr+".Length()"
		Case "resize" Return texpr+".Resize"+Bra( arg0 )

		'string methods
		Case "compare" Return texpr+".Compare"+Bra( arg0 )
		Case "find" Return texpr+".Find"+Bra( arg0+","+arg1 )
		Case "findlast" Return texpr+".FindLast"+Bra( arg0 )
		Case "findlast2" Return texpr+".FindLast"+Bra( arg0+","+arg1 )
		Case "trim" Return texpr+".Trim()"
		Case "join" Return texpr+".Join"+Bra( arg0 )
		Case "split" Return texpr+".Split"+Bra( arg0 )
		Case "replace" Return texpr+".Replace"+Bra( arg0+","+arg1 )
		Case "tolower" Return texpr+".ToLower()"
		Case "toupper" Return texpr+".ToUpper()"
		Case "contains" Return texpr+".Contains"+Bra( arg0 )
		Case "startswith" Return texpr+".StartsWith"+Bra( arg0 )
		Case "endswith" Return texpr+".EndsWith"+Bra( arg0 )

		'string functions
		Case "fromchar" Return "String"+Bra( "(Char)"+Bra(arg0)+",1" )

		'math methods
		Case "sin","cos","tan" Return "(float)"+id+Bra( Bra(arg0)+"*D2R" )
		Case "asin","acos","atan" Return "(float)"+Bra( id+Bra(arg0)+"*R2D" )
		Case "atan2" Return "(float)"+Bra( id+Bra(arg0+","+arg1)+"*R2D" )
		Case "sqrt","floor","ceil","log" Return "(float)"+id+Bra( arg0 )
		Case "pow" Return "(float)"+id+Bra( arg0+","+arg1 )
		'
		End Select
		InternalErr
	End Method

	'***** Statements *****

	Method TransTryStmt$( stmt:TTryStmt )
		Emit "do {"
		
		EmitLocalDeclarations(stmt.block)
		
		Emit "jmp_buf * buf = bbExEnter();"
		Emit "switch(setjmp(*buf)) {"
		Emit "case 0: {"
		If opt_debug Then
			Emit "bbOnDebugPushExState();"
		End If
		PushLoopTryStack(stmt)
		tryStack.Push(stmt.block)
		EmitBlock( stmt.block )
		tryStack.Pop()
		PopLoopTryStack
		Emit "bbExLeave();"
		If opt_debug Then
			Emit "bbOnDebugPopExState();"
		End If
		Emit "}"
		Emit "break;"
		Emit "case 1:"
		Emit "{"

		If opt_debug Then
			Emit "bbOnDebugPopExState();"
		End If

		Emit "BBOBJECT ex = bbExObject();"
		Local s:String = ""
		For Local c:TCatchStmt=EachIn stmt.catches
			MungDecl c.init
			If TStringType(c.init.ty) Then
				Emit s + "if (bbObjectDowncast(ex,&bbStringClass) != &bbEmptyString) {"
				Emit TransType( c.init.ty, c.init.munged )+" "+ c.init.munged + "=(BBSTRING)ex;" 
			Else If TArrayType(c.init.ty) Then
				Emit s + "if (bbObjectDowncast(ex,&bbArrayClass) != &bbEmptyArray) {"
				Emit TransType( c.init.ty, c.init.munged )+" "+ c.init.munged + "=(BBARRAY)ex;" 
			Else If TObjectType(c.init.ty) Then
				Emit s + "if (bbObjectDowncast(ex,&"+TObjectType(c.init.ty).classDecl.munged+") != &bbNullObject) {"
				Emit TransType( c.init.ty, c.init.munged )+" "+ c.init.munged + "=" + Bra(TransType( c.init.ty, c.init.munged )) + "ex;" 
			Else
				Err "Not an object"
			End If
			
			EmitLocalDeclarations(c.block, c.init)
			
			EmitBlock( c.block )
			s = "} else "
		Next
		If s Then
			Emit s + " {"
			' unhandled exception
			Emit "bbExThrow(ex);"
			Emit "}"
		Else
			' unhandled exception
			Emit "bbExThrow(ex);"
		End If

		Emit "}"
		Emit "break;"
		Emit "}"
		Emit "} while(0);"
	End Method
	
	Method EmitTryStack()
		For Local i:Int = 0 Until tryStack.Length()
			Emit "bbExLeave();"
			If opt_debug Then
				Emit "bbOnDebugPopExState();"
			End If
		Next
	End Method

	Method EmitLocalScopeStack()
		For Local i:Int = 0 Until localScope.Length()
			Emit "// TODO"
		Next
	End Method

	Method EmitDebugEnterScope(block:TBlockDecl)
		Local count:Int
		For Local decl:TDecl = EachIn block.Decls()
			If TLocalDecl(decl) Then
				count :+ 1
			End If
			If TConstDecl(decl) Then
				count :+ 1
			End If
			If TGlobalDecl(decl) Then
				count :+ 1
			End If
		Next
		
		' a method also includes "Self" reference back to parent Type
		If TFuncDecl(block) And TFuncDecl(block).IsMethod() Then
			count :+ 1
		End If
		
		If _app.mainFunc = block Then
			For Local decl:TDecl = EachIn _app.mainModule.Decls()
				If TConstDecl(decl) Then
					count :+ 1
				End If
				If TGlobalDecl(decl) Then
					count :+ 1
				End If
			Next
		End If
		
		If Not count Then
			Emit "struct BBDebugScope __scope = {"
		Else
			Emit "struct BBDebugScope_" + count + " __scope = {"
			_app.scopeDefs.Insert(String(count), "")
		End If

		If TFuncDecl(block) Then
			Emit "BBDEBUGSCOPE_FUNCTION,"
			If _app.mainFunc = block Then
				' use the filename as the base function name
				Emit Enquote(StripExt(StripDir(_app.mainModule.filepath))) + ","
			Else
				Emit Enquote(TFuncDecl(block).ident) + ","
			End If
		Else
			Emit "BBDEBUGSCOPE_LOCALBLOCK,"
			Emit "0,"
		End If
			
			Emit "{"
			
			If TFuncDecl(block) And TFuncDecl(block).IsMethod() Then
				Emit "{"
				Emit "BBDEBUGDECL_LOCAL,"
				Emit "~qSelf~q,"
				Emit Enquote(TransDebugScopeType(TClassDecl(block.scope).objectType)) + ","
				Emit ".var_address=&o"
				Emit "},"
			End If
			
			' block consts and globals
			' consts
			For Local cdecl:TConstDecl = EachIn block.Decls()
				EmitConstDebugScope(cdecl)
			Next
			' globals
			For Local gdecl:TGlobalDecl = EachIn block.Decls()
				EmitGlobalDebugScope(gdecl)
			Next
			
			' iterate through decls and add as appropriate
			For Local decl:TDecl = EachIn block.Decls()
				Local ldecl:TLocalDecl = TLocalDecl(decl)
				If ldecl Then
					Emit "{"
					If ldecl.ty._flags & TType.T_VAR Then
						Emit "BBDEBUGDECL_VARPARAM,"
					Else
						Emit "BBDEBUGDECL_LOCAL,"
					End If
					Emit Enquote(ldecl.ident) + ","
					Emit Enquote(TransDebugScopeType(ldecl.ty)) + ","
					Emit ".var_address=&" + ldecl.munged
					Emit "},"
					
					Continue
				End If
			Next

			' add module consts and globals
			If _app.mainFunc = block Then
				' consts
				For Local cdecl:TConstDecl = EachIn _app.mainModule.Decls()
					EmitConstDebugScope(cdecl)
				Next
				' globals
				For Local gdecl:TGlobalDecl = EachIn _app.mainModule.Decls()
					EmitGlobalDebugScope(gdecl)
				Next
			End If
			
			Emit "BBDEBUGDECL_END "
			Emit "}"
			
			
		Emit "};"
		
		Emit "bbOnDebugEnterScope(&__scope);"
	End Method
	
	Method TransDebugNullObjectError:String(variable:String, cdecl:TClassDecl)
		If cdecl.IsStruct() Or cdecl.ident = "String" Or cdecl.ident = "___Array" Then
			'Return cdecl.munged + "NullObjectTest(" + variable + ")"
			Return variable
		Else
			Return Bra(Bra(TransObject(cdecl)) + "bbNullObjectTest(" + variable + ")")
		End If
	End Method
	
	Method TransAssignStmt$( stmt:TAssignStmt )
		If Not stmt.rhs Return stmt.lhs.Trans()

		Local rhs$=stmt.rhs.Trans()
		Local lhs$=stmt.lhs.TransVar()

		Local s:String

		If IsPointerType(stmt.lhs.exprType, TType.T_BYTE) And rhs = "&bbNullObject" Then
			rhs = "0"
		End If

		If stmt.op = ":%" Then
			If TDecimalType(stmt.lhs.exprType) Or TDecimalType(stmt.rhs.exprType) Then
				Return lhs + "=fmod" + Bra(lhs + "," + rhs)
			End If
		End If
		
		If TStringType(stmt.lhs.exprType) 'Or TStringVarPtrType(stmt.lhs.exprType) Then
'			s:+ "{"
'			s:+ "BBSTRING tmp=" + lhs + ";~n"

			If stmt.op = ":+" Then
				s :+ lhs+"=bbStringConcat("+lhs+","+rhs+")"
			Else If rhs = "&bbNullObject" Then
				s :+ lhs+TransAssignOp( stmt.op )+"&bbEmptyString"
			Else
				s :+ lhs+TransAssignOp( stmt.op )+rhs
			End If

'			s :+ ";~nBBRETAIN(" + lhs +")~n"
'			s :+ "BBRELEASE(tmp)~n"

'			s:+ "}"
		Else If TVarPtrType(stmt.lhs.exprType) Then

			If TCastExpr(stmt.rhs) And IsNumericType(TCastExpr(stmt.rhs).expr.exprType) Then
				rhs = TCastExpr(stmt.rhs).expr.Trans()
			End If

			s :+ lhs+TransAssignOp( stmt.op )+rhs
		Else If TArrayType(stmt.lhs.exprType) Then
			If stmt.op = ":+" Then
				s :+ lhs+"=bbArrayConcat("+ TransArrayType(TArrayType(stmt.lhs.exprType).elemType) + "," + lhs+","+rhs+")"
			Else If rhs = "&bbNullObject" Then
				s :+ lhs+TransAssignOp( stmt.op )+"&bbEmptyArray"
			Else
				s :+ lhs+TransAssignOp( stmt.op )+rhs
			End If
		Else If (TFunctionPtrType(stmt.lhs.exprType) <> Null Or IsPointerType(stmt.lhs.exprType, TType.T_BYTE)) And TInvokeExpr(stmt.rhs) And Not TInvokeExpr(stmt.rhs).invokedWithBraces Then
			rhs = TInvokeExpr(stmt.rhs).decl.munged
			s :+ lhs+TransAssignOp( stmt.op )+rhs
		Else
			s :+ lhs+TransAssignOp( stmt.op )+rhs
		End If

		If DEBUG Then
			DebugObject(stmt.lhs.exprType, lhs, Null, True)
		End If

		Return s
	End Method

	Method TransThrowStmt:String( stmt:TThrowStmt )
		Local s:String = "bbExThrow("

		s:+ stmt.expr.Trans()

		s :+ ")"
		Return s
	End Method

	Method TransAssertStmt$( stmt:TAssertStmt )
		If opt_debug Then
			Emit "if (!" + Bra(stmt.expr.Trans()) + ") {"
			Emit "brl_blitz_RuntimeError(" + stmt.elseExpr.Trans() + ");"
			Emit "}"
		End If
	End Method

	Method TransEndStmt$( stmt:TEndStmt )
		Emit "bbEnd();"
	End Method

	Method TransReleaseStmt$( stmt:TReleaseStmt )
		Emit "bbHandleRelease" + Bra(stmt.expr.Trans()) + ";"
	End Method

	Method TransRestoreDataStmt$( stmt:TRestoreDataStmt )
		Emit "_defDataOffset = &_defData[" + TDataLabelExpr(stmt.expr).dataDef.label.index + "];"
	End Method

	Method TransReadDataStmt$( stmt:TReadDataStmt )
		For Local expr:TExpr = EachIn stmt.args
			' buffer overflow test
			If opt_debug Then
				Emit "if (_defDataOffset - _defData >= " + TDefDataDecl.count + ") brl_blitz_OutOfDataError();"
			End If
			Emit expr.Trans() + " = " + TransDefDataConversion(expr.exprType) + Bra("_defDataOffset++") + ";"
		Next
	End Method

	Method TransNativeStmt$( stmt:TNativeStmt)
		Emit stmt.raw
	End Method

	Method TransFullName:String(decl:TDecl)
		Local s:String
		
		If decl.scope Then
			s:+ TransFullName(decl.scope)
		End If
		
		If s Then
			s :+ " : "
		End If
		
		If TModuleDecl(decl) Then
			s:+ decl.ModuleScope().munged
		Else
			s :+ decl.ident
		End If
		
		If TFuncDecl(decl) Then
			s:+ "()"
		End If
		
		Return s
	End Method
	
	Method ClassHasObjectField:Int(classDecl:TClassDecl)
	
		If classDecl.superClass Then
			If ClassHasObjectField(classDecl.superClass) Then
				Return True
			End If
		End If

		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			If Not decl.IsSemanted() Then
				decl.Semant()
			End If
			If TStringType(decl.ty) Or TArrayType(decl.ty) Or (TObjectType(decl.ty) And Not TObjectType(decl.ty).classDecl.IsStruct()) Then
				Return True
			End If
		Next
		
		Return False
	End Method


	'***** Declarations *****
Rem
	Method EmitFuncProto( decl:TFuncDecl )
		PushMungScope

		decl.Semant

		MungDecl decl

		'Find decl we override
		Local odecl:TFuncDecl=decl
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		Local args$
		For Local arg:TArgDecl=EachIn odecl.argDecls
			If args args:+","
			args:+TransType( arg.ty )
		Next

		Local t$=TransType( odecl.retType )+" "+decl.munged+Bra( args )
		If decl.IsAbstract() t:+"=0"

		Local q$
		If decl.IsExtern() q:+"extern "
		If decl.IsMethod() q:+"virtual "
		If decl.IsStatic() And decl.ClassScope() q:+"static "

		Emit q+t+";"

		PopMungScope
	End Method
End Rem
	Method EmitBBClassFuncProto( decl:TFuncDecl)
		'PushMungScope
		BeginLocalScope
'DebugStop
'		decl.Semant

'		MungDecl decl

		'Find decl we override
		Local odecl:TFuncDecl=decl
		'If odecl.overrides And Not odecl.returnTypeSubclassed Then Return
'DebugLog decl.ident
'		While odecl.overrides
'			odecl=odecl.overrides
'		Wend

		Local id$=decl.munged
		Local pre:String

		If decl.IsMethod() Then
			id :+ "_m"
			pre = "m_"
		Else
			id :+ "_f"
			pre = "f_"
		End If

		Local bk:String = ";"
		'Local pre:String = "typedef "
		'If odecl.IsExtern() Then
		'	pre = "extern "
		'End If
'DebugLog "id = " + id
		Emit id + " " + pre + FuncDeclMangleIdent(odecl) + ";"

'		If Not proto Or (proto And Not odecl.IsExtern()) Then
Rem
			If Not TFunctionPtrType(odecl.retType) Then
				If Not odecl.castTo Then
					Emit pre + TransType( odecl.retType, "" )+" "+ Bra("*" + id)+Bra( args ) + bk
				Else
					If Not odecl.noCastGen Then
						Emit pre + odecl.castTo +" "+Bra("*" + id)+Bra( args ) + bk
					End If
				End If
			Else
				If Not odecl.castTo Then
					Emit pre + TransType( odecl.retType, id )+" "+Bra( args ) + bk
				Else
					If Not odecl.noCastGen Then
						Emit pre + odecl.castTo +" "+Bra( args ) + bk
					End If
				End If
			End If

			For Local t$=EachIn argCasts
				Emit t
			Next
'		End If
End Rem
		'PopMungScope
		EndLocalScope
	End Method
	
	Method FuncDeclMangleIdent:String(fdecl:TFuncDecl)

		If (Not fdecl.ClassScope()) Or (equalsBuiltInFunc(fdecl.classScope(), fdecl)) Then
			Return fdecl.ident
		End If	
	
		If Not fdecl.mangled Then
			Local id:String = fdecl.ident

			If fdecl.attrs & FUNC_OPERATOR Then
				id = MungSymbol(id)
			End If

			fdecl.mangled = id + MangleMethod(fdecl)
		End If

		Return fdecl.mangled		
'		If fdecl.olIndex Then
'			Return fdecl.ident + fdecl.olIndex
'		Else
'			Return fdecl.ident
'		End If
	End Method

	Method EmitClassFuncProto( decl:TFuncDecl, isStruct:Int = False)
		'PushMungScope
		BeginLocalScope

		decl.Semant

		MungDecl decl

		'Find decl we override
		Local odecl:TFuncDecl=decl
'		If odecl.overrides Then Return
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		'Generate 'args' string and arg casts
		Local args$

		' pass object for method
		If decl.IsMethod() Then
			args :+ TransObject(decl.scope, True)
		End If

		Local argCasts:TStack =New TStack
		For Local i:Int=0 Until decl.argDecls.Length
			Local arg:TArgDecl=decl.argDecls[i]
			Local oarg:TArgDecl=odecl.argDecls[i]
			MungDecl arg
			If args args:+","
			If Not TFunctionPtrType(oarg.ty) Then
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo + " " + arg.munged
				End If
			Else
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo
				End If
			End If
			If arg.ty.EqualsType( oarg.ty ) Continue
			Local t$=arg.munged
			arg.munged=""
			MungDecl arg
			argCasts.Push TransType( arg.ty, arg.munged )+" "+arg.munged+"=static_cast<"+TransType(arg.ty, "")+" >"+Bra(t)+";"
		Next

		Local id$=decl.munged

		Local bk:String = ";"
		Local pre:String = "typedef "
		Local api:String
		If decl.IsMethod() Then
			id :+ "_m"
		Else
			id :+ "_f"
		End If
		
		If decl.attrs & DECL_API_WIN32 Then
			api = " __stdcall "
		End If

		'If odecl.IsExtern() Then
		'	pre = "extern "
		'End If

'		If Not proto Or (proto And Not odecl.IsExtern()) Then
			If Not TFunctionPtrType(decl.retType) Then
				If Not odecl.castTo Then
					If Not isStruct Then
						If Not decl.overrides Or decl.returnTypeSubclassed Then
							Emit pre + TransType( decl.retType, "" )+" "+ Bra(api + "*" + id)+Bra( args ) + bk
						End If
					End If
					If decl.IsMethod() Then
						Emit TransType(decl.retType, "") + " _" + decl.munged +Bra( args ) + bk
					Else
						Emit TransType(decl.retType, "") + api + " " + decl.munged +Bra( args ) + bk
					End If
				Else
					If Not odecl.noCastGen Then
						If Not isStruct Then
							If Not decl.overrides Or decl.returnTypeSubclassed Then
								Emit pre + odecl.castTo +" "+Bra(api + "*" + id)+Bra( args ) + bk
							End If
						End If
						If decl.IsMethod() Then
							Emit odecl.castTo + " _" + decl.munged +Bra( args ) + bk
						Else
							Emit odecl.castTo + " " + decl.munged +Bra( args ) + bk
						End If
					End If
				End If
			Else
				If Not odecl.castTo Then
					If Not args Then
						' for function pointer return type, we need to generate () regardless of whether there are
						' args or not.
						args = " "
					End If
					' emit function ptr typedef
					Emit pre + TransType( decl.retType, id + "x") + bk
					' emit actual typedef (with return type of above typedef)
					Emit pre + TransType( decl.retType, id, args, True ) + bk
				Else
					If Not odecl.noCastGen Then
						Emit pre + odecl.castTo +" "+Bra( args ) + bk
					End If
				End If
			End If

			For Local t$=EachIn argCasts
				Emit t
			Next
'		End If

		'PopMungScope
		EndLocalScope
	End Method



	Method EmitFuncDecl( decl:TFuncDecl, proto:Int = False, classFunc:Int = False )
		'If Not proto And decl.IsAbstract() Return

		Local tmpDebug:Int = opt_debug
		If decl.isNoDebug() Then
			opt_debug = False
		End If

		'PushMungScope
		BeginLocalScope
'DebugStop
		decl.Semant

		MungDecl decl

		' emit nested functions
		If Not proto Then
			' emit nested protos
			For Local fdecl:TFuncDecl = EachIn decl._decls
				EmitFuncDecl(fdecl, True, classFunc)
			Next
			
			' emit nested bodies
			For Local fdecl:TFuncDecl = EachIn decl._decls
				EmitFuncDecl(fdecl, proto, classFunc)
			Next
		End If

		'Find decl we override
		Local odecl:TFuncDecl=decl
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		'Generate 'args' string and arg casts
		Local args$

		' pass object for method
		If decl.IsMethod() Then
			args :+ TransObject(decl.scope, True) + " o"
		End If

		Local argCasts:TStack =New TStack
		For Local i:Int=0 Until decl.argDecls.Length
			Local arg:TArgDecl=decl.argDecls[i]
			Local oarg:TArgDecl=odecl.argDecls[i]
			MungDecl arg, True
			If args args:+","
			If Not TFunctionPtrType(oarg.ty) Then
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )+" "+arg.munged
				Else
					args:+ oarg.castTo + " " + arg.munged
				End If
			Else
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo
				End If
			End If
			If arg.ty.EqualsType( oarg.ty ) Continue
			Local t$=arg.munged
			arg.munged=""
			MungDecl arg
			argCasts.Push TransType( arg.ty, arg.munged )+" "+arg.munged+"=static_cast<"+TransType(arg.ty, "")+" >"+Bra(t)+";"
		Next

		Local id$=decl.munged

		If classFunc Then
			If decl.IsMethod() Then
				id = "_" + id
			End If
		Else
			If Not odecl.IsExtern() Then
				id = id
			End If
		End If

		Local bk:String = "{"
		Local pre:String
		Local api:String
		If proto Then
			If odecl.IsExtern() Then
				pre = "extern "
				If TFunctionPtrType(decl.retType) Then
					pre = ""
				End If
			End If
			bk = ";"
		End If

		If decl.attrs & DECL_API_WIN32 Then
			api = " __stdcall "
		End If

'		If Not proto Or (proto And Not odecl.IsExtern()) Then
		If Not IsStandardFunc(decl.munged) Then
			If Not TFunctionPtrType(odecl.retType) Then
				If Not odecl.castTo Then
					Emit pre + TransType( decl.retType, "" )+ api + " "+id+Bra( args ) + bk
				Else
					If Not odecl.noCastGen Then
						Emit pre + odecl.castTo + api + " "+id+Bra( args ) + bk
					End If
				End If
			Else
				If Not odecl.castTo Then
					If Not args Then
						' for function pointer return type, we need to generate () regardless of whether there are
						' args or not.
						args = " "
					End If
					Emit pre + TransType( decl.retType, id, args )+ bk
				Else
					If Not odecl.noCastGen Then
						Emit pre + odecl.castTo +" "+Bra( args ) + bk
					End If
				End If
			End If

			For Local t$=EachIn argCasts
				Emit t
			Next
		End If

		If Not proto Then

			If PROFILER Then
				DebugPrint("", TransFullName(decl))
			End If
				
			If DEBUG Then
				For Local i:Int=0 Until decl.argDecls.Length
					Local arg:TArgDecl=decl.argDecls[i]
					DebugObject(arg.ty, arg.munged, id)
				Next
			End If

			If decl.IsAbstract() Then
				' TODO : remove following line when generation stablises.
				Emit "printf(~qAbstract method called : " + decl.ident + "\n~q);fflush(stdout);"
				Emit "brl_blitz_NullMethodError();"
			Else

				decl.Semant()
				
				If opt_debug And decl.IsMethod() Then
					Emit TransDebugNullObjectError("o", TClassDecl(decl.scope)) + ";"
				End If

				EmitLocalDeclarations(decl)

				EmitBlock decl

			End If
			Emit "}"
		End If

		' reset label ids
		contLabelId = 0
		exitLabelId = 0

		EndLocalScope
		'PopMungScope
		
		opt_debug = tmpDebug
		
	End Method
	
	Method EmitLocalDeclarations(decl:TScopeDecl, ignoreVar:TValDecl = Null)
		If opt_debug Then
			For Local ldecl:TLocalDecl = EachIn decl.Decls()
				If ldecl <> ignoreVar Then
					If Not TArgDecl(ldecl) And Not ldecl.generated Then
						MungDecl ldecl
						Local ty:TType = ldecl.ty

						Local t:String = TransLocalDeclNoInit(ldecl)
						
'						If TObjectType( ty ) And TObjectType( ty ).classDecl.IsStruct() Then
'							t :+ "={}"
'						End If
						
						Emit t + ";"
					End If
				End If
			Next
		End If
	End Method

	Method EmitClassFieldsProto(classDecl:TClassDecl)

		If classDecl.superClass Then
			EmitClassFieldsProto(classDecl.superClass)
		End If

		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			decl.Semant()

			If Not TFunctionPtrType(decl.ty) Then
				If classDecl.IsExtern() Then
					Emit TransType(decl.ty, "") + " " + decl.ident + ";"
				Else
					Emit TransType(decl.ty, classDecl.actual.munged) + " _" + classDecl.actual.munged.ToLower() + "_" + decl.IdentLower() + ";"
				End If
			Else
				If classDecl.IsExtern() Then
					Emit TransType(decl.ty, decl.ident) + ";"
				Else
					Emit TransType(decl.ty, "_" + classDecl.actual.munged.ToLower() + "_" + decl.IdentLower()) + ";"
				End If
			End If
		Next

	End Method

	Method EmitClassGlobalsProto(classDecl:TClassDecl)

		For Local decl:TGlobalDecl = EachIn classDecl.Decls()
			decl.Semant()

			If TFunctionPtrType(decl.ty) Then
					Emit TransRefType( decl.ty, decl.munged ) + ";"
			Else
				Emit "extern "+TransRefType( decl.ty, "" )+" "+ decl.munged+";"
			End If
		Next

	End Method

	Method BBClassClassFuncProtoBuildList( classDecl:TClassDecl, list:TList )

		'Local reserved:String = ",New,Delete,ToString,Compare,SendMessage,_reserved1_,_reserved2_,_reserved3_,".ToLower()

		If classDecl.superClass Then
			BBClassClassFuncProtoBuildList(classDecl.superClass, list)
		End If
		
		For Local idecl:TClassDecl = EachIn classDecl.implmentsAll
			BBClassClassFuncProtoBuildList(idecl, list)
		Next

		For Local decl:TDecl=EachIn classDecl.Decls()
			Local fdecl:TFuncDecl =TFuncDecl( decl )
			If fdecl
				If Not fdecl.IsSemanted()
					fdecl.Semant()
				End If

				If Not equalsBuiltInFunc(classDecl, fdecl) And Not equalsTorFunc(classDecl, fdecl) Then
				
					Local ignore:Int
					Local link:TLink=list._head._succ
					While link<>list._head
						Local ofdecl:TFuncDecl = TFuncDecl(link._value)
						If fdecl.ident = ofdecl.ident And fdecl.EqualsArgs(ofdecl) Then
							If fdecl.overrides Then
								If fdecl.returnTypeSubclassed Then
									link._value = fdecl
								End If
								ignore = True
								Exit
							End If
							
							If TFuncDecl(link._value).IsMethod() Then
								ignore = True
							End If
						EndIf
						link = link._succ
					Wend

					If Not ignore Then
						list.AddLast(fdecl)
					End If
				
					Continue
				End If
			EndIf
		Next

	End Method

	Method EmitBBClassClassFuncProto( classDecl:TClassDecl )

		Local list:TList = New TList
		
		BBClassClassFuncProtoBuildList(classDecl, list)

		For Local fdecl:TFuncDecl = EachIn list
			EmitBBClassFuncProto( fdecl )
		Next

	End Method

	Method EmitClassProto( classDecl:TClassDecl )

		Local classid$=classDecl.munged
		Local superid$
		If classDecl.superClass Then
			superid=classDecl.superClass.actual.munged
		End If

		'Emit "void _" + classid + "_New" + Bra(TransObject(classdecl) + " o") + ";"
		
		EmitClassDeclNewListProto(classDecl)
		
		If classHierarchyHasFunction(classDecl, "Delete") Then
			Emit "void _" + classid + "_Delete" + Bra(TransObject(classdecl) + " o") + ";"
		End If

		If classHasFunction(classDecl, "ToString") Then
			Emit "BBSTRING _" + classid + "_ToString" + Bra(TransObject(classdecl) + " o") + ";"
		End If

		If classHasFunction(classDecl, "Compare") Then
			Emit "BBINT _" + classid + "_Compare(" + TransObject(classdecl) + " o, BBOBJECT otherObject);"
		End If

		If classHasFunction(classDecl, "SendMessage") Then
			Emit "BBOBJECT _" + classid + "_SendMessage(" + TransObject(classdecl) + " o, BBOBJECT message, BBOBJECT source);"
		End If

		'Local reserved:String = ",New,Delete,ToString,Compare,SendMessage,_reserved1_,_reserved2_,_reserved3_,".ToLower()

		classDecl.SemantParts()

		'Local fdecls:TFuncDecl[] = classDecl.GetAllFuncDecls(Null, False)
		For Local decl:TDecl=EachIn classDecl.Decls()
		'For Local fdecl:TFuncDecl = EachIn fdecls

			Local fdecl:TFuncDecl =TFuncDecl( decl )
			If fdecl

				If Not equalsBuiltInFunc(classDecl, fdecl) And Not equalsTorFunc(classDecl, fdecl) Then
					EmitClassFuncProto( fdecl )
					Continue
				End If
			EndIf

			Local gdecl:TGlobalDecl =TGlobalDecl( decl )
			If gdecl
				MungDecl gdecl
			'	Emit "static "+TransRefType( gdecl.ty )+" "+gdecl.munged+";"
				Continue
			EndIf
		Next

		Emit ""

		' emit the class structure
		Emit "struct BBClass_" + classid + " {"
		If classDecl.superClass.ident = "Object" Then
			Emit "BBClass*  super;"
		Else
			Emit "struct BBClass_" + classDecl.superClass.munged + "*  super;"
		End If
		Emit "void      (*free)( BBObject *o );"
		Emit "BBDebugScope* debug_scope;"
		Emit "unsigned int instance_size;"
		Emit "void      (*ctor)( BBOBJECT o );"
		Emit "void      (*dtor)( BBOBJECT o );"
		Emit "BBSTRING  (*ToString)( BBOBJECT x );"
		Emit "int       (*Compare)( BBOBJECT x,BBOBJECT y );"
		Emit "BBOBJECT  (*SendMessage)( BBOBJECT o,BBOBJECT m,BBOBJECT s );"
		Emit "BBINTERFACETABLE itable;"
		Emit "void*     extra;"
		Emit "unsigned int obj_size;"

		EmitBBClassClassFuncProto(classDecl)

		Emit "};~n"

		If classDecl.IsInterface() Then
			Emit "struct " + classid + "_methods {"
			EmitBBClassClassFuncProto(classDecl)
			Emit "};~n"
		End If

		Emit "struct " + classid + "_obj {"
		Emit "struct BBClass_" + classid + "* clas;"

		BeginLocalScope
		EmitClassFieldsProto(classDecl)
		EndLocalScope

		Emit "};"

		Emit "extern struct BBClass_" + classid + " " + classid + ";"

		EmitClassGlobalsProto(classDecl);

		' fields
		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			MungDecl decl
		Next
		
	End Method


	Method EmitExternClassFuncProto( classDecl:TClassDecl )

		If classDecl.superClass Then
			EmitExternClassFuncProto(classDecl.superClass)
		End If

		For Local decl:TFuncDecl = EachIn classDecl.Decls()
			decl.Semant()

			' code is written as a method, but emitted as a function pointer
			' with self as the first parameter
			Local func:TFuncDecl = TFuncDecl(decl.Copy())
			Local argDecl:TArgDecl = New TArgDecl.Create("This", classDecl.objectType, Null)

			func.argDecls = [argDecl] + func.argDecls
			
			func.Semant()
			
			Local ty:TFunctionPtrType = New TFunctionPtrType
			ty.func = func
			
			Emit TransType(ty, decl.Ident) + ";"

		Next
	End Method

	Method EmitExternClassTypeFuncProto( classDecl:TClassDecl )

		Local doneCtorDtor:Int
		Local iDecl:TClassDecl

		For Local decl:TFuncDecl = EachIn classDecl.GetAllOriginalFuncDecls(Null, True)
			decl.Semant()
			
			' first interface preceeds ctor/dtor
			If Not doneCtorDtor
				If Not iDecl And TClassDecl(decl.scope).IsInterface() Then
					iDecl = TClassDecl(decl.scope)
				End If
				
				If iDecl
					If iDecl <> TClassDecl(decl.scope) Then
						' a different interface
						doneCtorDtor = True
						Emit "void(*_ctor)();"
						Emit "void(*_dtor)();"
					End If
				Else
					doneCtorDtor = True
					Emit "void(*_ctor)();"
					Emit "void(*_dtor)();"
				End If
				
			End If

			' code is written as a method, but emitted as a function pointer
			' with self as the first parameter
			Local func:TFuncDecl = TFuncDecl(decl.Copy())
			Local argDecl:TArgDecl = New TArgDecl.Create("This", classDecl.objectType, Null)

			func.argDecls = [argDecl] + func.argDecls
			
			func.Semant()
			
			Local ty:TFunctionPtrType = New TFunctionPtrType
			ty.func = func
			
			Emit TransType(ty, decl.Ident) + ";"

		Next
	End Method

	Method EmitExternClassProto( classDecl:TClassDecl )

		Emit "typedef struct " + classDecl.ident + " " + classDecl.ident + ";"
		
		' vtable
		Emit "struct " + classDecl.ident  + "Vtbl {"
		
		' methods
		If classDecl.IsInterface() Then
			EmitExternClassFuncProto(classDecl)
		Else
			EmitExternClassTypeFuncProto(classDecl)
		End If

		Emit "};"
		
		Emit "struct " + classDecl.ident + " {"
		Emit "struct " + classDecl.ident + "Vtbl* vtbl;"
		Emit "};"

	End Method

	Field emittedStructs:TList = New TList

	Method EmitStructClassProto( classDecl:TClassDecl )
	
		If emittedStructs.Contains(classDecl) Return
		
		emittedStructs.AddLast(classDecl)
		
		' emit any dependent structs first
		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			decl.Semant()
			
			If TObjectType(decl.ty) And TObjectType(decl.ty).classDecl.IsStruct() Then
				If Not emittedStructs.Contains(TObjectType(decl.ty).classDecl) Then
					EmitStructClassProto(TObjectType(decl.ty).classDecl)
				End If
			End If
		Next

		If classDecl.IsExtern()
			Emit "struct " + classDecl.ident + " {"
		Else
			EmitClassDeclNewListProto( classDecl )


			For Local fdecl:TFuncDecl=EachIn classDecl.Decls()
	
				If fdecl.IdentLower() <> "new" Then
					EmitClassFuncProto( fdecl, True )
				End If

			Next
		
			Emit "struct " + classDecl.munged + " {"
		End If

		BeginLocalScope
		EmitClassFieldsProto(classDecl)
		EndLocalScope

		Emit "};"

	End Method

	Method classHasFunction:Int(classDecl:TClassDecl, func:String)
		Local f:String = func.ToLower()
		For Local decl:TFuncDecl = EachIn classDecl.Decls()
			If Not decl.IsSemanted() Then
				decl.Semant
			End If
			If decl.IdentLower() = f And equalsBuiltInFunc(classDecl.superClass, decl) Then
				Return True
			End If
		Next
		Return False
	End Method

	Method classHierarchyHasFunction:Int(classDecl:TClassDecl, func:String)
		If classHasFunction(classDecl, func) Return True
		If classDecl.superClass And classDecl.superClass.munged <> "bbObjectClass" Then
			Return classHierarchyHasFunction(classDecl.superClass, func)
		End If
		Return False
	End Method

	Method classidForFunction:String(classDecl:TClassDecl, func:String)
		If classHasFunction(classDecl, func) Return classDecl.munged
		If classDecl.superClass And classDecl.superClass.munged <> "bbObjectClass" Then
			Return classidForFunction(classDecl.superClass, func)
		End If
		Return Null
	End Method

	Method EmitMark( id$,ty:TType,queue:Int )

		If TObjectType( ty )

			If id.EndsWith( ".p" )
				If ty.GetClass().IsInterface() id=id[..-2] Else InternalErr
			Else
				If ty.GetClass().IsInterface() InternalErr
			EndIf

			If queue
				Emit "gc_mark_q("+id+");"
			Else
				Emit "gc_mark("+id+");"
			EndIf
		Else If TArrayType( ty )
			Emit "gc_mark("+id+");"
			Return
		EndIf
	End Method
	
	Method EmitClassConstsDebugScope(classDecl:TClassDecl)
	
		For Local decl:TConstDecl = EachIn classDecl.Decls()
			EmitConstDebugScope(decl)
		Next

	End Method

	Method EmitConstDebugScope(decl:TConstDecl)
	
		Emit "{"
		Emit "BBDEBUGDECL_CONST,"
		Emit Enquote(decl.ident) + ","
		Emit Enquote(TransDebugScopeType(decl.ty) + TransDebugMetaData(decl.metadata.metadataString)) + ","
		
		_appInstance.mapStringConsts(decl.value)
		
		Emit ".const_value=&" + TStringConst(_appInstance.stringConsts.ValueForKey(decl.value)).id
		Emit "},"

	End Method

	Method EmitClassFieldsDebugScope(classDecl:TClassDecl)

		' Don't list superclass fields in our debug scope
		'If classDecl.superClass Then
		'	EmitClassFieldsDebugScope(classDecl.superClass)
		'End If

		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			Emit "{"
			Emit "BBDEBUGDECL_FIELD,"
			Emit Enquote(decl.ident) + ","
			Emit Enquote(TransDebugScopeType(decl.ty) + TransDebugMetaData(decl.metadata.metadataString)) + ","

			Local offset:String = ".field_offset=offsetof"
			
			If classDecl.IsStruct() Then
				offset :+ Bra("struct " + classDecl.munged + "," + decl.munged)
			Else
				offset :+ Bra("struct " + classDecl.munged + "_obj," + decl.munged)
			End If
'			If WORD_SIZE = 8 Then
'				Emit Bra("BBLONG") + offset
'			Else
			Emit offset
'			End If
			'If Not TFunctionPtrType(decl.ty) Then
			'	Emit TransType(decl.ty, classDecl.actual.munged) + " _" + classDecl.actual.munged.ToLower() + "_" + decl.ident.ToLower() + ";"
			'Else
			'	Emit TransType(decl.ty, "_" + classDecl.actual.munged.ToLower() + "_" + decl.ident.ToLower()) + ";"
			'End If
			Emit "},"
			
			'offset:+ decl.ty.GetSize()
		Next
		
		'Return offset
	End Method
	
	Method EmitClassStandardMethodDebugScope(ident:String, ty:String, munged:String)
			Emit "{"
			Emit "BBDEBUGDECL_TYPEMETHOD,"
			Emit Enquote(ident) + ","
			Emit Enquote(ty) + ","
			Emit "&" + munged
			Emit "},"
	End Method
	
	Method TransDebugMetaData:String(meta:String)
		If meta Then
			Return "{" + meta + "}"
		End If
	End Method

	Method EmitBBClassFuncsDebugScope(decl:TFuncDecl)

			Emit "{"
			If decl.IsMethod() Then
				Emit "BBDEBUGDECL_TYPEMETHOD,"
			Else
				Emit "BBDEBUGDECL_TYPEFUNCTION,"
			End If
			Emit Enquote(decl.ident) + ","
			
			Local s:String = "("
			For Local i:Int = 0 Until decl.argDecls.length
				If i Then
					s:+ ","
				End If
				s:+ TransDebugScopeType(decl.argDecls[i].ty)
			Next
			s:+ ")"

			If decl.retType Then
				s:+ TransDebugScopeType(decl.retType)
			End If

			s:+ TransDebugMetaData(decl.metadata.metadataString)

			Emit Enquote(s) + ","
			If decl.IsMethod() Or decl.IsCTor() Then 
				Emit "&_" + decl.munged
			Else
				Emit "&" + decl.munged
			End If
			Emit "},"
	End Method

	Method BBClassClassFuncsDebugScopeBuildList(classDecl:TClassDecl, list:TList)
		'Local reserved:String = ",New,Delete,ToString,Compare,SendMessage,_reserved1_,_reserved2_,_reserved3_,".ToLower()

		For Local decl:TDecl=EachIn classDecl.GetAllFuncDecls(Null, False)
			Local fdecl:TFuncDecl =TFuncDecl( decl )
			If fdecl
				If Not fdecl.IsSemanted()
					fdecl.Semant()
				End If
				If Not classDecl.IsInterface() And fdecl.IsAbstract() Then
					Continue
				End If

				If Not equalsBuiltInFunc(classDecl, fdecl) Then
				
					Local ignore:Int
					Local link:TLink=list._head._succ
					While link<>list._head
						If fdecl.ident = TFuncDecl(link._value).ident Then
							If fdecl.overrides Then
								link._value = fdecl
								ignore = True
								Exit
							End If
						EndIf
						link = link._succ
					Wend

					If Not ignore Then
						list.AddLast(fdecl)
					End If
				
					Continue
				End If
			EndIf
		Next
	End Method
	

	Method EmitBBClassClassFuncsDebugScope(classDecl:TClassDecl)
	
		Local list:TList = New TList
		
		BBClassClassFuncsDebugScopeBuildList(classDecl, list)
	
		For Local fdecl:TFuncDecl = EachIn list
			EmitBBClassFuncsDebugScope( fdecl )
		Next

	End Method

	Method EmitClassFuncsDebugScope(classDecl:TClassDecl)

		If classDecl.IsExtern() Return

		Local classid$=classDecl.munged
		Local superid$
		If classDecl.superClass Then
			superid = classDecl.superClass.actual.munged
		End If

		Local ret:String = "()i"
		If opt_issuperstrict Then
			ret = "()"
		End If
		
		If Not classDecl.IsInterface() Then
			EmitClassStandardMethodDebugScope("New", ret, "_" + classid + "_New")
		End If
	
		If classHasFunction(classDecl, "ToString") Then
			EmitClassStandardMethodDebugScope("ToString", "()$", "_" + classidForFunction(classDecl, "ToString") + "_ToString")
			'Emit "_" + classid + "_ToString,"
		End If

		If classHasFunction(classDecl, "Compare") Then
			EmitClassStandardMethodDebugScope("Compare", "(:Object)i", "_" + classidForFunction(classDecl, "Compare") + "_Compare")
			'Emit "_" + classid + "_ObjectCompare,"
		End If

		If classHasFunction(classDecl, "SendMessage") Then
			EmitClassStandardMethodDebugScope("SendMessage", "(:Object, :Object):Object", "_" + classidForFunction(classDecl, "SendMessage") + "_SendMessage")
			'Emit "_" + classid + "_SendMessage,"
		End If

		EmitBBClassClassFuncsDebugScope(classDecl)

	End Method
	
	Method EmitClassGlobalDebugScope( classDecl:TClassDecl )
		For Local decl:TGlobalDecl = EachIn classDecl.Decls()
			EmitGlobalDebugScope(decl)
		Next
	End Method

	Method EmitGlobalDebugScope( decl:TGlobalDecl )
		Emit "{"
		Emit "BBDEBUGDECL_GLOBAL,"
		Emit Enquote(decl.ident) + ","
		Emit Enquote(TransDebugScopeType(decl.ty)) + ","
		Emit "&" + decl.munged
		Emit "},"
	End Method

	Method CountBBClassClassFuncsDebugScope(classDecl:TClassDecl, count:Int Var)

		For Local decl:TDecl=EachIn classDecl.GetAllFuncDecls(Null, False)
			Local fdecl:TFuncDecl =TFuncDecl( decl )
			If fdecl
				If Not classDecl.IsInterface() And fdecl.IsAbstract() Then
					Continue
				End If

				If Not equalsBuiltInFunc(classDecl, fdecl) Then
					count :+ 1
				End If
			End If
		Next
	End Method

	Method CountClassConstsDebugScope(classDecl:TClassDecl, count:Int Var)

		For Local decl:TConstDecl = EachIn classDecl.Decls()
			count :+ 1
		Next
	End Method

	Method CountClassFieldsDebugScope(classDecl:TClassDecl, count:Int Var)

		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			count :+ 1
		Next
	End Method
	
	Method DebugScopeDeclCount:Int(classDecl:TClassDecl)
		Local count:Int = 2 ' "New" counts as first one
		
		' but we don't use "New" for interfaces...
		If classDecl.IsInterface() Or (classDecl.IsExtern() And classDecl.IsStruct()) Then
			count :- 1
		End If

		' consts		
		CountClassConstsDebugScope(classDecl, count)

		' fields
		CountClassFieldsDebugScope(classDecl, count)
		
		' standard methods
		If classHasFunction(classDecl, "ToString") Then
			count :+ 1
		End If

		If classHasFunction(classDecl, "Compare") Then
			count :+ 1
		End If

		If classHasFunction(classDecl, "SendMessage") Then
			count :+ 1
		End If
		
		' methods and functions
		CountBBClassClassFuncsDebugScope(classDecl, count)
		
		' class globals
		For Local decl:TGlobalDecl = EachIn classDecl.Decls()
			count :+ 1
		Next
		
		Return count
	End Method

	Method EmitClassDecl( classDecl:TClassDecl )

		PushEnv classDecl
		'If classDecl.IsTemplateInst()
		'	Return
		'EndIf

		If classDecl.IsExtern() And Not classDecl.IsStruct() Then
			Return
		EndIf

		Local classid$=classDecl.munged
		Local superid$
		If classDecl.superClass Then
			superid = classDecl.superClass.actual.munged
		End If


		If Not classDecl.IsExtern() Then
			' process nested functions for new
			Local decl:TFuncDecl = classDecl.FindFuncDecl("new",,,,,,SCOPE_CLASS_HEIRARCHY)
			If decl And decl.scope = classDecl Then ' only our own New method, not any from superclasses
				decl.Semant
				' emit nested protos
				For Local fdecl:TFuncDecl = EachIn decl._decls
					EmitFuncDecl(fdecl, True, False)
				Next
				
				' emit nested bodies
				For Local fdecl:TFuncDecl = EachIn decl._decls
					EmitFuncDecl(fdecl, False, False)
				Next
			End If
	
			EmitClassDeclNewList(classDecl)
			
			' process nested functions for delete
			decl = classDecl.FindFuncDecl("delete",,,,,,SCOPE_CLASS_HEIRARCHY)
			If decl Then
				decl.Semant
				' emit nested protos
				For Local fdecl:TFuncDecl = EachIn decl._decls
					EmitFuncDecl(fdecl, True, False)
				Next
				
				' emit nested bodies
				For Local fdecl:TFuncDecl = EachIn decl._decls
					EmitFuncDecl(fdecl, False, False)
				Next
			End If
	
			If classHierarchyHasFunction(classDecl, "Delete") Then
				EmitClassDeclDelete(classDecl)
			End If
	
			Rem
			'fields ctor
			Emit classid+"::"+classid+"(){"
			For Local decl:TDecl=EachIn classDecl.Semanted()
				Local fdecl:TFieldDecl=TFieldDecl( decl )
				If Not fdecl Continue
				Emit TransField(fdecl,Null)+"="+fdecl.init.Trans()+";"
			Next
			Emit "}"
			End Rem
			Local reserved:String = ",New,Delete,".ToLower()
	
			'methods
			For Local decl:TDecl=EachIn classDecl.Decls()
	
				Local fdecl:TFuncDecl=TFuncDecl( decl )
				If fdecl
					If reserved.Find("," + fdecl.IdentLower() + ",") = -1 Then
						EmitGDBDebug(fdecl)
						EmitFuncDecl fdecl, , True
						Continue
					End If
				EndIf
	
			'Local gdecl:TGlobalDecl=TGlobalDecl( decl )
			'If gdecl
			'		Emit TransRefType( gdecl.ty )+" "+classid+"::"+gdecl.munged+";"
			'		Continue
			'	EndIf
			Next
			Rem
			'gc_mark
			Emit "void "+classid+"::mark(){"
			If classDecl.superClass
				Emit classDecl.superClass.actual.munged+"::mark();"
			EndIf
			For Local decl:TDecl=EachIn classDecl.Semanted()
				Local fdecl:TFieldDecl=TFieldDecl( decl )
				If fdecl EmitMark TransField(fdecl,Null),fdecl.ty,True
			Next
			Emit "}"
			End Rem
	
			For Local decl:TDecl=EachIn classDecl.Semanted()
				Local gdecl:TGlobalDecl =TGlobalDecl( decl )
				If gdecl
					If TFunctionPtrType(gdecl.ty) Then
						Emit TransRefType( gdecl.ty, gdecl.munged ) + ";"
					Else
						Emit TransRefType( gdecl.ty, "" )+" "+gdecl.munged+";"
					End If
					Continue
				EndIf
			Next
	
			reserved = ",New,Delete,ToString,Compare,SendMessage,_reserved1_,_reserved2_,_reserved3_,".ToLower()

		End If

			
		'Emit "struct _" + classid + "_DebugScope{"
		'Emit "int kind;"
		'Emit "const char *name;"
		'Emit "BBDebugDecl decls[" + DebugScopeDeclCount(classDecl) + "];"
		'Emit "};"
		Local count:Int = DebugScopeDeclCount(classDecl)
		
		' debugscope
		If count > 1 Then
			_app.scopeDefs.Insert(String(count - 1), "")
			Emit "struct BBDebugScope_" + (count - 1) + " " + classid + "_scope ={"
		Else
			Emit "struct BBDebugScope " + classid + "_scope ={"
		End If
		
		If classDecl.IsInterface() Then
			Emit "BBDEBUGSCOPE_USERINTERFACE,"
		Else If classDecl.IsStruct() Then
			Emit "BBDEBUGSCOPE_USERSTRUCT,"
		Else
			Emit "BBDEBUGSCOPE_USERTYPE,"
		End If
		Emit EnQuote(classDecl.ident + TransDebugMetaData(classDecl.metadata.metadataString)) + ","

		Emit "{"
		
		' debug const decls
		EmitClassConstsDebugScope(classDecl)
		
		' debug field decls
		EmitClassFieldsDebugScope(classDecl)
		
		' debug global decls
		EmitClassGlobalDebugScope(classDecl)
		
		' debug func decls
		EmitClassFuncsDebugScope(classDecl)
		
		Emit "BBDEBUGDECL_END"
		Emit "}"

		Emit "};"
		
		Local fdecls:TFuncDecl[] = classDecl.GetAllFuncDecls()
		Local implementedInterfaces:TMap = classDecl.GetInterfaces()
		Local ifcCount:Int

		If Not classDecl.IsStruct() Then

			' interface class implementation
			If Not classDecl.IsInterface()
				If Not implementedInterfaces.IsEmpty() Then
					Emit "struct " + classid + "_vdef {"
					For Local ifc:TClassDecl = EachIn implementedInterfaces.Values()
						Emit "struct " + ifc.munged + "_methods interface_" + ifc.ident + ";"
						ifcCount :+ 1
					Next
					Emit "};~n"
				
					Emit "static struct BBInterfaceOffsets " + classid + "_ifc_offsets[] = {"
					For Local ifc:TClassDecl = EachIn implementedInterfaces.Values()
						Emit "{&" + ifc.munged + "_ifc, offsetof(struct " + classid + "_vdef, interface_" + ifc.ident + ")},"
					Next
					Emit "};~n"
		
					Emit "struct " + classid + "_vdef " + classid + "_ifc_vtable = {"
					For Local ifc:TClassDecl = EachIn implementedInterfaces.Values()
						Emit ".interface_" + ifc.ident + "={"
						
						For Local func:TFuncDecl = EachIn ifc.GetImplementedFuncs()
						
							If func.IsMethod() Then
							
								For Local f:TFuncDecl = EachIn fdecls
									Mungdecl f
									If f.ident = func.ident And func.EqualsFunc(f) Then
										Emit "_" + f.munged + ","
										Exit
									End If
								Next
						
							End If
						Next
						Emit "},"
					Next
					Emit "};~n"
					
					Emit "struct BBInterfaceTable " + classid + "_itable = {"
					Emit classid + "_ifc_offsets,"
					Emit "&" + classid + "_ifc_vtable,"
					Emit ifcCount
					Emit "};~n"
				End If
			End If
			
			Emit "struct BBClass_" + classid + " " + classid + "={"
	
			' super class reference
			Emit "&" + classDecl.superClass.munged + ","
			Emit "bbObjectFree,"
			' debugscope
			Emit "&" + classid + "_scope,"
			' object instance size
			Emit "sizeof" + Bra("struct " + classid + "_obj") + ","
	
			' standard methods
			Emit "_" + classid + "_New,"
	
			If Not classHierarchyHasFunction(classDecl, "Delete") Then
				Emit "bbObjectDtor,"
			Else
				Emit "_" + classid + "_Delete,"
			End If
	
			If classHierarchyHasFunction(classDecl, "ToString") Then
				Emit "_" + classidForFunction(classDecl, "ToString") + "_ToString,"
			Else
				Emit "bbObjectToString,"
			End If
	
			If classHierarchyHasFunction(classDecl, "Compare") Then
				Emit "_" + classidForFunction(classDecl, "Compare") + "_Compare,"
			Else
				Emit "bbObjectCompare,"
			End If
	
			If classHierarchyHasFunction(classDecl, "SendMessage") Then
				Emit "_" + classidForFunction(classDecl, "SendMessage") + "_SendMessage,"
			Else
				Emit "bbObjectSendMessage,"
			End If
	
			'Emit "public:"
	
			'fields
			'For Local decl:TDecl=EachIn classDecl.Semanted()
			'	Local fdecl:TFieldDecl =TFieldDecl( decl )
			'	If fdecl
			'		Emit TransRefType( fdecl.ty )+" "+fdecl.munged+";"
			'		Continue
			'	EndIf
			'Next
	
			'fields ctor
			'Emit classid+"();"
	
			'methods
			'For Local decl:TDecl=EachIn classDecl.Semanted()
			'
			'	Local fdecl:TFuncDecl =TFuncDecl( decl )
			'	If fdecl
			'		EmitFuncProto fdecl
			'		Continue
			'	EndIf
			'
			'	Local gdecl:TGlobalDecl =TGlobalDecl( decl )
			'	If gdecl
			'		Emit "static "+TransRefType( gdecl.ty )+" "+gdecl.munged+";"
			'		Continue
			'	EndIf
			'Next
	
			'gc mark
			'Emit "void mark();"
	
			If classDecl.IsInterface() Or implementedInterfaces.IsEmpty() Then
				' itable
				Emit "0,"
				' extra pointer
				Emit "0,"
			Else
				Emit "&" + classid + "_itable,"
				' extra pointer
				Emit "0,"
			End If
	
			' obj_size
			Emit TransObjectSize(classDecl)
	
	
			' methods/funcs
			'reserved = "New,Delete,ToString,ObjectCompare,SendMessage".ToLower()
	
			'For Local decl:TFuncDecl = EachIn classDecl.Decls()
			For Local decl:TFuncDecl = EachIn fdecls
	
				If Not equalsBuiltInFunc(classDecl, decl) And Not equalsTorFunc(classDecl, decl) Then
	
					MungDecl decl
	
					If decl.IsMethod() Then
						Emit ",_" + decl.munged
					Else
						Emit "," + decl.munged
					End If
				End If
			Next
	
			Emit "};~n"
	
			If classDecl.IsInterface()  Then
				Emit "const struct BBInterface " + classid + "_ifc = { &" + classid + ", (const char *) ~q" + classDecl.ident + "~q };"
			Else
				
			End If
			
		End If
		
		PopEnv

	End Method

	Method TransObjectSize:String(classDecl:TClassDecl)
		Local t:String
		
		Local fieldDecl:TFieldDecl

		For Local decl:TFieldDecl = EachIn classDecl.Decls()
			fieldDecl = decl
		Next
		
		If fieldDecl Then
			t = "offsetof" + Bra("struct " + classDecl.munged + "_obj," + fieldDecl.munged) + " - sizeof(void*) + sizeof" + Bra(TransType(fieldDecl.ty, ""))
		Else
			t = "0"
		End If

		Return t
	End Method
	
	
	Method EmitClassDeclNew( classDecl:TClassDecl, fdecl:TFuncDecl )
		Local classid$=classDecl.munged
		Local superid$=classDecl.superClass.actual.munged

		Local t:String = "void _" 
		
		If fdecl.argDecls.Length Then
			If classDecl = fdecl.scope Then
				t :+ fdecl.munged
			Else
				t :+ classDecl.munged + "_" + fdecl.ident + MangleMethod(fdecl)
			End If
		Else
			t :+ classid + "_New"
		End If
		
		'Find decl we override
		Local odecl:TFuncDecl=fdecl
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		Local args:String = TransObject(classdecl, True) + " o"

		For Local i:Int=0 Until fdecl.argDecls.Length
			Local arg:TArgDecl=fdecl.argDecls[i]
			Local oarg:TArgDecl=odecl.argDecls[i]
			MungDecl arg, True
			If args args:+","
			If Not TFunctionPtrType(oarg.ty) Then
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )+" "+arg.munged
				Else
					args:+ oarg.castTo + " " + arg.munged
				End If
			Else
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo
				End If
			End If
			If arg.ty.EqualsType( oarg.ty ) Continue
		Next
		
		Emit t + Bra(args) + " {"
		
		Local newDecl:TNewDecl = TNewDecl(fdecl)
		
		If Not classDecl.IsStruct() Then
			' calling constructor?
			If newDecl And newDecl.chainedCtor Then
				mungdecl newDecl.chainedCtor.ctor
				
				Emit "_" + newDecl.chainedCtor.ctor.ClassScope().munged + "_" + newDecl.chainedCtor.ctor.ident + MangleMethod(newDecl.chainedCtor.ctor) + TransArgs(newDecl.chainedCtor.args, newDecl.chainedCtor.ctor, "o") + ";"
			Else
				If classDecl.superClass.ident = "Object" Then
					Emit "bbObjectCtor(o);"
				Else
					Emit "_" + superid + "_New(o);"
				End If
			End If
	
			Emit "o->clas = (BBClass*)&" + classid + ";"
		End If

		' only initialise fields if we are not chaining to a local (in our class) constructor.
		' this prevents fields being re-initialised through the call-chain.
		If Not newDecl.chainedCtor Or (newDecl.chainedCtor And classDecl <> newDecl.chainedCtor.ctor.scope) Then

			' field initialisation
			For Local decl:TFieldDecl=EachIn classDecl.Decls()
			
				Local fld:String
	
				' ((int*)((char*)o + 5))[0] =
				fld :+ TransFieldRef(decl, "o")
	
				If decl.init Then
					If TObjectType(decl.ty) And TObjectType(decl.ty).classdecl.IsExtern() And TObjectType(decl.ty).classdecl.IsStruct() Then
						' skip for uninitialised extern type
						If Not isPointerType(decl.ty) And TConstExpr(decl.init) And Not TConstExpr(decl.init).value Then
							Continue
						End If
					End If
	
					' initial value
					If (TConstExpr(decl.init) And Not TConstExpr(decl.init).value) And TIntrinsicType(decl.ty) Then
						fld :+ "= "
						If TFloat64Type(decl.ty) Then
							fld :+ "_mm_setzero_si64();"
						Else If TFloat128Type(decl.ty) Then
							fld :+ "_mm_setzero_ps();"
						Else If TDouble128Type(decl.ty) Then
							fld :+ "_mm_setzero_pd();"
						Else If TInt128Type(decl.ty) Then
							fld :+ "_mm_setzero_si128();"
						End If
					Else
						If TObjectType(decl.ty) And TObjectType(decl.ty).classdecl.IsStruct() And Not isPointerType(decl.ty) And (TConstExpr(decl.init) And Not TConstExpr(decl.init).value) Then
							fld = "memset(&" + fld + ", 0, sizeof" + Bra(TransType(decl.ty, "")) + ");"
						Else
							fld :+ "= " + decl.init.Trans() + ";"
						End If
					End If
				Else
					If TNumericType(decl.ty) Or TObjectType(decl.ty) Or IsPointerType(decl.ty, 0, TType.T_POINTER) Then
						fld :+ "= 0;"
					Else If TFunctionPtrType(decl.ty) Then
						fld :+ "= &brl_blitz_NullFunctionError;"
					Else If TStringType(decl.ty) Then
						fld :+ "= &bbEmptyString;"
					Else If TArrayType(decl.ty) Then
						fld :+ "= &bbEmptyArray;"
					End If
				End If
	
				Emit fld
			Next
		
		End If

		'Local decl:TFuncDecl = classDecl.FindFuncDecl("new",,,,,,SCOPE_CLASS_LOCAL)
		If fdecl And (fdecl.scope = classDecl Or fdecl.argDecls.Length) Then ' only our own New method, not any from superclasses
			fdecl.Semant
			If fdecl.munged <> "bbObjectCtor" Then
				EmitLocalDeclarations(fdecl)
				EmitBlock fdecl
			End If
		End If

		'
		Emit "}"
	End Method

	Method EmitClassDeclNewList( classDecl:TClassDecl )
		Local classid$=classDecl.munged
		Local superid$=classDecl.superClass.actual.munged

		Local newDecls:TFuncDeclList = TFuncDeclList(classdecl.FindDeclList("new", SCOPE_CLASS_LOCAL))
		
		For Local fdecl:TFuncDecl = EachIn newDecls
		
			EmitClassDeclNew(classDecl, fdecl)

			' generate "objectNew" function if required
			If (fdecl.argDecls And fdecl.argDecls.length) Or classDecl.IsStruct() Then
				EmitClassDeclNewInit(classDecl, fdecl)
			End If
		
		Next

	End Method

	Method EmitClassDeclNewListProto( classDecl:TClassDecl )
		Local classid$=classDecl.munged
		'Local superid$=classDecl.superClass.actual.munged

		Local newDecls:TFuncDeclList = TFuncDeclList(classdecl.FindDeclList("new", SCOPE_CLASS_LOCAL))
		
		For Local fdecl:TFuncDecl = EachIn newDecls
		
			EmitClassDeclNewProto(classDecl, fdecl)
		
			' generate "objectNew" function if required
			If (fdecl.argDecls And fdecl.argDecls.length) Or classDecl.IsStruct() Then
				EmitClassDeclObjectNewProto(classDecl, fdecl)
			End If
		
		Next

	End Method
	
	Method EmitClassDeclNewInit(classDecl:TClassDecl, fdecl:TFuncDecl)

		Local funcMunged:String
		
		If classDecl = fdecl.scope Then
			funcMunged = fdecl.munged
		Else
			funcMunged = classDecl.munged + "_" + fdecl.ident + MangleMethod(fdecl)
		End If

		Local t:String = TransObject(classdecl) + " _" + funcMunged + "_ObjectNew"

		'Find decl we override
		Local odecl:TFuncDecl=fdecl
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		Local args:String
		
		If Not classDecl.IsStruct() Then
			args = "BBClass * clas"
		End If

		For Local i:Int=0 Until fdecl.argDecls.Length
			Local arg:TArgDecl=fdecl.argDecls[i]
			Local oarg:TArgDecl=odecl.argDecls[i]
			MungDecl arg, True
			If args args:+","
			If Not TFunctionPtrType(oarg.ty) Then
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )+" "+arg.munged
				Else
					args:+ oarg.castTo + " " + arg.munged
				End If
			Else
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo
				End If
			End If
			If arg.ty.EqualsType( oarg.ty ) Continue
		Next
		
		Emit t + Bra(args) + " {"

		t = TransObject(classdecl) + " o"

		If classDecl.IsStruct() Then
			Emit t + ";"
		Else
			t :+ " = "
			If ClassHasObjectField(classDecl) Then
				t :+ "bbObjectNewNC"
			Else
				t :+ "bbObjectAtomicNewNC"
			End If
		
			Emit t + "(clas);"
		End If
		
		t = "_" + funcMunged
		
		If classDecl.IsStruct() Then
			t :+ "(&o"
		Else
			t :+ "(o"
		End If
		
		For Local i:Int=0 Until fdecl.argDecls.Length
			Local arg:TArgDecl=fdecl.argDecls[i]
			t :+ ", " + arg.munged
		Next
		
		Emit t + ");"
		
		Emit "return o;"
		
		Emit "}"
		
	End Method

	Method EmitClassDeclNewProto( classDecl:TClassDecl, fdecl:TFuncDecl )
		Local classid$=classDecl.munged
		Local superid$
		If classDecl.superClass Then
			superid = classDecl.superClass.actual.munged
		End If

		Local t:String = "void _" 
		
		If fdecl.argDecls.Length Then
			If classDecl = fdecl.scope Then
				t :+ fdecl.munged
			Else
				t :+ classDecl.munged + "_" + fdecl.ident + MangleMethod(fdecl)
			End If
		Else
			t :+ classid + "_New"
		End If
		
		'Find decl we override
		Local odecl:TFuncDecl=fdecl
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		Local args:String = TransObject(classdecl, True) + " o"

		For Local i:Int=0 Until fdecl.argDecls.Length
			Local arg:TArgDecl=fdecl.argDecls[i]
			Local oarg:TArgDecl=odecl.argDecls[i]
			MungDecl arg, True
			If args args:+","
			If Not TFunctionPtrType(oarg.ty) Then
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )+" "+arg.munged
				Else
					args:+ oarg.castTo + " " + arg.munged
				End If
			Else
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo
				End If
			End If
			If arg.ty.EqualsType( oarg.ty ) Continue
		Next
		
		Emit t + Bra(args) + ";"
	End Method
	
	Method EmitClassDeclObjectNewProto(classDecl:TClassDecl, fdecl:TFuncDecl)

		Local t:String = TransObject(classdecl) + " _"
		
		If classDecl = fdecl.scope Then
			t :+ fdecl.munged
		Else
			t :+ classDecl.munged + "_" + fdecl.ident + MangleMethod(fdecl)
		End If
		
		t:+ "_ObjectNew"
			
		'Find decl we override
		Local odecl:TFuncDecl=fdecl
		While odecl.overrides
			odecl=odecl.overrides
		Wend

		Local args:String
		If Not classDecl.IsStruct() Then
			args = "BBClass * clas"
		End If

		For Local i:Int=0 Until fdecl.argDecls.Length
			Local arg:TArgDecl=fdecl.argDecls[i]
			Local oarg:TArgDecl=odecl.argDecls[i]
			MungDecl arg, True
			If args args:+","
			If Not TFunctionPtrType(oarg.ty) Then
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )+" "+arg.munged
				Else
					args:+ oarg.castTo + " " + arg.munged
				End If
			Else
				If Not odecl.castTo Then
					args:+TransType( oarg.ty, arg.munged )
				Else
					args:+ oarg.castTo
				End If
			End If
			If arg.ty.EqualsType( oarg.ty ) Continue
		Next
		
		Emit t + Bra(args) + ";"

	End Method

	Method EmitClassDeclDelete( classDecl:TClassDecl )
		Local classid$=classDecl.munged
		Local superid$=classDecl.superClass.actual.munged

		' New
'		If opt_issuperstrict Then
			Emit "void _" + classid + "_Delete" + Bra(TransObject(classdecl) + " o") + " {"
'		Else
'			Emit "int _" + classid + "_Delete" + Bra(TransObject(classdecl) + " o") + " {"
'		End If

		Local decl:TFuncDecl = classDecl.FindFuncDecl("delete",,,,,,SCOPE_CLASS_HEIRARCHY)
		If decl Then
			decl.Semant
			EmitLocalDeclarations(decl)
			EmitBlock decl
		End If


		' field cleanup
		For Local decl:TFieldDecl=EachIn classDecl.Decls()


			' String
			If TStringType(decl.declTy) Then
				Emit "BBRELEASE(" + TransFieldRef(decl, "o") + ")"
			End If

			' object
			' TODO

		Next

		' finally, call super delete
		EmitClassDeclDeleteDtor(classDecl)

		'
		Emit "}"
	End Method
	
	Method EmitClassDeclDeleteDtor( classDecl:TClassDecl )
		Local superid$=classDecl.superClass.actual.munged
		
		If classDecl.superClass.ident = "Object" Or Not classHierarchyHasFunction(classDecl.superClass, "Delete") Then
			Emit "bbObjectDtor(o);"
		Else
			Emit "_" + superid + "_Delete(o);"
		End If
	End Method

	Method TransFieldRef:String(decl:TFieldDecl, variable:String, exprType:TType = Null)
		Local s:String = variable
'DebugStop
		Local ind:String = "->"
		If decl.scope And TClassDecl(decl.scope) And TClassDecl(decl.scope).IsStruct() Then
			If exprType And Not IsPointerType(exprType) And variable <> "o" Then
				ind = "."
			End If
		End If

		If variable.StartsWith("*") Then
			variable = Bra(variable)
		End If
		
		' Null test
		If opt_debug
			If TClassDecl(decl.scope) And TClassDecl(decl.scope).IsStruct() Then
				'
			Else
				variable = TransDebugNullObjectError(variable, TClassDecl(decl.scope))
			End If
		End If

		' array.length
		If decl.scope And decl.scope.ident = "___Array" Then
			If decl.ident = "length" Then
				Return Bra(variable + "->scales[0]")
			End If
			If decl.ident = "numberOfDimensions" Then
				Return Bra(variable + "->dims")
			End If
			If decl.ident = "sizeMinusHeader" Then
				Return Bra(variable + "->size")
			End If
			If decl.ident = "elementTypeEncoding" Then
				Return Bra(variable + "->type")
			End If
		End If

		' string methods
		If decl.scope And decl.scope.ident = "String" Then
			If decl.ident = "length" Then
				'If exprType._flags & TType.T_VAR Then
				'	Return Bra("(*" + variable + ")->length")
				'Else
					If variable.StartsWith("&_s") Then
						Return Bra(variable[1..] + ".length")
					Else
						Return Bra(variable + "->length")
					End If
				'End If
			End If
		End If

		'If TObjectType(exprType) And (exprType._flags & TType.T_VAR) Then
		'	' get the object from the pointer
		'	variable = Bra("*" + variable)
		'End If

		If IsNumericType(decl.ty) Then
			s = variable + ind + decl.munged + " "
		Else If TStringType(decl.ty) Then
			s = variable + ind + decl.munged + " "
		Else If TObjectType(decl.ty) Then
			s = variable + ind + decl.munged + " "
		Else If IsPointerType(decl.ty, 0, TType.T_POINTER) Then
			s = variable + ind + decl.munged + " "
		Else If TFunctionPtrType(decl.ty) Then
			s = variable + ind + decl.munged + " "
		Else If TArrayType(decl.ty) Then
			s = variable + ind + decl.munged + " "
		End If

		Return s
	End Method

	' " _" + classDecl.actual.munged + "_" + decl.ident.ToLower(

	Method TransIfcArgs:String(funcDecl:TFuncDecl)
		Local args:String

		If Not funcDecl.IsSemanted() Then
			funcDecl.Semant()
		End If

		For Local i:Int=0 Until funcDecl.argDecls.Length
			Local arg:TArgDecl = funcDecl.argDecls[i]

			If args args:+","
			args:+ arg.ident + TransIfcType( arg.ty )

			If arg.init Then
				If TInvokeExpr(arg.init) Then
					args:+ "=" + Enquote(TInvokeExpr(arg.init).decl.munged)
				Else
					args:+ "=" + TransIfcConstExpr(arg.init)
				End If
			End If
		Next

		Return Bra(args)
	End Method

	Method EmitIfcClassFuncDecl(funcDecl:TFuncDecl)

		funcDecl.Semant

		Local func:String

		' method / function
		If funcDecl.IsMethod() Or funcDecl.IsCTor() Then
			func :+ "-"
		Else
			func :+ "+"
		End If

		If funcDecl.attrs & FUNC_OPERATOR Then
			func :+ BmxEnquote(funcDecl.ident)
		Else
			func :+ funcDecl.ident
		End If

		func :+ TransIfcType(funcDecl.retType, funcDecl.ModuleScope().IsSuperStrict())

		' function args
		func :+ TransIfcArgs(funcDecl)

		If funcDecl.attrs & DECL_FINAL Then
			func :+ "F"
		Else If funcDecl.attrs & DECL_ABSTRACT Then
			func :+ "A"
		End If
		
		If funcDecl.attrs & FUNC_OPERATOR Then
			func :+ "O"
		End If
		
		If funcDecl.attrs & DECL_PRIVATE Then
			func :+ "P"
		Else If funcDecl.attrs & DECL_PROTECTED Then
			func :+ "R"
		End If


		func :+ "="

		func :+ Enquote(funcDecl.munged)

		Emit func

	End Method

	Method EmitIfcFuncDecl(funcDecl:TFuncDecl)

		Local func:String

		func :+ funcDecl.ident

		' ensure the function has been semanted
		funcDecl.Semant()

		func :+ TransIfcType(funcDecl.retType, funcDecl.ModuleScope().IsSuperStrict())

		' function args
		func :+ TransIfcArgs(funcDecl)

		func :+ "="

		func :+ Enquote(funcDecl.munged)

		If funcDecl.castTo Then
			func :+ ":" + funcDecl.castTo
			func :+ " " + funcDecl.munged + "("

			For Local i:Int = 0 Until funcDecl.argDecls.length
				If i Then
					func :+ ", "
				End If

				func :+ funcDecl.argDecls[i].castTo
			Next

			func :+ ")"
		End If

		Emit func

	End Method

	Method TransIfcConstExpr:String(expr:TExpr)

		If Not expr.exprType Then
			expr.Semant()
		End If

		If TStringType(expr.exprType) Then
			Return "$" + EscapeChars(BmxEnquote(expr.Eval()))
		EndIf

		If TArrayType(expr.exprType) Then
			Return Enquote("bbEmptyArray")
		End If

		If TFunctionPtrType(expr.exprType) Then
			If TCastExpr(expr) Then
				If TInvokeExpr(TCastExpr(expr).expr) Then
					Return Enquote(TInvokeExpr(TCastExpr(expr).expr).decl.munged)
				End If
				If TNullExpr(TCastExpr(expr).expr) Then
					Return Enquote("brl_blitz_NullFunctionError")
				End If
			End If

			InternalErr
		End If

		If TObjectType(expr.exprType) Then
			If TCastExpr(expr) Then
				If TNullExpr(TCastExpr(expr).expr) Then
					Return Enquote("bbNullObject")
				End If
			End If
		End If
		
		If IsPointerType(expr.exprType, 0, TType.T_POINTER) Then
			If TCastExpr(expr) Then
				If TNullExpr(TCastExpr(expr).expr) Then
					Return "0"
				End If
				If TConstExpr(TCastExpr(expr).expr) Then
					Return TConstExpr(TCastExpr(expr).expr).value
				End If
			End If
		End If

		If IsNumericType(expr.exprType) Then
			Local s:String = expr.Eval()
			If Not s Then
				Return "0"
			Else
				If TDecimalType(expr.exprType) Then
					Return s + TransIfcType(expr.exprType)
				Else
					Return s
				End If
			End If
		EndIf

		'If TObjectType(expr.exprType) And TNullDecl(TObjectType(expr.exprType).classDecl) Then
		'	Return Enquote("bbNullObject")
		'End If

	End Method

	Method EmitIfcConstDecl(constDecl:TConstDecl)
		Local c:String
		c = constDecl.ident + TransIfcType(constDecl.ty)

		If TExpr(constDecl.init) Then
			c:+ "=" + TransIfcConstExpr(TExpr(constDecl.init))
		End If

		Emit c
	End Method

	Method EmitIfcFieldDecl(fieldDecl:TFieldDecl)
		Local f:String = "." + fieldDecl.ident + TransIfcType(fieldDecl.ty, fieldDecl.ModuleScope().IsSuperStrict())

		f :+ "&"
		
		If fieldDecl.IsPrivate() Then
			f :+ "`"
		Else If fieldDecl.IsProtected() Then
			f :+ "``"
		End If

		Emit f
	End Method

	Method EmitIfcClassDecl(classDecl:TClassDecl)

		Local head:String = classDecl.ident + "^"
		If classDecl.superClass Then
			head :+ classDecl.superClass.ident
		Else
			head :+ "Null"
		End If
		
		If classDecl.implments Then
			head :+ "@"
			For Local i:Int = 0 Until classDecl.implments.length
				If i Then
					head :+ ","
				End If
				head :+ classDecl.implments[i].ident
			Next
		End If
		
		Emit head + "{", False

		'PushMungScope
		BeginLocalScope

		' fields, globals and consts
'		For Local decl:TDecl=EachIn classDecl.Decls()

		' const
		For Local cDecl:TConstDecl = EachIn classDecl.Decls()
			cDecl.Semant()
			
			EmitIfcConstDecl(cDecl)
		Next

			' global
		For Local gDecl:TGlobalDecl = EachIn classDecl.Decls()
			gDecl.Semant()

			EmitIfcGlobalDecl(gDecl)
		Next


			' field
		For Local fDecl:TFieldDecl = EachIn classDecl.Decls()
			fDecl.Semant()

			EmitIfcFieldDecl(fDecl)
		Next


		' functions
		If Not classDecl.IsExtern() Then

			Emit "-New()=" + Enquote("_" + classDecl.munged + "_New")
			If classHierarchyHasFunction(classDecl, "Delete") Then
				Emit "-Delete()=" + Enquote("_" + classDecl.munged + "_Delete")
			End If

			For Local decl:TDecl=EachIn classDecl.Decls()

				Local fdecl:TFuncDecl=TFuncDecl( decl )
				If fdecl
					If Not equalsIfcBuiltInFunc(classDecl, fdecl) Then
						EmitIfcClassFuncDecl fdecl
					End If
					Continue
				EndIf

			Next
			
			Local flags:String
			
			If classDecl.IsAbstract() Then
				flags :+ "A"
			End If
			
			If classDecl.attrs & DECL_FINAL Then
				flags :+ "F"
			End If

			If classDecl.attrs & CLASS_INTERFACE Then
				flags :+ "I"
			Else If classDecl.IsStruct() Then
				flags :+ "S"
			End If
			
			Emit "}" + flags + "=" + Enquote(classDecl.munged), False
		Else
			For Local decl:TDecl=EachIn classDecl.Decls()

				Local fdecl:TFuncDecl=TFuncDecl( decl )
				If fdecl
					EmitIfcClassFuncDecl fdecl
					Continue
				EndIf

			Next
			
			Local flags:String = "E"
			
			If classDecl.IsInterface() Then
				flags :+ "I"
			Else If classDecl.IsStruct() Then
				flags :+ "S"
			End If
			
			If classDecl.attrs & DECL_API_WIN32 Then
				flags :+ "W"
			End If

			Emit "}" + flags + "=0", False
		End If

		'PopMungScope
		EndLocalScope

	End Method

	Method EmitIfcGlobalDecl(globalDecl:TGlobalDecl)

		globalDecl.Semant

		Local g:String = globalDecl.ident

		g:+ TransIfcType(globalDecl.ty, globalDecl.ModuleScope().IsSuperStrict())

		g:+ "&"

		If globalDecl.IsPrivate() Then
			g :+ "`"
		Else If globalDecl.IsProtected() Then
			g :+ "``"
		End If

		g :+ "="

		g :+ "mem:p("
		If TFunctionPtrType(globalDecl.ty) Then
			g :+ Enquote(TFunctionPtrType(globalDecl.ty).func.munged)
		Else
			g :+ Enquote(globalDecl.munged)
		End If
		g :+ ")"

		Emit g
	End Method

	Method EmitModuleInclude(moduleDecl:TModuleDecl, included:TMap = Null)
		If moduleDecl.filepath Then
			' a module import
			If FileType(moduleDecl.filepath) = FILETYPE_DIR Or (opt_ismain And moduleDecl.ident = opt_modulename) Then

				Local inc:String = ModuleHeaderFromIdent(moduleDecl.ident, True)

				If Not included Or (included And Not included.Contains(inc)) Then
					Emit "#include <" + inc + ">"
					If included Then
						included.Insert(inc, inc)
					End If
				End If
			Else
				' a file import...
				Local inc:String = FileHeaderFromFile(moduleDecl, False)

				If Not included Or (included And Not included.Contains(inc)) Then
					Emit "#include ~q" + inc + "~q"
					If included Then
						included.Insert(inc, inc)
					End If
				End If
			End If
'			DebugLog moduleDecl.filepath
		End If
	End Method

	Method EmitModuleInit(moduleDecl:TModuleDecl)
		If moduleDecl.filepath Then
			' a module import
			If FileType(moduleDecl.filepath) = FILETYPE_DIR Then
				Emit MungModuleName(moduleDecl) + "();"
			Else
				' maybe a file import...
				Emit MungImportFromFile(moduleDecl) + "();"
			End If
		End If
	End Method

	Method EmitIncBinFile(ib:TIncbin)

		If FileType(ib.path) = FILETYPE_FILE Then

			Local ident:String = _appInstance.munged + "_ib_" + ib.id

			Local buf:Byte[] = LoadByteArray(ib.path)
			ib.length = buf.length

			Emit "unsigned char " + ident + "[] = {"
			Local s:String

			Local hx:Short[2]
			For Local i:Int = 0 Until buf.length
				Local val:Int = buf[i]

				For Local k:Int=1 To 0 Step -1
					Local n:Int=(val&15)+48
					If n>57 n:+39
					hx[k]=n
					val:Shr 4
				Next
				s :+ "0x" + String.FromShorts( hx,2 )

				s :+ ","

				If s.length > 80 Then
					Emit s
					s = ""
				End If
			Next

			Emit s
			Emit "};"

		End If

	End Method

	Method TransHeader(app:TAppDecl)

		SetOutput("head")

		_app = app

		prefix = app.GetPathPrefix()

		' TODO

		If Not opt_apptype Then
			app.mainFunc.munged="bb_localmain"
		Else
			app.mainFunc.munged="bb_main"
		End If

		' track what's been included so far - avoid duplicates
		Local included:TMap = New TMap

		For Local decl:TModuleDecl=EachIn app.imported.Values()
			For Local mdecl:TDecl=EachIn decl.imported.Values()

				MungDecl mdecl

				'skip mdecls we are not interested in
				If Not TModuleDecl(mdecl) Then Continue
				If app.mainModule = mdecl Then Continue
				If mdecl.ident = "brl.classes" Then Continue
				If mdecl.ident = "brl.blitzkeywords" Then Continue

				EmitModuleInclude(TModuleDecl(mdecl), included)
			Next
		Next
		
		For Local header:String=EachIn app.headers
			Emit "#include ~q../" + header + "~q"
		Next

		Emit "int " + app.munged + "();"
		
		For Local decl:TDecl=EachIn app.Semanted()

			If decl.declImported Continue

			MungDecl decl

			Local cdecl:TClassDecl=TClassDecl( decl )
			If Not cdecl Continue

' mung, but don't emit
'			Emit prefix + decl.munged+";"

			'PushMungScope
			funcMungs = New TMap
			BeginLocalScope

			For Local decl:TDecl=EachIn cdecl.Semanted()
				MungDecl decl
				
				cdecl.SemantParts()
			Next

			EndLocalScope
			'PopMungScope
		Next

		' forward declarations
		For Local decl:TClassDecl=EachIn app.Semanted()
			If decl.declImported Or (decl.IsExtern() And Not decl.IsStruct()) Continue
			If Not decl.IsStruct()
				Emit "struct " + decl.munged + "_obj;"
			Else
				Emit "struct " + decl.munged + ";"
			End If
			If decl.IsInterface() Then
				Emit "extern const struct BBInterface " + decl.munged + "_ifc;"
			End If
		Next

		'prototypes/header! - structs first
		For Local decl:TDecl=EachIn app.Semanted()

			If decl.declImported Continue

			Local cdecl:TClassDecl=TClassDecl( decl )
			If cdecl
				If cdecl.IsStruct() Then
					EmitStructClassProto cdecl
				End If
			EndIf
		Next

		'prototypes/header!
		For Local decl:TDecl=EachIn app.Semanted()

			If decl.declImported Continue

			Local gdecl:TGlobalDecl=TGlobalDecl( decl )
			If gdecl
				MungDecl gdecl
				
				If Not TFunctionPtrType(gdecl.ty) Then
If Not gdecl.IsPrivate() Then
					Emit "extern "+TransRefType( gdecl.ty, "" )+" "+gdecl.munged+";"	'forward reference...
End If
				Else
					If Not TFunctionPtrType(gdecl.ty).func.noCastGen Then
						' generate function pointer refs if we haven't been told not to
'						If Not gdecl.IsExtern() Then
							Emit TransRefType( gdecl.ty, gdecl.munged )+";"	'forward reference...
'						End If
					End If
				End If
				Continue
			EndIf

			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl' And Not fdecl.IsExtern()
				' don't include the main function - it's handled separately
				If fdecl = app.mainFunc Then
					Continue
				End If

				EmitGDBDebug(fdecl)
				EmitFuncDecl( fdecl, True)
				Continue
			EndIf

			Local cdecl:TClassDecl=TClassDecl( decl )
			If cdecl
				If Not cdecl.IsStruct() Then
					If Not cdecl.IsExtern()
						EmitClassProto cdecl
					Else
						EmitExternClassProto cdecl
					End If
				'Else
				'	EmitStructClassProto cdecl
				End If
				'Continue
			EndIf
		Next

	End Method

	Method IncBinRequiresRebuild:Int(file:String, incbins:TList)

		' file doesn't exist?
		If Not FileType(file) Then
			Return True
		End If

		Local timestamp:Int = FileTime(file)

		' file exists... read header and compare names
		' read lines until "// ----"
		' TODO
		Local files:TList = New TList
		Local stream:TStream = ReadFile(file)
		While True
			Local s:String = ReadLine(stream)
			If Not s.StartsWith("// ") Or s.StartsWith("// ----") Then
				Exit
			End If

			Local ind:Int = s.Find("// FILE : ")
			If ind = 0 Then
				files.AddLast(s[10..].Replace("~q",""))
			End If
		Wend
		stream.Close()

		' different number of files?
		If files.Count() <> incbins.Count() Then
			Return True
		End If

		' different file names?
		Local count:Int
		For Local s:String = EachIn files
			For Local ib:TIncbin = EachIn incbins
				If s = ib.file Then
					count :+ 1
					Exit
				End If
			Next
		Next

		If count <> files.count() Then
			Return True
		End If

		count = 0
		For Local ib:TIncbin = EachIn incbins
			For Local s:String = EachIn files
				If s = ib.file Then
					count :+ 1
					Exit
				End If
			Next
		Next

		If count <> incbins.count() Then
			Return True
		End If

		For Local ib:TIncbin = EachIn incbins
			If timestamp < FileTime(ib.path) Then
				Return True
			End If

			' set the length, as we will need this later if we aren't loading the files now.
			ib.length = FileSize(ib.path)
		Next

		Return False
	End Method

	Method TransIncBin(app:TAppDecl)
		If app.incbins.Count() > 0 Then

			SetOutput("incbin")

			Local mung:String = FileMung(False)

			Local name:String = StripAll(app.mainModule.filepath)
			Local file:String = name + ".bmx" + mung + ".incbin.h"
			Local filepath:String = OutputFilePath(opt_filepath, mung, "incbin.h")

			If IncBinRequiresRebuild(filepath, app.incbins) Then

				app.genIncBinHeader = True

				For Local ib:TIncbin = EachIn app.incbins
					Emit "// FILE : " + Enquote(ib.file)
				Next

				Emit "// ----"

				For Local ib:TIncbin = EachIn app.incbins
					EmitIncBinFile(ib)
				Next

			End If

			SetOutput("pre_source")

			Emit "#include ~q" + file + "~q"
		End If
	End Method

	Method TransGlobalInit(decl:TGlobalDecl)
		If TFunctionPtrType(decl.ty) Then
			If TInvokeExpr(decl.init) And Not TInvokeExpr(decl.init).invokedWithBraces Then
				Emit TransGlobal( decl )+"="+TInvokeExpr(decl.init).decl.munged + ";"
			Else
				Emit TransGlobal( decl )+"="+decl.init.Trans()+";"
			End If
		Else
			If Not decl.funcGlobal Then
				Emit TransGlobal( decl )+"="+decl.init.Trans()+";"
			End If
		End If
	End Method

	Method TransSource(app:TAppDecl)

		SetOutput("pre_source")

		' include our header
		EmitModuleInclude(app.mainModule)

		' incbins
		TransIncBin(app)

		SetOutput("source")

		' Private Global declarations
		' since we don't declare them in the header, they need to be near the top of the source
		For Local decl:TDecl=EachIn app.Semanted()

			If decl.declImported Continue

			Local gdecl:TGlobalDecl=TGlobalDecl( decl )
			If gdecl And gdecl.IsPrivate() Then

				If Not TFunctionPtrType(gdecl.ty) Then
					If TConstExpr(gdecl.init) Then
						Emit TransRefType( gdecl.ty, "WW" )+" "+TransGlobalDecl(gdecl)+";"
						gdecl.inited = True
					Else
If Not gdecl.IsExtern() Then
						Emit TransRefType( gdecl.ty, "WW" )+" "+gdecl.munged+";"
Else
					' delcare in source for any references to it locally in this module
					Emit "extern "+TransRefType( gdecl.ty, "WW" )+" "+gdecl.munged+";"
End If
					End If
				Else
					'Emit TransRefType( gdecl.ty, gdecl.munged ) + ";"
				End If
				Continue
			EndIf
			
		Next

		For Local gdecl:TGlobalDecl=EachIn app.SemantedGlobals
			If gdecl And gdecl.funcGlobal Then
				MungDecl gdecl
				
				If Not TFunctionPtrType(gdecl.ty) Then
					Emit "static " + TransRefType( gdecl.ty, "WW" )+" "+gdecl.munged+";"
				Else
					Emit "static " + TransRefType( gdecl.ty, gdecl.munged ) + ";"
				End If
				Continue
			End If
		Next


		'definitions!
		For Local decl:TDecl=EachIn app.Semanted()

			If decl.declImported Continue

			Local gdecl:TGlobalDecl=TGlobalDecl( decl )
			If gdecl
				If Not TFunctionPtrType(gdecl.ty) And Not gdecl.IsPrivate() Then
					If TConstExpr(gdecl.init) Then
						Emit TransRefType( gdecl.ty, "WW" )+" "+TransGlobalDecl(gdecl)+";"
						gdecl.inited = True
					Else
If Not gdecl.IsExtern() Then
						Emit TransRefType( gdecl.ty, "WW" )+" "+gdecl.munged+ "=" + TransValue(gdecl.ty, "") + ";"
End If
					End If
				Else
					'Emit TransRefType( gdecl.ty, gdecl.munged ) + ";"
				End If
				Continue
			EndIf

			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl And Not fdecl.IsExtern()

				' don't include the main function - it's handled separately
				If fdecl = app.mainFunc Then
					Continue
				End If

				EmitGDBDebug(fdecl)
				EmitFuncDecl fdecl
				Continue
			EndIf

			Local cdecl:TClassDecl=TClassDecl( decl )
			If cdecl
				EmitGDBDebug(cdecl)
				EmitClassDecl cdecl
				Continue
			EndIf
		Next

		Emit "static int " + app.munged + "_inited" + " = 0;"

		Emit "int " + app.munged + "(){"

		' initialise stuff
		Emit "if (!" + app.munged + "_inited) {"
		Emit app.munged + "_inited = 1;"

		' register incbins
		For Local ib:TIncbin = EachIn app.incbins
			Emit "bbIncbinAdd(&" + TStringConst(app.stringConsts.ValueForKey(ib.file)).id + ",&" + app.munged + "_ib_" + ib.id + "," + ib.length + ");"
		Next
		
		Local importOnce:TMap = New TMap
		
		' call any imported mod inits
		For Local decl:TModuleDecl=EachIn app.imported.Values()
			For Local mdecl:TDecl=EachIn decl.imported.Values()
				If TModuleDecl(mdecl) And app.mainModule <> mdecl And mdecl.ident <> "brl.classes" And mdecl.ident <> "brl.blitzkeywords" Then
					If Not importOnce.Contains(mdecl.ident) Then
						EmitModuleInit(TModuleDecl(mdecl))
						importOnce.Insert(mdecl.ident, "")
					End If
				End If
			Next
		Next

		' register types
		For Local decl:TDecl=EachIn app.Semanted()

			If decl.declImported Continue

			Local cdecl:TClassDecl=TClassDecl( decl )
			If cdecl And Not cdecl.IsExtern()
				If Not cdecl.IsInterface() Then
					If Not cdecl.IsStruct() Then
						Emit "bbObjectRegisterType(&" + cdecl.munged + ");"
					Else
						Emit "bbObjectRegisterStruct(&" + cdecl.munged + "_scope);"
					End If
				Else
					Emit "bbObjectRegisterInterface(&" + cdecl.munged + "_ifc);"
				End If
			EndIf
		Next
		'

		' defdata init
		If Not app.dataDefs.IsEmpty() Then
			Emit "_defDataOffset = &_defData;"
		End If

		' initialise globals
		For Local decl:TGlobalDecl=EachIn app.semantedGlobals

			If decl.declImported Continue

			decl.Semant

			' TODO : what about OnDebugStop etc, who have no init ?
			If decl.init And Not (decl.attrs & DECL_INITONLY) Then

				If decl.scope And TClassDecl(decl.scope) Then

					' class global inits need to be generated in the correct order.
					' only generate global inits if the parent class hasn't already been processed,
					' otherwise, we will skip this global as it should already have been generated.
					If Not TClassDecl(decl.scope).globInit Then
					
						TClassDecl(decl.scope).globInit = True
					
						For Local gdecl:TGlobalDecl = EachIn decl.scope._decls
						
							If gdecl.declImported Continue
							
							gdecl.Semant
							
							If gdecl.init And Not (gdecl.attrs & DECL_INITONLY) Then
								TransGlobalInit(gdecl)
							End If
						Next
					End If
					
				Else
					TransGlobalInit(decl)
				End If

			End If
		Next

		' now do the local main stuff
		app.mainFunc.Semant()
		EmitLocalDeclarations(app.mainFunc)
		EmitBlock app.mainFunc


		Emit "}"
		Emit "return 0;"
		Emit "}"

		' redirect string generation to the top of the source
		SetOutput("pre_source")

		' strings
		For Local s:String = EachIn app.stringConsts.Keys()
			If s Then
				Local key:TStringConst = TStringConst(app.stringConsts.ValueForKey(s))

				If key.count > 0 Then
					Emit "static BBString " + key.id + "={"
					Emit "&bbStringClass,"
					'Emit "2147483647,"
					Emit s.length + ","

					Local t:String = "{"

					For Local i:Int = 0 Until s.length
						If i Then
							t:+ ","
						End If
						t:+ s[i]

						If i And Not (i Mod 16) Then
							Emit t
							t = ""
						End If
					Next

					Emit t + "}"

					Emit "};"
				End If
			End If
		Next
		
		' defdata
		EmitDefDataArray(app)
		
		' scope defs
		If Not app.scopedefs.IsEmpty() Then
			For Local val:String = EachIn app.scopedefs.Keys()
				Local i:Int = val.ToInt()
				Emit "struct BBDebugScope_" + i + "{int kind; const char *name; BBDebugDecl decls[" + (i + 1) + "]; };"
			Next
		End If

	End Method
	
	Method EmitDefDataArray(app:TAppDecl)
		If Not app.dataDefs.IsEmpty() Then
			' 
			Emit "static struct bbDataDef * _defDataOffset;"
			Emit "static struct bbDataDef _defData[" + TDefDataDecl.count + "]={"
			
			For Local decl:TDefDataDecl = EachIn app.dataDefs
				EmitDefData(decl)
			Next
			
			Emit "};"
		End If
	End Method

	Method EmitDefData(decl:TDefDataDecl)
		For Local i:Int = 0 Until decl.data.length
			Local expr:TExpr = decl.data[i]
			
			Emit "{"
		
			Emit TransDefDataType(expr.exprType) + ","
			
			Emit "{"
			Emit "." + TransDefDataUnionType(expr.exprType) + " = " + expr.Trans()
			Emit "}"
		
			Emit "},"
		Next
	End Method

	Method EmitIfcImports(impMod:TModuleDecl, processed:TMap)

		For Local decl:TDecl=EachIn impMod.imported.Values()
			Local mdecl:TModuleDecl=TModuleDecl( decl )
			If mdecl And mdecl.ident <> "brl.classes" And mdecl.ident <> "brl.blitzkeywords" Then
				If mdecl.filepath.EndsWith(".bmx")
					If _appInstance.mainModule<>mdecl
						EmitIfcImports(mdecl, processed)

						For Local s:String = EachIn mdecl.fileImports
							If Not processed.Contains("XX" + s + "XX") Then
								Emit "import " + BmxEnquote(s)
								processed.Insert("XX" + s + "XX", "")
							End If
						Next
					End If
				Else
					If Not processed.Contains(mdecl.ident)
						Emit "import " + mdecl.ident
						processed.Insert(mdecl.ident, "")
					End If
				End If
			End If
		Next

	End Method

	Method EmitIfcStructImports(impMod:TModuleDecl, processed:TMap)
		For Local decl:TDecl=EachIn impMod.imported.Values()
			Local mdecl:TModuleDecl=TModuleDecl( decl )
			If mdecl Then
				If mdecl.filepath.EndsWith(".bmx") And _appInstance.mainModule<>mdecl And Not processed.Contains(mdecl)
					EmitIfcStructImports(mdecl, processed)

					processed.Insert(mdecl, mdecl)

					For Local decl:TDecl=EachIn mdecl._decls

						decl.Semant
						
						' consts
						Local cdecl:TConstDecl=TConstDecl( decl )
						If cdecl
							EmitIfcConstDecl(cdecl)
							Continue
						End If

						' classes
						Local tdecl:TClassDecl=TClassDecl( decl )
						If tdecl
							EmitIfcClassDecl(tdecl)
							Continue
						EndIf

						' functions
						Local fdecl:TFuncDecl=TFuncDecl( decl )
						If fdecl And fdecl <> _appInstance.mainFunc Then
							EmitIfcFuncDecl(fdecl)
							Continue
						End If

						' globals
						Local gdecl:TGlobalDecl=TGlobalDecl( decl )
						If gdecl
							EmitIfcGlobalDecl(gdecl)
							Continue
						End If
					Next

				End If
			End If
		Next

	End Method

	Method FileHeaderFromFile:String(mdecl:TModuleDecl, includePath:Int = False)

		Local name:String = StripAll(mdecl.filepath)
		Local dir:String = ExtractDir(mdecl.filePath)

		Local file:String = name + ".bmx" + FileMung(opt_apptype And (Not mdecl.declImported)) + ".h"

		If mdecl.relPath Then
			Local dir:String = ExtractDir(mdecl.relPath)
			If dir Then
				file = "../" + dir + "/.bmx/" + file
			End If
		End If

		Return file
	End Method

	Method MungImportFromFile:String(mdecl:TModuleDecl)

		Local result:String
		If opt_buildtype <> BUILDTYPE_MODULE Then
			Local dir:String = ExtractDir(mdecl.filepath).ToLower()
			dir = dir[dir.findLast("/") + 1..]
			If dir.EndsWith(".mod") Then
				dir = dir.Replace(".mod", "")
			End If
			Local file:String = StripDir(mdecl.filepath).ToLower()
			result = "_bb_" + dir + "_" + StripExt(file)
		Else
			result = "_bb_" + mdecl.ident
		End If

		'return with all non-allowed chars (like "-" or " ") removed
		Return TStringHelper.Sanitize(result)
	End Method

	Method TransInterface(app:TAppDecl)

		SetOutput("interface")

		If app.mainModule.IsSuperStrict() Then
			Emit "superstrict"
		End If

		' module info
		For Local info:String = EachIn app.mainModule.modInfo
			Emit "ModuleInfo " + BmxEnquote(info)
		Next

		Local processed:TMap = New TMap

		' module imports
		For Local decl:TDecl=EachIn app.mainModule.imported.Values()
			Local mdecl:TModuleDecl=TModuleDecl( decl )
			If mdecl Then
				If mdecl.IsActualModule() Then
					Emit "import " + mdecl.ident
					processed.Insert(mdecl.ident, "")
				Else If Not opt_ismain And mdecl.filepath.EndsWith(".bmx") And app.mainModule<>mdecl
					Local file:String = StripDir(mdecl.filepath)
					If mdecl.relPath Then
						Local dir:String = ExtractDir(mdecl.relPath)
						If dir Then
							file = dir + "/" + file
						End If
					End If
					If Not processed.Contains(file) Then
						Emit "import " + Enquote(file)
						processed.Insert(file, "")
					End If
				End If
			End If
		Next

		' module imports from other files?
		If opt_buildtype = BUILDTYPE_MODULE And opt_ismain Then
			EmitIfcImports(app.mainModule, processed)
		End If

		' other imports
		For Local s:String = EachIn app.fileImports
			Emit "import " + BmxEnquote(s)
		Next


		processed = New TMap
		' imported module structure (consts, classes, functions, etc)
		If opt_buildtype = BUILDTYPE_MODULE And opt_ismain Then
			EmitIfcStructImports(app.mainModule, processed)
		End If

		' consts
		For Local decl:TDecl=EachIn app.Semanted()
			If decl.IsPrivate() Continue

			Local cdecl:TConstDecl=TConstDecl( decl )
			If cdecl And Not cdecl.declImported
				EmitIfcConstDecl(cdecl)
			End If
		Next

		' classes
		For Local decl:TDecl=EachIn app.Semanted()
			If decl.IsPrivate() Continue

			Local cdecl:TClassDecl=TClassDecl( decl )
			If cdecl And Not cdecl.declImported
				EmitIfcClassDecl(cdecl)
			EndIf
		Next

		' functions
		For Local decl:TDecl=EachIn app.Semanted()
			If decl.IsPrivate() Continue

			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl And fdecl <> app.mainFunc  And Not fdecl.declImported Then
				EmitIfcFuncDecl(fdecl)
			End If
		Next

		' globals
		For Local decl:TDecl=EachIn app.Semanted()
			If decl.IsPrivate() Continue

			Local gdecl:TGlobalDecl=TGlobalDecl( decl )
			If gdecl And Not gdecl.declImported
				EmitIfcGlobalDecl(gdecl)
			End If
		Next

	End Method

	Method TransApp( app:TAppDecl )

		If app.mainModule.IsSuperStrict()
			opt_issuperstrict = True
		End If

		TransHeader(app)

		TransSource(app)

		TransInterface(app)

	End Method
	
End Type

' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'

Const DECL_EXTERN:Int=      $010000
Const DECL_PRIVATE:Int=     $020000
Const DECL_ABSTRACT:Int=    $040000
Const DECL_FINAL:Int=       $080000

Const DECL_SEMANTED:Int=    $100000
Const DECL_SEMANTING:Int=   $200000

Const DECL_POINTER:Int=     $400000

Const DECL_ARG:Int=         $800000
Const DECL_INITONLY:Int=   $1000000

Const DECL_NODEBUG:Int=    $2000000
Const DECL_PROTECTED:Int=  $4000000

Const DECL_API_WIN32:Int= $10000000
Const DECL_API_OS:Int=DECL_API_WIN32

Const CLASS_INTERFACE:Int=  $001000
Const CLASS_THROWABLE:Int=  $002000
Const CLASS_STRUCT:Int=     $004000

Const SCOPE_FUNC:Int = 0
Const SCOPE_CLASS_LOCAL:Int = 1
Const SCOPE_CLASS_HEIRARCHY:Int = 2
Const SCOPE_MODULE:Int = 3
Const SCOPE_ALL:Int = 4

Global _env:TScopeDecl
Global _envStack:TList=New TList

Global _appInstance:TAppDecl

Global _loopnest:Int

Function PushEnv( env:TScopeDecl )
	If _env _envStack.AddLast( _env )
	_env=env
End Function

Function PopEnv()
	_env=TScopeDecl( _envStack.RemoveLast() )
End Function

Type TFuncDeclList Extends TList
	Field ident:String
	Field _identLower:String
	
	Method IdentLower:String()
		If Not _identLower Then
			_identLower = ident.ToLower()
		End If
		Return _identLower
	End Method
End Type

Type TMetadata

	Field metadataString:String

	' key/value pairs
	Field meta:TMap

	Method InsertMeta(key:String, value:String)
		If Not meta Then
			meta = New TMap
		End If
		
		meta.Insert(key, value)
	End Method

	Method HasMeta:Int(key:String)
		Return meta And meta.Contains(key.ToLower())
	End Method
	
End Type

Type TDecl
	Field ident$
	Field munged$
	Field errInfo$
	Field actual:TDecl
	Field scope:TScopeDecl
	Field attrs:Int
	Field metadata:TMetadata = New TMetadata
	
	Field declImported:Int = False
	Field generated:Int
	
	Field _identLower:String
	
	Method New()
		errInfo=_errInfo
		actual=Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True) Abstract
	
	Method IdentLower:String()
		If Not _identLower Then
			_identLower = ident.ToLower()
		End If
		Return _identLower
	End Method
	
	Method ToString$()
		If TClassDecl( scope ) Return scope.ToString()+"."+ident
		Return ident
	End Method
	
	Method ToTypeString:String()
	End Method
	
	Method IsExtern:Int()
		Return (attrs & DECL_EXTERN)<>0
	End Method
	
	Method IsPrivate:Int()
		Return (attrs & DECL_PRIVATE)<>0
	End Method

	Method IsProtected:Int()
		Return (attrs & DECL_PROTECTED)<>0
	End Method
	
	Method IsPublic:Int()
		Return Not (IsPrivate() Or IsProtected())
	End Method
	
	Method IsAbstract:Int()
		Return (attrs & DECL_ABSTRACT)<>0
	End Method
	
	Method IsSemanted:Int()
		Return (attrs & DECL_SEMANTED)<>0
	End Method
	
	Method IsSemanting:Int()
		Return (attrs & DECL_SEMANTING)<>0
	End Method
	
	Method IsNoDebug:Int()
		Return (attrs & DECL_NODEBUG)<>0
	End Method
	
	Method FuncScope:TFuncDecl()
		If TFuncDecl( Self ) Return TFuncDecl( Self )
		If scope Return scope.FuncScope()
	End Method

	Method ClassScope:TClassDecl()
		If TClassDecl( Self ) Return TClassDecl( Self )
		If scope Return scope.ClassScope()
	End Method
	
	Method ModuleScope:TModuleDecl()
		If TModuleDecl( Self ) Return TModuleDecl( Self )
		' "app" is a module container
		If TAppDecl( Self ) Return TAppDecl( Self).mainModule
		If scope Return scope.ModuleScope()
	End Method
	
	Method AppScope:TAppDecl()
		If TAppDecl( Self ) Return TAppDecl( Self )
		If scope Return scope.AppScope()
	End Method
	
	Method CheckAccess:Int()
		If IsPrivate() And ModuleScope()<>_env.ModuleScope() Return False
		Return True
	End Method
	
	Method AssertAccess()
		If Not CheckAccess()
			If IsPrivate() Then
				Err ToString() +" is private."
			Else
				Err ToString() +" is protected."
			End If
		EndIf
	End Method

	Method Copy:TDecl(deep:Int = True)
		Local t:TDecl=OnCopy(deep)
		t.munged=munged
		t.errInfo=errInfo
		Return t
	End Method

	Method Semant()

		If IsSemanted() Return

		If IsSemanting() Err "Cyclic declaration of '"+ident+"'."
		
		If actual<>Self
			actual.Semant
		EndIf

		PushErr errInfo
		
		If scope
			PushEnv scope
		EndIf
		
		attrs:|DECL_SEMANTING

		'If ident And ClassScope() Print "Semanting "+ToString()

		OnSemant
		
		attrs:&~DECL_SEMANTING

		attrs:|DECL_SEMANTED

		If scope 
			'If Not IsExtern()
			If TFuncDecl(Self) And attrs & FUNC_PTR
				'DebugLog "**** " + ident
			Else

				scope._semanted.AddLast Self
				
				If TGlobalDecl( Self )
					' FIXME
					If AppScope() Then
						AppScope().semantedGlobals.AddLast TGlobalDecl( Self )
					End If
				EndIf
				
				If TModuleDecl( scope )
'DebugStop
					' FIXME
					Local app:TAppDecl = AppScope()
					If app Then
						app._semanted.AddLast Self
					End If
				EndIf
			
			EndIf
			
			If TValDecl(Self) And TValDecl(Self).deferInit Then
				TValDecl(Self).SemantInit
			End If

			PopEnv
		Else
			If TValDecl(Self) And TValDecl(Self).deferInit Then
				TValDecl(Self).SemantInit
			End If
		EndIf
		
		
		PopErr
	End Method
	
	Method InitInstance:TDecl( decl:TDecl )
		decl.ident=ident
		decl.munged=munged
		decl.errInfo=errInfo
		decl.actual=actual
		decl.scope=Null
		decl.attrs=attrs & ~(DECL_SEMANTED|DECL_SEMANTING)
		Return decl
	End Method
	
	Method GenInstance:TDecl()
		InternalErr
	End Method
	
	Method OnSemant() Abstract

End Type

Type TValDecl Extends TDecl
	'pre-semant
	Field declTy:TType
	Field declInit:TExpr
	'post-semant
	Field ty:TType
	Field init:TExpr
	
	Field deferInit:Int = False
	
	Method ToString$()
		Local t$=Super.ToString()
		If ty Return t+":"+ty.ToString()
		If declTy Return t+":"+declTy.ToString()
		Return t+":?"
	End Method

	Method ToTypeString:String()
		If ty Return ty.ToString()
		If declTy Return declTy.ToString()
	End Method

	Method CopyInit:TExpr()
		If init Return init.Copy()
	End Method
	
	Method OnSemant()
	
		If declTy
			' ensure to set the scope for a function pointer array before semanting
			If TArrayType(declTy) And TFunctionPtrType(TArrayType(declTy).elemType) Then
				If Not TFunctionPtrType(TArrayType(declTy).elemType).func.scope Then
					If scope Then
						TFunctionPtrType(TArrayType(declTy).elemType).func.scope = scope
					Else
						TFunctionPtrType(TArrayType(declTy).elemType).func.scope = _env
					End If
				End If
			End If

			' pass the scope into the function ptr
			If TFunctionPtrType(declTy) Then
				If Not TFunctionPtrType(declTy).func.scope Then
					If scope Then
						TFunctionPtrType(declTy).func.scope = scope
					Else
						TFunctionPtrType(declTy).func.scope = _env
					End If
				End If
			End If
			
			ty=declTy.Semant()

			If Not deferInit Then
				SemantInit()
			End If
			
		Else If declInit
			If Not deferInit Then
				SemantInit()
			End If
		Else
			InternalErr
		EndIf
		
	End Method
	
	Method SemantInit()
		' for field initialisation, create a stub New() method to use as current scope
		' since fields are initialised in New(). Otherwise the scope would be "class", which is
		' incorrect for processing field inits.
		If TFieldDecl(Self) And declInit Then
			Local newScope:TFuncDecl = New TFuncDecl.CreateF( "new", Null,Null,FUNC_METHOD )
			newScope.scope = _env
			PushEnv(newScope)
		End If
	
		If declTy
			If declInit Then
				If TFunctionPtrType(ty) Then
					
					' the default munged function value as defined in the interface
					If TInvokeExpr(declInit) Then
						init = declInit.Copy()
					Else If TConstExpr(declInit) Then
						init = declInit.Copy().Semant()
					Else
						Local expr:TExpr
						
						If TFuncCallExpr(declInit) Then
							expr=declInit.Copy().Semant()
						Else If TNullExpr(declInit) Then
							expr = declInit
						Else
							Local argExpr:TExpr[] = New TExpr[0]

							For Local arg:TArgDecl = EachIn TFunctionPtrType(ty).func.argDecls
								Local ldecl:TLocalDecl = New TLocalDecl.Create(arg.ident, arg.declTy, Null, 0)
								ldecl.Semant()
								Local aexp:TVarExpr = New TVarExpr.Create(ldecl)
								'Local aexp:TIdentTypeExpr = New TIdentTypeExpr.Create(arg.declTy)
								aexp.Semant()
								argExpr :+ [aexp]
							Next

							expr=declInit.Copy().SemantFunc(argExpr, False, False)
							If Not expr Then
								expr = declInit.Copy().Semant()
							End If
						End If
						
						If expr.exprType.EqualsType( ty ) Then
							init = expr
						Else
							init = New TCastExpr.Create( ty,expr,CAST_EXPLICIT ).Semant()
						End If
					End If
					
					
				Else
					If TArrayExpr(declInit) And TArrayType(ty) And TNumericType(TArrayType(ty).elemType) Then
						TArrayExpr(declInit).toType = TArrayType(ty).elemType
					End If
				
					init=declInit.Copy().SemantAndCast(ty)
				End If
			End If
		Else If declInit
			init=declInit.Copy().Semant()
			ty=init.exprType
		End If
		
		If init Then
			If TVarExpr(init) And TVarExpr(init).decl = Self Then
				Err "Identifier '" + TVarExpr(init).decl.ident + "' not found."
			End If
			
			If TNewObjectExpr(init) And TVarExpr(TNewObjectExpr(init).instanceExpr) And TVarExpr(TNewObjectExpr(init).instanceExpr).decl = Self Then
				Err "Identifier '" + Self.ident + "' not found."
			End If
		End If
		
		' remove the temporary scope
		If TFieldDecl(Self) And declInit Then
			PopEnv()
		End If
	End Method
	
End Type

Type TConstDecl Extends TValDecl
	Field value$
	
	Method Create:TConstDecl( ident$,ty:TType,init:TExpr,attrs:Int )
		Self.ident=ident
		Self.munged=ident
		Self.declTy=ty
		Self.declInit=init
		Self.attrs=attrs
		Return Self
	End Method

	Method GenInstance:TDecl()
		Local inst:TConstDecl = New TConstDecl
		InitInstance inst
		inst.declTy=declTy
		inst.declInit=declInit
		Return inst
	End Method

	Method OnCopy:TDecl(deep:Int = True)
		Return New TConstDecl.Create( ident,ty,CopyInit(), attrs )
	End Method
	
	Method OnSemant()
		Super.OnSemant()
		'If Not IsExtern() value=init.Eval()
		If init Then
			value=init.Eval()
			If TStringType(ty) And Not _appInstance.hasStringConst(value) Then
				_appInstance.mapStringConsts(value)
			End If
		End If
	End Method
	
	Method ToString$()
		Return "Const "+Super.ToString()
	End Method

End Type

Type TVarDecl Extends TValDecl

End Type

Type TLocalDecl Extends TVarDecl

	Field done:Int
	Field volatile:Int = True

	Method Create:TLocalDecl( ident$,ty:TType,init:TExpr,attrs:Int=0, generated:Int = False, volatile:Int = True )
		Self.ident=ident
		Self.declTy=ty
		Self.declInit=init
		Self.attrs=attrs
		Self.generated=generated
		Self.volatile=volatile
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Return New TLocalDecl.Create( ident,ty,CopyInit(),attrs, generated, volatile )
	End Method

	Method GetDeclPrefix:String()
		Return "Local "
	End Method
	
	Method ToString$()
		Return GetDeclPrefix() + Super.ToString()
	End Method

End Type

Type TArgDecl Extends TLocalDecl

	Field castTo:String
	
	Method Create:TArgDecl( ident$,ty:TType,init:TExpr,attrs:Int=0, generated:Int = False, volatile:Int = True )
		Self.ident=ident
		Self.declTy=ty
		Self.declInit=init
		Self.attrs=attrs
		Self.generated=generated
		Self.volatile=volatile
		Return Self
	End Method
	
	Method GenInstance:TDecl()
		Local inst:TArgDecl=New TArgDecl
		InitInstance inst
		inst.declTy=declTy
		inst.declInit=declInit
		Return inst
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Local d:TArgDecl = New TArgDecl.Create( ident,ty,CopyInit(),attrs,generated,volatile )
		d.ty = d.declTy
		d.init = d.declInit
		Return d
	End Method

	Method GetDeclPrefix:String()
		Return ""
	End Method
	
	Method ToString$()
		Return Super.ToString()
	End Method
	
End Type

Type TGlobalDecl Extends TVarDecl

	Field inited:Int
	Field funcGlobal:Int
	
	Method Create:TGlobalDecl( ident$,ty:TType,init:TExpr,attrs:Int=0,funcGlobal:Int=False )
		Self.deferInit = True
		Self.ident=ident
		Self.declTy=ty
		Self.declInit=init
		Self.attrs=attrs
		Self.funcGlobal=funcGlobal
		Return Self
	End Method

	Method OnCopy:TDecl(deep:Int = True)
		Return New TGlobalDecl.Create( ident,ty,CopyInit(),attrs,funcGlobal )
	End Method
	
	Method ToString$()
		Return "Global "+Super.ToString()
	End Method

	Method GenInstance:TDecl()
'		PushErr errInfo
'		Err "Global variables cannot be used inside generic classes."
		Local inst:TGlobalDecl=New TGlobalDecl
		InitInstance inst
		inst.declTy=declTy
		inst.declInit=declInit
		Return inst
	End Method

	Method CheckAccess:Int()
		Local cd:TClassDecl = ClassScope()
		If cd Then
			If IsPrivate() And cd<>_env.ClassScope() Return False
			If IsProtected() Then
				Local ec:TClassDecl = _env.ClassScope()
				If Not ec Return False
				If Not ec.ExtendsClass(cd) Return False
			End If
			Return True
		End If
		Return Super.CheckAccess()
	End Method

End Type

Type TFieldDecl Extends TVarDecl

	' location offset in object variable data
	Field offset:Int

	Method Create:TFieldDecl( ident$,ty:TType,init:TExpr,attrs:Int=0 )
		Self.ident=ident
		Self.declTy=ty
		Self.declInit=init
		Self.attrs=attrs
		Return Self
	End Method

	Method OnCopy:TDecl(deep:Int = True)
		Local f:TFieldDecl = New TFieldDecl.Create( ident,ty,CopyInit(),attrs )
		f.metadata = metadata
		Return f
	End Method
	
	Method ToString$()
		Return "Field "+Super.ToString()
	End Method
	
	Method GenInstance:TDecl()
		Local inst:TFieldDecl=New TFieldDecl
		InitInstance inst
		inst.declTy=declTy
		inst.declInit=declInit
		Return inst
	End Method

	Method CheckAccess:Int()
		If IsPrivate() And ClassScope()<>_env.ClassScope() Return False
		If IsProtected() And ClassScope() Then
			Local ec:TClassDecl = _env.ClassScope()
			If Not ec Return False
			If Not ec.ExtendsClass(ClassScope()) Return False
		End If
		Return True
	End Method

End Type

Type TAliasDecl Extends TDecl

	Field decl:Object
	
	Method Create:TAliasDecl( ident$,decl:Object,attrs:Int=0 )
		Self.ident=ident
		Self.decl=decl
		Self.attrs=attrs
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Return New TAliasDecl.Create( ident,decl,attrs )
	End Method
	
	Method OnSemant()
	End Method
	
End Type

Type TScopeDecl Extends TDecl

'Private

	Field _decls:TList=New TList'<TDecl>
	Field _semanted:TList=New TList'<TDecl>

	Field declsMap:TMap=New TMap'<Object>

'Public

	Method OnCopy:TDecl(deep:Int = True)
		InternalErr
	End Method

	Method Decls:TList()
		Return _decls
	End Method
	
	Method Semanted:TList()
		Return _semanted
	End Method
	
	Method FuncDecls:TList( id$="" )
		Local fdecls:TList=New TList
		For Local decl:TDecl=EachIn _decls
			If id And decl.ident<>id Continue
			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl fdecls.AddLast fdecl
		Next
		Return fdecls
	End Method
	
	Method MethodDecls:TList( id$="" )
		Local fdecls:TList=New TList
		For Local decl:TDecl=EachIn _decls
			If id And decl.ident<>id Continue
			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl And fdecl.IsMethod() fdecls.AddLast fdecl
		Next
		Return fdecls
	End Method
	
	Method SemantedFuncs:TList( id$="" )
		Local fdecls:TList=New TList
		For Local decl:TDecl=EachIn _semanted
			If id And decl.ident<>id Continue
			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl fdecls.AddLast fdecl
		Next
		Return fdecls
	End Method
	
	Method SemantedMethods:TList( id$="" )
		Local fdecls:TList=New TList
		For Local decl:TDecl=EachIn _decls
			If id And decl.ident<>id Continue
			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl And fdecl.IsMethod()
				If Not fdecl.IsSemanted() Then
					fdecl.Semant()
				End If
				fdecls.AddLast fdecl
			End If
		Next
		Return fdecls
	End Method
	
	Method InsertDecl( decl:TDecl )

		If decl.scope And Not (decl.attrs & DECL_INITONLY) InternalErr
		
		'Local ident$=decl.ident
		If Not decl.ident Return
		
		If Not decl.scope Then
			decl.scope=Self
		End If
		_decls.AddLast decl

		'Local _decls:TMap
		Local tdecl_:Object=declsMap.ValueForKey( decl.IdentLower() )
		
		If TFuncDecl( decl )
			Local funcs:TFuncDeclList=TFuncDeclList( tdecl_ )
			If funcs Or Not tdecl_
				If Not funcs
					funcs=New TFuncDeclList
					funcs.ident = decl.IdentLower()
					declsMap.Insert decl.IdentLower(),funcs
				EndIf

				funcs.AddLast TFuncDecl( decl )
				Return
			Else
				Err "Duplicate identifier '"+decl.ident+"'."
			EndIf
		Else If Not tdecl_
			declsMap.Insert decl.IdentLower(),decl
		Else
			Err "Duplicate identifier '"+decl.ident+"'."
		EndIf

	End Method

	Method InsertDecls( _decls:TList )
		For Local decl:TDecl=EachIn _decls
			InsertDecl decl
		Next
	End Method
	
	'This is overridden by TClassDecl and TModuleDecl
	Method GetDecl:Object( ident$ )
'DebugLog "GetDecl (" + Self.ident + ") : " + ident
		Local decl:Object=Object(declsMap.ValueForKey( ident ))

		If Not decl Then
			If Self.IdentLower() = ident Then
				' name matches but we are a "module", but not a *real* module..
				' .. so we can't be looking for ourself
				If TModuleDecl(Self) And Self.ident.Find(".") = - 1 Then
					decl = Null
				Else
					decl = Self
				End If
			End If
		End If
		
		If Not decl Return Null
		
		Local adecl:TAliasDecl=TAliasDecl( decl )
		If Not adecl Return decl
		
		If adecl.CheckAccess() Return adecl.decl
	End Method
	

	Method FindDecl:Object( ident$, override:Int = False )
	
		If Not override And _env<>Self Return GetDecl( ident )
		
		Local tscope:TScopeDecl=Self
		While tscope
			Local decl:Object=tscope.GetDecl( ident )
			If decl Return decl
			tscope=tscope.scope
		Wend
	End Method
	
	Method GetDeclList:Object( ident$, declList:TFuncDeclList = Null, maxSearchDepth:Int )

		If Not declList Then
			declList = New TFuncDeclList
		End If

		Local decl:Object=Object(declsMap.ValueForKey( ident ))

		If Not decl Return Null

		If TFuncDeclList(decl) Then
			For Local fdecl:TFuncDecl = EachIn TFuncDeclList(decl)

				If Not fdecl.IsSemanted() Then
					fdecl.Semant
				End If
				
				Local found:Int
				For Local func:TFuncDecl = EachIn declList
					If func.equalsFunc(fdecl) Then
						found = True
						Exit
'Else
'Print func.ToString() + "  didn't match  " + fdecl.ToString()
					End If
				Next
				
				If Not found Then
					declList.AddLast(fdecl)
				End If
			Next
			
			Return declList
		End If		
		
		Return decl
		
	End Method
	
	' returns a list of all matching named decls in scope
	Method FindDeclList:Object(ident:String, override:Int = False, declList:TFuncDeclList = Null, maxSearchDepth:Int = SCOPE_ALL )
	
		If Not declList Then
			declList = New TFuncDeclList
		End If
	
		If Not override And _env<>Self Return GetDeclList( ident, declList, maxSearchDepth )
		
		Local tscope:TScopeDecl=Self
		While tscope
			Local decl:Object=tscope.GetDeclList( ident, declList, maxSearchDepth )
			'If decl And (Not TFuncDeclList(decl) And declList.IsEmpty()) Return decl
			If decl Then
				If TFuncDeclList(decl) Then
					If TFuncDeclList(decl) <> declList Then
						For Local d:TDecl = EachIn TFuncDeclList(decl)
							declList.AddLast(d)
						Next
					End If
				Else
					declList.AddLast(decl)
				End If
			End If

			' if scope is an interface, also check implemented/extended interfaces?
			If TClassDecl(tscope) And TClassDecl(tscope).IsInterface() Then
				If TClassDecl(tscope).implments Then
					For Local idecl:TScopeDecl = EachIn TClassDecl(tscope).implments
						Local decl:Object=idecl.GetDeclList( ident, declList, maxSearchDepth )
						If decl Then
							If TFuncDeclList(decl) Then
								If TFuncDeclList(decl) <> declList Then
									For Local d:TDecl = EachIn TFuncDeclList(decl)
										declList.AddLast(d)
									Next
								End If
							Else
								declList.AddLast(decl)
							End If
						End If
					Next
				End If 
			End If
			
			tscope=tscope.scope
			
			If TClassDecl(tscope) And maxSearchDepth < SCOPE_CLASS_HEIRARCHY Then
				Exit
			Else If TModuleDecl(tscope) And maxSearchDepth < SCOPE_ALL Then
				Exit
			End If
		Wend
		
		Return declList
	End Method

	

'	Method FindDecl:Object( ident$, static:Int = False )
'		Local decl:Object=GetDecl( ident )
'		
'		If Not static Or Not decl Then
'			If decl Return decl
'		Else
'			If Not TFieldDecl(decl) And Not (TFuncDecl(decl) And TFuncDecl(decl).IsMethod()) Then
'				Return decl
'			End If
'		End If
'		If scope Return scope.FindDecl( ident, static )
'	End Method
	
	Method FindValDecl:TValDecl( ident$, static:Int = False )
		Local decl:TValDecl=TValDecl( FindDecl( ident ) )
		
		' we found a field but we don't have access to it?
		If TFieldDecl(decl) And static Then
			' see if there's another decl with the same name elsewhere that we may...
			' field's scope.scope will be a module.
			If decl.scope And decl.scope.scope Then
				Local vDecl:TValDecl = TValDecl( decl.scope.scope.FindDecl( ident, True ) )
				If vDecl Then
					decl = vDecl
				End If
			End If
		End If
		
		If Not decl Then
			' try scope search
			decl = TValDecl( FindDecl( ident, True ) )
			
			If Not decl Then
				' didn't find it? Maybe it is in module local scope?
				' issue arises when a global initialises with a local variable in the module scope.
				Local fdecl:Object = FindDecl("__localmain", True)
				If fdecl Then
					If TFuncDecl(fdecl) Then
						decl = TValDecl( TFuncDecl(fdecl).FindDecl( ident ) )
					Else If TFuncDeclList(fdecl) Then
						For Local func:TFuncDecl = EachIn TFuncDeclList(fdecl)
							func.Semant()
							decl = TValDecl( func.FindDecl( ident ) )
							If decl Then
								Exit
							End If
						Next
					End If
					
					' a local variable from module local scope can't be seen outside of module local scope...
					If TLocalDecl(decl) And static Then
						decl = Null
					End If
				End If
			End If
		End If
		If Not decl Return Null
		decl.AssertAccess
		decl.Semant
		Return decl
	End Method

	Method FindType:TType( ident$,args:TType[] )
'DebugLog Self.ident + "::FindType::" + ident
		Local decl:Object=(GetDecl( ident ))
		If decl Then
			If TModuleDecl(decl) Then
				decl = TModuleDecl(decl).GetDecl(ident)
			End If
			Local ty:TType=TType(decl)
			If ty
				If args.Length Err "Wrong number of type arguments"
				Return ty
			EndIf
			Local cdecl:TClassDecl=TClassDecl( decl )
			If cdecl
				cdecl.AssertAccess
				cdecl=cdecl.GenClassInstance( args )
				cdecl.Semant
				Return cdecl.objectType
			EndIf
		EndIf
		If scope Return scope.FindType( ident,args )
	End Method
	
	Method FindScopeDecl:TScopeDecl( ident$ )
		Local decl:TScopeDecl=TScopeDecl( FindDecl( ident ) )
		If Not decl Return Null
		decl.AssertAccess
		decl.Semant
		Return decl
	End Method
Rem	
	Method FindClassDecl:TClassDecl( ident$,args:TClassDecl[] = Null )
		Local decl:TClassDecl=TClassDecl( GetDecl( ident ) )
		If Not args Then
			args = New TClassDecl[0]
		End If
		If Not decl
			If scope Return scope.FindClassDecl( ident,args )
			Return Null
		EndIf
		decl.AssertAccess
		decl.Semant
		Return decl.GenClassInstance( args )
	End Method
End Rem	
	Method FindModuleDecl:TModuleDecl( ident$ )
'DebugStop
		Local decl:TModuleDecl=TModuleDecl( GetDecl( ident ) )
		If Not decl
			If scope Return scope.FindModuleDecl( ident )
			Return Null
		EndIf
		decl.AssertAccess
		
		' only semant on "real" module
		If Not decl.declImported Then
			decl.Semant
		End If
		Return decl
	End Method
	
	Method FindBestMatchForArgs:TFuncDecl(argExprs:TExpr[], matches:TList)

		Local bestMatch:TFuncDecl = Null
		Local totals:Int[] = New Int[matches.count()]
		Local index:Int
		
		For Local func:TFuncDecl = EachIn matches

			Local argDecls:TArgDecl[]=func.argDecls
			
			For Local i:Int=0 Until argDecls.Length
	
				If i<argExprs.Length And argExprs[i]
				
					Local declTy:TType=argDecls[i].ty
					Local exprTy:TType=argExprs[i].exprType

					If TFunctionPtrType(declTy) And TInvokeExpr(argExprs[i]) Then
						If TFunctionPtrType(declTy).equalsDecl(TInvokeExpr(argExprs[i]).decl) Then
							Continue
						End If
					End If

					' not ideal - since the arg is configured as a Byte Ptr, we can't check that the function is of the correct type.
					If IsPointerType(declTy, TType.T_BYTE) And TInvokeExpr(argExprs[i]) And TInvokeExpr(argExprs[i]).invokedWithBraces = 0 Then
						Continue
					End If
					
					If TFunctionPtrType(declTy) And IsPointerType(exprTy, TType.T_BYTE) Then
						Continue
					End If
					
					If exprTy.EqualsType( declTy ) Continue
					
					' not an exact match. increase distance...
					totals[index] :+ exprTy.DistanceToType(declTy)
					
				End If
				
			Next
			
			index :+ 1

		Next
		
		Local tot:Int = -1
		index = 0
		Local i:Int
		For Local func:TFuncDecl = EachIn matches
			If tot = -1 Or totals[i] < tot Then
				tot = totals[i]
				bestMatch = func
			Else If tot = totals[i] Then
				If bestMatch.IsMethod() And Not func.IsMethod() Then
					' 
				Else If Not bestMatch.IsMethod() And func.IsMethod() Then
					bestMatch = func
				Else If (bestMatch.scope <> func.scope) And (TClassDecl(bestMatch.scope).ExtendsClass(TClassDecl(func.scope))) Then
					' match is in different level of class hierarchy
					Exit
				Else
					' a tie?
					Err "Unable to determine overload to use: "+ bestMatch.ToString()+" or "+func.ToString()+"."
				End If
			End If
			i :+ 1
		Next
		
		Return bestMatch
		
	End Method
	
	Method FindFuncDecl:TFuncDecl( ident$,argExprs:TExpr[] = Null,explicit:Int=False, isArg:Int = False, isIdentExpr:Int = False, throwOnNotMatched:Int = False, maxSearchDepth:Int )
'DebugLog "FindFuncDecl : " + ident
'If ident = "new" Then DebugStop
		Local foundIdentMatch:Int
		Local funcs:TFuncDeclList

		' does ident exist?
		Local f:Object = FindDeclList(ident, True,,maxSearchDepth)
		If Not f Then Return Null
		
		funcs = TFuncDeclList( f )
		Local fp:TFuncDecl
		
		' not a function list, test for a function ptr var
		If Not funcs Or funcs.IsEmpty() Then

			' we found a funcdecl
			If TFuncDecl(f) Then
				funcs = New TFuncDeclList
				funcs.AddLast(f)
			End If
			
			If TVarDecl(f) Then
				If Not TVarDecl(f).IsSemanted() Then
					TVarDecl(f).Semant()
				End If
				If TFunctionPtrType(TVarDecl(f).ty) Then
					funcs = New TFuncDeclList
					fp = TFunctionPtrType(TVarDecl(f).ty).func
					If Not fp.scope Then
						fp.scope = TVarDecl(f).scope
					End If
					If Not fp.ident Then
						fp.ident = TVarDecl(f).ident
					End If
					funcs.AddLast fp
				End If
			End If
		End If
		' was neither... lets bug out
		If Not funcs Return Null
		
'		If Not funcs Then Return Null
		
		For Local func:TDecl = EachIn funcs
			func.Semant()
		Next
		
		'Local f:TDecl = TDecl(findDecl(ident))
		'If Not f Then Return Null
		
				
			'Local func:TFuncDecl = TFuncDecl(f)
'			If Not func Then
'				If TVarDecl(f) Then
'					If Not f.IsSemanted() Then
'						f.Semant()
'					End If
'					If TFunctionPtrType(TVarDecl(f).ty) Then
'						func = TFunctionPtrType(TVarDecl(f).ty).func
'						If Not func.scope Then
'							func.scope = f.scope
'						End If
'						If Not func.ident Then
'							func.ident = f.ident
'						End If
'					End If
'				End If
'			End If
'			If Not func Return Null
	
		If Not argExprs
			argExprs = New TExpr[0]
		End If
	
		'func.Semant()
		
		Local match:TFuncDecl,isexact:Int
		Local _err$
		Local errorDetails:String
		Local matches:TList = New TList

		Local noExtendString:Int = True
		Local generateWarnings:Int = False

		' double test for matches.
		' * first time through we don't allow up-casting args to String
		'    if we get a match on the first pass, we'll take it.
		' * second iteration we allow up-casting numerics to string
		' * third iteration is valid if opt_warnover is enabled
		'    this will allow down-casting of numerics (eg. double->float)
		'    warnings will be generated if this produces valid results.
		' if after all that, there's no match, then we can fail it.
		For Local n:Int = 0 Until 3
		
			If n > 1 Then
				If Not opt_warnover Then
					Continue
				Else
					generateWarnings = True
				End If
			End If
		
			errorDetails = ""
		
			If n Then
				noExtendString = False
			End If

			For Local iDecl:TDecl = EachIn funcs
			
				Local func:TFuncDecl = TFuncDecl(iDecl)
				
				If Not func Then
					If TVarDecl(iDecl) Then
'						If Not TVarDecl(iDecl).IsSemanted() Then
'							TVarDecl(f).Semant()
'						End If
						If TFunctionPtrType(TVarDecl(iDecl).ty) Then
							'funcs = New TFuncDeclList
							fp = TFunctionPtrType(TVarDecl(iDecl).ty).func
							If Not fp.scope Then
								fp.scope = TVarDecl(iDecl).scope
							End If
							If Not fp.ident Then
								fp.ident = TVarDecl(iDecl).ident
							End If
							'funcs.AddLast fp
							func = fp
						End If
					End If
					
					If Not func Then
						Continue
					End If
				End If
				
	
			'While True
				If Not func.CheckAccess() Continue
				
				Local argDecls:TArgDecl[]=func.argDecls
				
				Local exact:Int=True
				Local possible:Int=True
				
				foundIdentMatch = True

				' we found a matching name - this is probably the one we mean...
				If isArg Then
					'match=func
					matches.AddLast(func)
					Exit
				End If

				If argExprs.Length>argDecls.Length
					exact = False
					Continue
				End If
										
				For Local i:Int=0 Until argDecls.Length
	
					If i<argExprs.Length And argExprs[i]
					
						Local arg:TExpr = argExprs[i]
					
						Local declTy:TType=argDecls[i].ty
						Local exprTy:TType=arg.exprType
						
						Local widensTest:Int = True
						
						' for numeric constants, allow them to be auto-cast unless
						If TConstExpr(arg) And IsNumericType(exprTy) And Not TConstExpr(arg).typeSpecific And TConstExpr(arg).CompatibleWithType(declTy) Then
							widensTest = False
						End If
	
						If TFunctionPtrType(declTy) And TInvokeExpr(arg) Then
							If TFunctionPtrType(declTy).equalsDecl(TInvokeExpr(arg).decl) Continue
						End If
	
						' not ideal - since the arg is configured as a Byte Ptr, we can't check that the function is of the correct type.
						If IsPointerType(declTy, TType.T_BYTE) And TInvokeExpr(arg) And TInvokeExpr(arg).invokedWithBraces = 0 Then
							Continue
						End If
						
						If TFunctionPtrType(declTy) And IsPointerType(exprTy, TType.T_BYTE) Then
							Continue
						End If
						
						If exprTy.EqualsType( declTy ) Continue
						
						exact=False
						
						If Not generateWarnings Then
							If Not explicit And exprTy.ExtendsType( declTy, noExtendString, widensTest ) Continue
						Else
							If Not explicit Then
								' fails widen test
								If Not exprTy.ExtendsType( declTy, noExtendString, True ) Then
									' but passes non-widen test
									If exprTy.ExtendsType( declTy, noExtendString, False ) Then
										' generate a warning, and accept it
										Warn "In call to " + func.ToString()+ ". Argument #"+(i+1)+" is ~q" + exprTy.ToString()+"~q but declaration is ~q"+declTy.ToString()+"~q. "
										Continue
									End If
								Else
									Continue
								End If
							End If
						End If
	
						' make a more helpful error message
						errorDetails :+ "Argument #"+(i+1)+" is ~q" + exprTy.ToString()+"~q but declaration is ~q"+declTy.ToString()+"~q. "

					Else If Not argDecls[i].init
	
						If (func.attrs & FUNC_PTR) Or isIdentExpr Then
							exact=False
							Exit
						End If
	
						' if this argument is missing and there isn't a default...
						errorDetails :+  "Missing function parameter '" + argDecls[i].ident + "'"
	
					Else ' for case of argdecls having default args
						exact=False
						If Not explicit Exit
					EndIf
				
					possible=False
					Exit
				Next
				
				If Not possible Continue
				
				If exact
					If isexact
						Err "Unable to determine overload to use: "+match.ToString()+" or "+func.ToString()+"."
					Else
						_err=""
						'match=func
						matches.AddLast(func)
						isexact=True
						Exit
					EndIf
				Else
					If Not isexact
						'If match 
						'	_err="Unable to determine overload to use: "+match.ToString()+" or "+func.ToString()+"."
						'Else
							'match=func
							matches.AddLast(func)
						'EndIf
					EndIf
				EndIf
				'Exit
			Next
			
			If Not matches.IsEmpty() Then
				Exit
			End If
			
		Next
		
		If matches.Count() = 1 Then
			match = TFuncDecl(matches.First())
		Else
			' find best match
			match = FindBestMatchForArgs(argExprs, matches)
		End If
		
		If Not isexact
			If _err Err _err
			If explicit Return Null
		EndIf

		' last try... maybe we are trying to use it as a function pointer? (no args)
		If Not match Then
			If argExprs Then
				'match = func
'				match.maybeFunctionPtr = True
			End If
		Else If Not argExprs Then
			' if there are no args, the actual function may have none either... so we may still be trying to use it as a function pointer
			match.maybeFunctionPtr = True
		End If
		
		If Not match
			Local t$
			For Local i:Int=0 Until argExprs.Length
				If t t:+","
				If argExprs[i] t:+argExprs[i].exprType.ToString()
			Next
			If foundIdentMatch Then
				If throwOnNotMatched Then
					Throw "Unable to find overload for "+ident+"("+t+"). " + errorDetails
				Else
					Err "Unable to find overload for "+ident+"("+t+"). " + errorDetails
				End If
			Else
				If throwOnNotMatched Then
					Throw "Identifier '" + ident + "' not found."
				Else
					Err "Identifier '" + ident + "' not found."
				End If
			End If
		EndIf
		
		match.AssertAccess

		Return match
	End Method

	Method FindLoop:TStmt(ident:String = Null)

		If TBlockDecl(Self) And TBlockDecl(Self).extra Then
			Local loop:TLoopStmt = TLoopStmt(TBlockDecl(Self).extra)
			If ident Then
				If loop.loopLabel And loop.loopLabel.IdentLower() = ident Then
					Return loop
				End If
			Else
				Return loop
			End If
		End If

		If TFuncDecl(scope) Or TModuleDecl(scope)
			Return Null
		End If
		
		If scope Return scope.FindLoop( ident )
	End Method
	
	Method OnSemant()
	End Method
	
End Type

Type TBlockDecl Extends TScopeDecl
	Field stmts:TList=New TList
	Field extra:Object
	
	Method Create:TBlockDecl( scope:TScopeDecl, generated:Int = False )
		Self.scope=scope
		Self.generated = generated
		
		attrs :| (scope.attrs & DECL_NODEBUG)
		
		Return Self
	End Method
	
	Method AddStmt( stmt:TStmt )
		stmts.AddLast stmt
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Local t:TBlockDecl=New TBlockDecl
		If deep Then
			For Local stmt:TStmt=EachIn stmts
				t.AddStmt stmt.Copy( t )
			Next
		End If
		t.extra = extra
		t.generated = generated
		Return t
	End Method

	Method OnSemant()
		PushEnv Self
		For Local stmt:TStmt=EachIn stmts
			stmt.Semant
		Next
		PopEnv
	End Method

	Method CopyBlock:TBlockDecl( scope:TScopeDecl )
		Local t:TBlockDecl=TBlockDecl( Copy() )
		t.scope=scope
		Return t
	End Method

End Type

Const FUNC_METHOD:Int=   $0001			'mutually exclusive with ctor
Const FUNC_CTOR:Int=     $0002
Const FUNC_PROPERTY:Int= $0004
Const FUNC_DTOR:Int=     $0008
Const FUNC_PTR:Int=      $0100
Const FUNC_BUILTIN:Int = $0080
Const FUNC_INIT:Int =    $0200
Const FUNC_NESTED:Int =  $0400
Const FUNC_OPERATOR:Int= $0800

'Fix! A func is NOT a block/scope!
'
Type TFuncDecl Extends TBlockDecl

	Field retType:TType
	Field retTypeExpr:TType
	Field argDecls:TArgDecl[]

	Field overrides:TFuncDecl
	Field superCtor:TInvokeSuperExpr
	
	Field castTo:String
	Field noCastGen:Int
	
	Field maybeFunctionPtr:Int
	
	Field returnTypeSubclassed:Int
	
	Field mangled:String
	Field noMangle:Int
	
	Field equalsBuiltIn:Int = -1
	
	Method CreateF:TFuncDecl( ident$,ty:TType,argDecls:TArgDecl[],attrs:Int )
		Self.ident=ident
		Self.retTypeExpr=ty
		If argDecls
			Self.argDecls=argDecls
		Else
			Self.argDecls = New TArgDecl[0]
		End If
		Self.attrs=attrs
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Local args:TArgDecl[]=argDecls[..]
		For Local i:Int=0 Until args.Length
			args[i]=TArgDecl( args[i].Copy() )
		Next
		Local t:TFuncDecl=New TFuncDecl.CreateF( ident,retType,args,attrs )
		If deep Then
			For Local stmt:TStmt=EachIn stmts
				t.AddStmt stmt.Copy( t )
			Next
		End If
		t.retType = retType
		t.scope = scope
		t.overrides = overrides
		t.superCtor = superCtor
		t.castTo = castTo
		t.noCastGen = noCastGen
		t.munged = munged
		t.metadata = metadata
		t.mangled = mangled
		t.noMangle = noMangle
		Return  t
	End Method

	Method GenInstance:TDecl()
		Local inst:TFuncDecl=New TFuncDecl
		InitInstance inst
		inst.retTypeExpr=retTypeExpr
		inst.argDecls=argDecls[..]
		For Local i:Int=0 Until argDecls.Length
			inst.argDecls[i]=TArgDecl( argDecls[i].GenInstance() )
		Next
		Return inst
	End Method
	
	Method ToString$()
		Local t$
		For Local decl:TArgDecl=EachIn argDecls
			If t t:+","
			t:+decl.ToString()
		Next
		Local q$
		If IsCtor()
			q="Method "+Super.ToString()
		Else
			If IsMethod() q="Method " Else q="Function "
			q:+Super.ToString()
			If retType
				If Not TVoidType(retType) Then
					q:+":"+retType.ToString()
				End If
			Else If retTypeExpr 
				q:+":"+retTypeExpr.ToString()
			'Else
			'	q:+":"+"?"
			EndIf
		EndIf
		Return q+"("+t+")"
	End Method

	Method ToTypeString:String()
		Local t$
		For Local decl:TArgDecl=EachIn argDecls
			If t t:+","
			t:+decl.ToTypeString()
		Next
		Local q$
		If Not IsCtor() Then
			If retType
				If Not TVoidType(retType) Then
					q:+retType.ToString()
				End If
			Else If retTypeExpr 
				q:+retTypeExpr.ToString()
			EndIf
		End If
		Return q+"("+t+")"
	End Method

	Method IsBuiltIn:Int()
		Return (attrs & FUNC_BUILTIN)<>0
	End Method
	
	Method IsCtor:Int()
		Return (attrs & FUNC_CTOR)<>0
	End Method

	Method IsDtor:Int()
		Return (attrs & FUNC_DTOR)<>0
	End Method

	Method IsMethod:Int()
		Return (attrs & FUNC_METHOD)<>0
	End Method
	
	Method IsAnyMethod:Int()
		Return IsMethod() Or IsCtor() Or IsDtor() 
	End Method
	
	Method IsStatic:Int()
		Return (attrs & (FUNC_METHOD|FUNC_CTOR))=0
	End Method
	
	Method IsProperty:Int()
		Return (attrs & FUNC_PROPERTY)<>0
	End Method
	
	Method EqualsArgs:Int( decl:TFuncDecl )
		If argDecls.Length<>decl.argDecls.Length Return False
		For Local i:Int=0 Until argDecls.Length
			If Not argDecls[i].ty.EqualsType( decl.argDecls[i].ty ) Return False
		Next
		Return True
	End Method

	Method EqualsFunc:Int( decl:TFuncDecl )
		If IsCtor() Then
			Return EqualsArgs( decl )
		Else
			Return (retType.EqualsType( decl.retType ) Or retType.ExtendsType( decl.retType ) Or decl.retType.EqualsType( retType )) And EqualsArgs( decl )
		End If
	End Method

	Method OnSemant()

		Local strictVoidToInt:Int = False
		
		'semant ret type
		If Not retTypeExpr Then
			If Not retType Then ' may have previously been set (if this is a function pointer)
				retType = TType.voidType
			Else If TIdentType(retType)
				retType = retType.Semant()
			Else
				' for Strict code, a void return type becomes Int
				If TVoidType(retType) And Not ModuleScope().IsSuperStrict() Then
					strictVoidToInt = True
					retType = New TIntType
				End If
			End If
		Else
			' pass the scope into the function ptr
			If TFunctionPtrType(retTypeExpr) Then
				If Not TFunctionPtrType(retTypeExpr).func.scope Then
					If scope Then
						TFunctionPtrType(retTypeExpr).func.scope = scope
					Else
						TFunctionPtrType(retTypeExpr).func.scope = _env
					End If
				End If
			End If
		
			retType=retTypeExpr.Semant()
			
			' for Strict code, a void return type becomes Int
			If TVoidType(retType) And Not ModuleScope().IsSuperStrict() And Not IsDTor() Then
				strictVoidToInt = True
				retType = New TIntType
			End If
		End If
		
		If TArrayType( retType ) And Not retType.EqualsType( retType.ActualType() )
'			Err "Return type cannot be an array of generic objects."
		EndIf
		
		'semant args
		For Local arg:TArgDecl=EachIn argDecls
			InsertDecl arg
			arg.Semant
		Next

		' if we are a function pointer declaration, we just want to semant the args here.
		If attrs & FUNC_PTR Return

		If actual<>Self Return
		
		'check for duplicate decl
		If ident Then
			For Local decl:TFuncDecl=EachIn scope.SemantedFuncs( ident )
				If decl<>Self And EqualsArgs( decl )
					Err "Duplicate declaration "+ToString()
				EndIf
				If noMangle Then
					If decl<>Self Then
						If decl.argDecls.Length = 0 Then
							Err "You cannot apply NoMangle to the function, as another function with no arguments exists."
						Else If decl.NoMangle Then
							Err "Another function is already declared with NoMangle."
						End If
					End If
				End If
			Next
		End If
		
		' any nested functions?
		For Local fdecl:TFuncDecl = EachIn _decls
			fdecl.Semant
		Next
		
		'get cdecl, sclasss
		Local cdecl:TClassDecl=ClassScope(),sclass:TClassDecl
		If cdecl sclass=TClassDecl( cdecl.superClass )
		
		'prefix call to super ctor if necessary
'		If IsCtor() And superCtor=Null And sclass
'			If sclass.FindFuncDecl( "new", Null )
'				superCtor=New TInvokeSuperExpr.Create( "new" )
'				stmts.AddFirst New TExprStmt.Create( superCtor )
'			EndIf
'		EndIf
		
		'check we exactly match an override
		If sclass 'And IsMethod()

			While sclass
				Local errorDetails:String = ""

				Local found:Int
				For Local decl:TFuncDecl=EachIn sclass.FuncDecls( )
					
					If decl.IdentLower() = IdentLower() Then

						If IdentLower() = "new" Continue
						If IdentLower() = "delete" Continue

						found=True

						If Not decl.IsSemanted() Then
							decl.Semant
						End If

						' check void return type strictness, and fail if appropriate.
						Local voidReturnTypeFail:Int = False
						' super has void return type... so it is superstrict (or inherited from)
						If TVoidType(decl.retType) And TIntType(retType) Then
							' if we are only strict, we may fail on type mismatch
							If Not ModuleScope().IsSuperStrict() Then
								' we have the option of upgrading our return type to match superstrict parent
								If opt_strictupgrade And strictVoidToInt Then
									retType = TType.voidType
								Else
									' otherwise...
									voidReturnTypeFail = True
								End If
							End If
						End If

						If EqualsFunc( decl ) And Not voidReturnTypeFail

							' check we aren't attempting to assign weaker access modifiers
							If (IsProtected() And decl.IsPublic()) Or (IsPrivate() And (decl.IsProtected() Or decl.IsPublic())) Then
							
								Local p:String
								If IsProtected() Then
									p = "Protected"
								Else
									p = "Private"
								End If
								
								Local dp:String
								If decl.IsPublic() Then
									dp = "Public"
								Else
									dp = "Protected"
								End If
							
								Err ToString() + " clashes with " + decl.ToString() + ". Attempt to assign weaker access privileges ('" + p + "'), was '" + dp + "'."
							
							End If
						

							If Not retType.EqualsType( decl.retType ) And retType.ExtendsType( decl.retType ) Then
								returnTypeSubclassed = True
							End If
							
							overrides=TFuncDecl( decl.actual )
						Else
							'prepare a more detailed error message
							If (Not retType.EqualsType( decl.retType ) Or Not retType.ExtendsType( decl.retType )) Or (decl.retType And Not decl.retType.EqualsType( retType )) Or voidReturnTypeFail
								errorDetails :+ "Return type is ~q"+retType.ToString()+"~q, expected ~q"+decl.retType.ToString()+"~q. "
								If voidReturnTypeFail Then
									errorDetails :+ "You may have Strict type overriding SuperStrict type. "
								End If
							Else
								found = False
								Continue
							End If
' TODO REMOVE
' the following doesn't apply when supporting overloading, as we can have methods of the same name with different args length/types
							If argDecls.Length <> decl.argDecls.Length
								errorDetails :+ "Argument count differs. Got " + argDecls.Length +", expected " + decl.argDecls.Length + " arguments."
							End If
							Local argCount:Int = Min(argDecls.Length, decl.argDecls.Length)
							If argCount > 0
								For Local i:Int=0 Until argCount
									If Not argDecls[i].ty.EqualsType( decl.argDecls[i].ty )
										errorDetails :+ "Argument #"+(i+1)+" is ~q" + argDecls[i].ty.ToString()+"~q, expected ~q"+decl.argDecls[i].ty.ToString()+"~q. "
									End If
								Next
							EndIf
							'remove last space
							errorDetails = errorDetails.Trim()
						EndIf
					End If
				Next
				If found
					If Not overrides Err "Overriding method does not match any overridden method. (Detail: " + errorDetails+")"
					' for overrides, make the ident match that of the superclass
					ident = overrides.ident
					
					Exit
				EndIf
				sclass=sclass.superClass
			Wend
		EndIf

		'append a return statement if necessary
		If Not IsExtern() And Not TVoidType( retType ) And Not TReturnStmt( stmts.Last() )
			If Not isCtor() And Not isDtor()
				Local stmt:TReturnStmt

				stmt=New TReturnStmt.Create( New TConstExpr.Create( retType,"" ) )
				stmt.generated = True

				stmt.errInfo=errInfo
				stmts.AddLast stmt
			End If
		EndIf

		attrs:|DECL_SEMANTED
		
		Super.OnSemant()
	End Method

	Method CheckAccess:Int()
		Local cd:TClassDecl = ClassScope()
		If cd Then
			If IsPrivate() And cd<>_env.ClassScope() Return False
			If IsProtected() Then
				Local ec:TClassDecl = _env.ClassScope()
				If Not ec Return False
				If Not ec.ExtendsClass(cd) Return False
			End If
			Return True
		End If
		Return Super.CheckAccess()
	End Method

End Type

Type TNewDecl Extends TFuncDecl

	Field chainedCtor:TNewExpr
	
	

End Type


'Const CLASS_INTERFACE:Int=1
'Const CLASS_TEMPLATEARG:Int=2
'Const CLASS_TEMPLATEINST:Int=4
'Const CLASS_INSTANCED:Int=8		'class used in New?
Const CLASS_INSTANCED:Int=1
Const CLASS_EXTENDSOBJECT:Int=2
Const CLASS_FINALIZED:Int=4

Type TNullDecl Extends TClassDecl

End Type

Type TClassDecl Extends TScopeDecl

	Field lastOffset:Int

	Field args:String[]
	Field superTy:TIdentType
	Field impltys:TIdentType[]

	Field superClass:TClassDecl
	
	Field implments:TClassDecl[]			'interfaces immediately implemented
	Field implmentsAll:TClassDecl[]		'all interfaces implemented
	
	Field instanceof:TClassDecl			'for instances
	Field instances:TList		'for actual (non-arg, non-instance)
	Field instArgs:TType[]

	Field objectType:TObjectType '"canned" objectType
	Field globInit:Int

	'Global nullObjectClass:TClassDecl=New TNullDecl.Create( "{NULL}",Null,Null,Null,DECL_ABSTRACT|DECL_EXTERN )
	
	Method Create:TClassDecl( ident$,args:String[],superTy:TIdentType,impls:TIdentType[],attrs:Int )
		Self.ident=ident
		Self.args=args
		Self.superTy=superTy
		Self.impltys=impls
		Self.attrs=attrs
		Self.objectType=New TObjectType.Create( Self )
		If args
			instances=New TList
			instances.AddLast Self
		EndIf
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		InternalErr
	End Method
	
	Method ToString$()
		Local t$
		If args Then
				For Local i:Int=0 Until args.Length
				If i t:+","
				t:+args[i].ToString()
			Next
		ElseIf instargs
		End If
		If t t="<"+t+">"
		Return ident+t
	End Method

	Method ToTypeString:String()
		Return ident
	End Method
Rem
	Method GenClassInstance:TClassDecl( instArgs:TClassDecl[] )
		If Not IsSemanted() InternalErr
		
		'no args
		If Not instArgs
			If Not args Return Self
			If instanceof Return Self
			For Local inst:TClassDecl=EachIn instances
				If _env.ClassScope()=inst Return inst
			Next
		EndIf
		
		'If Not instanceof And Not instArgs Return Self
		
		'check number of args
		If instanceof Or args.Length<>instArgs.Length
			Err "Wrong number of class arguments for "+ToString()
		EndIf
		
		'look for existing instance
		For Local inst:TClassDecl=EachIn instances
			Local equal:Int=True
			For Local i:Int=0 Until args.Length
				If inst.args[i]=instArgs[i] Continue
				equal=False
				Exit
			Next
			If equal Return inst
		Next
		
		Local inst:TClassDecl=New TClassDecl

		InitInstance inst

		inst.scope=scope
		inst.attrs:|CLASS_TEMPLATEINST
		inst.args=instArgs
		inst.superTy=superTy
		inst.instanceof=Self
		instances.AddLast inst
		
		For Local i:Int=0 Until args.Length
			inst.InsertDecl New TAliasDecl.Create( args[i].ident,instArgs[i] )
		Next
		
		For Local decl:TDecl=EachIn _decls
			If TClassDecl( decl ) Continue
			inst.InsertDecl decl.GenInstance()
		Next

		'inst.Semant
		'A bit cheeky...
		inst.OnSemant
		inst.attrs:|DECL_SEMANTED
		
		Return inst
	End Method
End Rem
	Method GenClassInstance:TClassDecl( instArgs:TType[] )

		If instanceof InternalErr
		
		'no args
		If Not instArgs
			If Not args Return Self
			For Local inst:TClassDecl=EachIn instances
				If _env.ClassScope()=inst Return inst
			Next
		EndIf
		
		'check number of args
		If args.Length<>instArgs.Length
			Err "Wrong number of type arguments for class "+ToString()
		EndIf
		
		'look for existing instance
		For Local inst:TClassDecl=EachIn instances
			Local equal:Int=True
			For Local i:Int=0 Until args.Length
				If Not inst.instArgs[i].EqualsType( instArgs[i] )
					equal=False
					Exit
				EndIf
			Next
			If equal Return inst
		Next
		
		Local inst:TClassDecl=New TClassDecl.Create( ident,Null,superTy,impltys, attrs )

		inst.attrs:&~DECL_SEMANTED
		inst.munged=munged
		inst.errInfo=errInfo
		inst.scope=scope
		inst.instanceof=Self
		inst.instArgs=instArgs
		instances.AddLast inst
		
		For Local i:Int=0 Until args.Length
			inst.InsertDecl New TAliasDecl.Create( args[i].ToString(),instArgs[i],0 )
		Next
		
		For Local decl:TDecl=EachIn _decls
			inst.InsertDecl decl.Copy()
		Next

		Return inst
	End Method

	Method IsInterface:Int()
		Return (attrs & CLASS_INTERFACE)<>0
	End Method

	Method IsFinal:Int()
		Return (attrs & DECL_FINAL)<>0
	End Method

	Method IsThrowable:Int()
		Return (attrs & CLASS_THROWABLE)<>0
	End Method

	Method IsFinalized:Int()
		Return (attrs & CLASS_FINALIZED)<>0
	End Method
	
	Method IsStruct:Int()
		Return (attrs & CLASS_STRUCT)<>0
	End Method

	Method ExtendsObject:Int()
		Return (attrs & CLASS_EXTENDSOBJECT)<>0
	End Method
	
	Method IsInstanced:Int()
		Return (attrs & CLASS_INSTANCED)<>0
	End Method
	
	Method GetDecl:Object( ident$ )
	
		Local cdecl:TClassDecl=Self
		While cdecl
			Local decl:Object=cdecl.GetDecl2( ident )
			If decl Return decl
			
			cdecl=cdecl.superClass
		Wend

	End Method
	
	'needs this 'coz you can't go blah.Super.GetDecl()...
	Method GetDecl2:Object( ident$ )
		Return Super.GetDecl( ident )
	End Method

	Method GetDeclList:Object( ident$, declList:TFuncDeclList = Null, maxSearchDepth:Int )
	
		If Not declList Then
			declList = New TFuncDeclList
		End If
	
		Local cdecl:TClassDecl=Self
		While cdecl
			Local decl:Object=cdecl.GetDeclList2( ident, declList, maxSearchDepth )
			'If decl And (Not TFuncDeclList(decl) And declList.IsEmpty()) Return decl
			If decl Then
				declList.AddLast(decl)
			End If

			cdecl=cdecl.superClass
			
			If maxSearchDepth < SCOPE_CLASS_HEIRARCHY Then
				Exit
			End If
		Wend

		Return declList
	End Method
	
	'needs this 'coz you can't go blah.Super.GetDecl()...
	Method GetDeclList2:Object( ident$, declList:TFuncDeclList = Null, maxSearchDepth:Int )
		Return Super.GetDeclList( ident, declList, maxSearchDepth )
	End Method
	
	Method FindFuncDecl:TFuncDecl( ident$,args:TExpr[] = Null ,explicit:Int=False, isArg:Int = False, isIdentExpr:Int = False, throwOnNotMatched:Int = False, maxSearchDepth:Int )
	
		' try the super first...
		Local funcDecl:TFuncDecl = Super.FindFuncDecl(ident, args, explicit, isArg, isIdentExpr, throwOnNotMatched, maxSearchDepth)
		If funcDecl Then
			Return funcDecl
		End If
	
	
		If args = Null Then
			args = New TExpr[0]
		End If
	
		If Not IsInterface()
			' try getdecl first&
			Local decl:TFuncDecl = TFuncDecl(GetDecl(ident))
			If decl Then
				Return decl
			End If
			Return FindFuncDecl2( ident,args,explicit,isIdentExpr )
		EndIf
		
		Local fdecl:TFuncDecl=FindFuncDecl2( ident,args,True )
		
		For Local iface:TClassDecl=EachIn implmentsAll
			Local decl:TFuncDecl=iface.FindFuncDecl2( ident,args,True )
			If Not decl Continue
			
			If fdecl
				If fdecl.EqualsFunc( decl ) Continue
				Err "Unable to determine overload to use: "+fdecl.ToString()+" or "+decl.ToString()+"."
			EndIf
			fdecl=decl
		Next
		
		If fdecl Or explicit Return fdecl
		
		fdecl=FindFuncDecl2( ident,args,False )
		
		For Local iface:TClassDecl=EachIn implmentsAll
			Local decl:TFuncDecl=iface.FindFuncDecl2( ident,args,False )
			If Not decl Continue
			
			If fdecl
				If fdecl.EqualsFunc( decl ) Continue
				Err "Unable to determine overload to use: "+fdecl.ToString()+" or "+decl.ToString()+"."
			EndIf
			fdecl=decl
		Next
		
		Return fdecl
	End Method
	
	Method FindFuncDecl2:TFuncDecl( ident$,args:TExpr[],explicit:Int, isIdentExpr:Int = False )
		Return Super.FindFuncDecl( ident,args,explicit,,isIdentExpr,0,0 )
	End Method
	
	Method GetAllFuncDecls:TFuncDecl[](funcs:TFuncDecl[] = Null, includeSuper:Int = True)
		If Not funcs Then
			funcs = New TFuncDecl[0]
		End If
		
		If superClass And includeSuper Then
			funcs = superClass.GetAllFuncDecls(funcs)
		End If

		' interface methods
		For Local iface:TClassDecl=EachIn implmentsAll
			funcs = iface.GetAllFuncDecls(funcs)
		Next
		
		For Local func:TFuncDecl = EachIn _decls
		
			Local matched:Int = False
			
			For Local i:Int = 0 Until funcs.length
				' found a match - we are overriding it
				If func.IdentLower() = funcs[i].IdentLower() And func.EqualsArgs(funcs[i]) Then
					matched = True
					' set this to our own func
					funcs[i] = func
					Exit
				End If
			Next
			
			If Not matched Then
				funcs :+ [func]
			End If
		
		Next
		
		Return funcs
	End Method

	' returns a list of original function decls (i.e. decls in the scope of their original declarations).
	' this is useful for generating vtables for extern types
	Method GetAllOriginalFuncDecls:TFuncDecl[](funcs:TFuncDecl[] = Null, includeSuper:Int = True)
		If Not funcs Then
			funcs = New TFuncDecl[0]
		End If
		
		If superClass And includeSuper Then
			funcs = superClass.GetAllOriginalFuncDecls(funcs, True)
		End If

		' interface methods
		For Local iface:TClassDecl=EachIn implmentsAll
			For Local func:TFuncDecl=EachIn iface._decls
				Local matched:Int = False

'				For Local i:Int = 0 Until funcs.length
'					' found a match - we are overriding it
'					If func.IdentLower() = funcs[i].IdentLower() Then
'						matched = True
'						Exit
'					End If
'				Next
				
				If Not matched Then
					funcs :+ [func]
				End If
			Next
		Next

		
		For Local func:TFuncDecl = EachIn _decls
		
			Local matched:Int = False
			
			' dont count any that are already in the funcs list
			For Local i:Int = 0 Until funcs.length
				' found a match - we are overriding it
				If func.IdentLower() = funcs[i].IdentLower() And func.EqualsArgs(funcs[i]) Then
					matched = True
					' set this to our own func
					'funcs[i] = func
					Exit
				End If
			Next
			
			If Not matched Then
				funcs :+ [func]
			End If
		
		Next
		
		Return funcs
	End Method
	
	Method ExtendsClass:Int( cdecl:TClassDecl )
		'If Self=nullObjectClass Return True
		
'		If cdecl.IsTemplateArg()
'			cdecl=TType.objectType.FindClass()
'		EndIf
		
		Local tdecl_:TClassDecl=Self
		While tdecl_
			If tdecl_=cdecl Return True
			If cdecl.IsInterface()
				For Local iface:TClassDecl=EachIn tdecl_.implmentsAll
					If iface=cdecl Return True
				Next
			EndIf
			tdecl_=tdecl_.superClass
		Wend
		
		Return False
	End Method
	
	Method OnSemant()

		PushEnv Self

		'If Not IsTemplateInst()
		'	For Local i:Int=0 Until args.Length
		'		InsertDecl args[i]
		'		args[i].Semant
		'	Next
		'EndIf

		'Semant superclass		
		If superTy
			'superClass=superTy.FindClass()
			superClass=superTy.SemantClass()
			If superClass.IsInterface() Then
				If Not IsExtern() Or Not superClass.IsExtern() Err superClass.ToString()+" is an interface, not a class."
				If (IsExtern() And Not superClass.IsExtern()) Or (superClass.IsExtern() And Not IsExtern()) Err "Extern and non extern types cannot be mixed."
			End If
			If superClass.IsFinal() Err "Final types cannot be extended."
		EndIf
		
		'Semant implemented interfaces
		Local impls:TClassDecl[]=New TClassDecl[impltys.Length]
		Local implsall:TStack=New TStack
		For Local i:Int=0 Until impltys.Length
			Local cdecl:TClassDecl=impltys[i].SemantClass()
			If Not cdecl.IsInterface()
				Err cdecl.ToString()+" is a type, not an interface."
			EndIf
			For Local j:Int=0 Until i
				If impls[j]=cdecl
					Err "Duplicate interface "+cdecl.ToString()+"."
				EndIf
			Next
			impls[i]=cdecl
			implsall.Push cdecl
			For Local tdecl_:TDecl=EachIn cdecl.implmentsAll
				implsall.Push tdecl_
			Next
		Next
		Local length:Int = implsall.Length()
		implmentsAll=New TClassDecl[length]
		For Local i:Int=0 Until length
			implmentsAll[i]=TClassDecl(implsall.Get(length - i - 1))
		Next
		implments=impls

		Rem
		If IsInterface()
			'add implemented methods to our methods
			For Local iface:=EachIn implmentsAll
				For Local decl:=EachIn iface.FuncDecls
					InsertAlias decl.ident,decl
				Next
			Next
		EndIf
		EndRem
				
'		attrs|=DECL_SEMANTED
		
		PopEnv
		
		'If IsTemplateArg()
		'	actual=TType.objectType.FindClass()
		'	Return
		'EndIf
		
		'If IsTemplateInst()
		'	Return
		'EndIf
		
		'Are we abstract?
		If Not IsAbstract()
			For Local decl:TDecl=EachIn _decls
				Local fdecl:TFuncDecl=TFuncDecl( decl )
				If fdecl And fdecl.IsAbstract()
					attrs:|DECL_ABSTRACT
					Exit
				EndIf
			Next
		EndIf
		
		If Not lastOffset And superClass Then
			lastOffset = superClass.LastOffset
		End If

		For Local decl:TFieldDecl=EachIn _decls
			GetFieldOffset(decl)
		Next

		If Not IsExtern() And Not IsInterface()
			Local fdecl:TFuncDecl
			For Local decl:TFuncDecl=EachIn FuncDecls()
				If Not decl.IsCtor() Continue
				Local nargs:Int
				For Local arg:TArgDecl=EachIn decl.argDecls
					If Not arg.init nargs:+1
				Next
				If nargs Continue
				fdecl=decl
				Exit
			Next
			
			
			' Don't need default new?
			'If Not fdecl
			'	fdecl=New TFuncDecl.CreateF( "new",New TObjectType.Create( Self ),Null,FUNC_CTOR )
			'	fdecl.AddStmt New TReturnStmt.Create( Null )
			'	InsertDecl fdecl
			'EndIf
		EndIf

		'NOTE: do this AFTER super semant so UpdateAttrs order is cool.
		If AppScope() Then
			AppScope().semantedClasses.AddLast Self
		End If
	End Method
	
	Method SemantParts()
'		If IsSemanted() Return
		
'		Super.Semant()
		
		For Local decl:TConstDecl = EachIn Decls()
			decl.Semant()
		Next

		For Local decl:TGlobalDecl = EachIn Decls()
			decl.Semant()
		Next

		' NOTE : we can't semant functions here as they cause cyclic errors.
		For Local decl:TFuncDecl = EachIn Decls()
			decl.Semant()
		Next

		For Local decl:TFieldDecl = EachIn Decls()
			decl.Semant()
		Next

	End Method
	
	'Ok, this dodgy looking beast 'resurrects' methods that may not currently be alive, but override methods that ARE.
	Method UpdateLiveMethods:Int()
	
		If IsInterface() Return 0

		If Not superClass Return 0

		Local n:Int
		For Local decl:TFuncDecl=EachIn MethodDecls()
			If decl.IsSemanted() Continue
			
			Local live:Int
			Local unsem:TList=New TList'<TFuncDecl>
			
			unsem.AddLast decl
			
			Local sclass:TClassDecl=superClass
			While sclass
				For Local decl2:TFuncDecl=EachIn sclass.MethodDecls( decl.ident )
					If decl2.IsSemanted()
						live=True
					Else
						unsem.AddLast decl2
						If decl2.IsExtern() live=True
						If decl2.actual.IsSemanted() live=True
					EndIf
				Next
				sclass=sclass.superClass
			Wend
			
			If Not live
				Local cdecl:TClassDecl=Self
				While cdecl
					For Local iface:TClassDecl=EachIn cdecl.implmentsAll
						For Local decl2:TFuncDecl=EachIn iface.MethodDecls( decl.ident )
							If decl2.IsSemanted()
								live=True
							Else
								unsem.AddLast decl2
								If decl2.IsExtern() live=True
								If decl2.actual.IsSemanted() live=True
							EndIf
						Next
					Next
					cdecl=cdecl.superClass
				Wend
			EndIf
			
			If Not live Continue
			
			For Local decl:TDecl=EachIn unsem
				decl.Semant
				n:+1
			Next
		Next
		
		Return n
	End Method
	
	Method FinalizeClass()
	
		SemantParts()

		PushErr errInfo
		
		If Not IsInterface()
			'
			'check for duplicate fields! - BlitzMax supports fields with the same name in subclasses..
			'
			'For Local decl:TDecl=EachIn Semanted()
			'	Local fdecl:TFieldDecl=TFieldDecl( decl )
			'	If Not fdecl Continue
			'	Local cdecl:TClassDecl=superClass
			'	While cdecl
			'		For Local decl:TDecl=EachIn cdecl.Semanted()
			'			If decl.ident=fdecl.ident Err "Field '"+fdecl.ident+"' in class "+ToString()+" overrides existing declaration in class "+cdecl.ToString()
			'		Next
			'		cdecl=cdecl.superClass
			'	Wend
			'Next
			'
			'Check we implement all abstract methods!
			'
			If IsInstanced()
				Local cdecl:TClassDecl=Self
				Local impls:TList=New TList'<TFuncDecl>
				While cdecl
					For Local decl:TFuncDecl=EachIn cdecl.SemantedMethods()
						If decl.IsAbstract()
							Local found:Int
							For Local decl2:TFuncDecl=EachIn impls
								If decl.IdentLower() = decl2.IdentLower() And decl2.EqualsFunc( decl )
									found=True
									Exit
								EndIf
							Next
							If Not found
								Err "Can't create instance of type "+ToString()+" due to abstract method "+decl.ToString()+"."
							EndIf
						Else
							impls.AddLast decl
						EndIf
					Next
					cdecl=cdecl.superClass
				Wend
			EndIf
			'
			'Check we implement all interface methods!
			'
			If Not IsAbstract() Then

				Local ints:TMap = GetInterfaces()

				For Local iface:TClassDecl=EachIn ints.Values()
				
					If (Not IsExtern() And iface.IsExtern()) Or (IsExtern() And Not iface.IsExtern()) Then
						Err "Cannot mix Extern and non Extern Types and Interfaces."
					End If
				
					For Local decl:TFuncDecl=EachIn iface.SemantedMethods()
						Local found:Int

						Local cdecl:TClassDecl=Self
						
						While cdecl And Not found
							For Local decl2:TFuncDecl=EachIn cdecl.SemantedMethods( decl.ident )
								If decl.EqualsFunc( decl2 )
									found=True
									Exit
								EndIf
							Next
						
							cdecl = cdecl.superClass
						Wend

						If Not found
							Err decl.ToString() + " must be implemented by type " + ToString()
						EndIf
					Next
				Next
			End If
		EndIf
		
		PopErr
		
	End Method
	
	Method GetFieldOffset(decl:TFieldDecl)
		
		Local ty:TType = decl.declTy
		
		Local modifier:Int = POINTER_SIZE
		
		If TIntType(ty) Or TFloatType(ty) Or TUIntType(ty) Then
			modifier = 4
		Else If TShortType(ty) Then
			modifier = 2
		Else If TLongType(ty) Or TDoubleType(ty) Or TULongType(ty) Then
			modifier = 8
		Else If TByteType(ty) Then
			modifier = 1
		Else If TSizeTType(ty) Then
			modifier = WORD_SIZE
		End If

		If modifier > 1 And lastOffset Mod modifier Then
			lastOffset :+ modifier - (lastOffset Mod modifier)
		End If
		
		decl.offset = lastOffset
		
		lastOffset :+ modifier
	End Method
	
	' returns a map of all interfaces implemented in this hierarchy
	Method GetInterfaces:TMap(map:TMap = Null)
		If Not map Then
			map = New TMap
		End If

		For Local iface:TClassDecl=EachIn implmentsAll
		
			If iface.IsInterface() Then
			
				Local cdecl:TClassDecl = iface
				While cdecl
				
					If cdecl.IsInterface() Then
						If Not map.Contains(cdecl) Then
							map.Insert(cdecl, cdecl)
						End If
					End If


					cdecl=cdecl.superClass
				Wend
			
			End If
		Next

		
		If superClass Then
			map = superClass.GetInterfaces(map)
		End If
		
		Return map
	End Method
	
	Method GetImplementedFuncs:TList(list:TList = Null)
		If Not list Then
			list = New TList
		End If
		
		For Local idecl:TClassDecl = EachIn implmentsAll
			idecl.GetImplementedFuncs(list)
		Next
		
		For Local decl:TFuncDecl = EachIn SemantedMethods()
			list.AddLast(decl)
		Next

		Return list
	End Method
	
End Type

Type TLoopLabelDecl Extends TDecl

	Field realIdent:String

	Method Create:TLoopLabelDecl( ident$, attrs:Int=0 )
		Self.ident="#" + ident
		Self.realIdent = ident
		Self.attrs=attrs
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Return New TLoopLabelDecl.Create( realIdent,attrs )
	End Method
	
	Method OnSemant()
	End Method
	
End Type

Type TDataLabelDecl Extends TDecl

	Field realIdent:String
	Field index:Int

	Method Create:TDataLabelDecl( ident$, attrs:Int=0 )
		Self.ident="#" + ident
		Self.realIdent = ident
		Self.attrs=attrs
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Return New TDataLabelDecl.Create( realIdent,attrs )
	End Method
	
	Method OnSemant()
	End Method
	
End Type

Type TDefDataDecl Extends TDecl

	Global count:Int

	Field label:TDataLabelDecl
	Field data:TExpr[]

	Method Create:TDefDataDecl(data:TExpr[], label:TDataLabelDecl = Null, attrs:Int=0 )
		Self.data=data
		Self.label=label
		Self.attrs=attrs
		Return Self
	End Method
	
	Method OnCopy:TDecl(deep:Int = True)
		Return New TDefDataDecl.Create(TExpr.CopyArgs(data),TDataLabelDecl(label.Copy()),attrs)
	End Method

	Method OnSemant()
		If data Then
			If label Then
				label.index = count
			End If
		
			For Local i:Int = 0 Until data.length
				data[i] = data[i].Semant()
				If Not TConstExpr(data[i]) Then
					Err "Data items must be numeric or strings"
				Else
					' todo : more type tests?
				End If
				count :+ 1
			Next
		Else
			' err?
		End If
	End Method
	
End Type

Const MODULE_STRICT:Int=1
Const MODULE_SUPERSTRICT:Int=2
Const MODULE_ACTUALMOD:Int=4

Type TNamespaceDecl Extends TScopeDecl

'	Field mods:TMap = New TMap

	Method Create:TNamespaceDecl( ident$,munged$ )
		Self.ident=ident
		Self.munged=munged
		Return Self
	End Method

'	Method GetDecl:Object( ident$ )
'		Return mods.ValueForKey(ident.ToLower())
'	End Method
	
End Type

Type TModuleDecl Extends TScopeDecl

	Field filepath$
	Field relpath$
	Field imported:TUnorderedMap=New TUnorderedMap'<TModuleDecl>		'Maps filepath to modules
	Field pubImported:TUnorderedMap =New TUnorderedMap'<TModuleDecl>	'Ditto for publicly imported modules

	Field pmod:TModuleDecl

	Field fileImports:TList=New TList'StringList
	
	' cache of ModuleInfo lines
	Field modInfo:TList = New TList

	Field _getDeclTreeCache:TList
	
	Field _getDeclCache:TMap = New TMap
	Field _getDeclListCache:TMap = New TMap

	Method ToString$()
		Return "Module "+munged
	End Method
	
	Method Create:TModuleDecl( ident$,munged$,filepath$,attrs:Int )
		Self.ident=ident
		Self.munged=munged
		Self.filepath=filepath
		Self.attrs=attrs

		If ident.Find(".") <> -1 Then
			Local m:String = ident[..ident.Find(".")]
			Local ns:TNamespaceDecl = TNamespaceDecl(_appInstance.GetDecl(m.ToLower()))
			If Not ns Then
				ns = New TNamespaceDecl.Create(m, m)
				If _appInstance.mainModule Then
					_appInstance.mainModule.InsertDecl(ns)
				Else
					' this must be the main module...
					InsertDecl(ns)
				End If
			End If
			ns.InsertDecl(Self)
		End If

		Return Self
	End Method

	Method UpdateFilePath(fp:String)
		filepath = fp
	End Method
	
	Method AddImport(imp:String, obj:Object)
		imported.Insert(imp, obj)
		FlushCaches()
	End Method
	
	Method FlushCaches()
		_getDeclTreeCache = Null
		If TModuleDecl(pmod) Then
			TModuleDecl(pmod).FlushCaches()
		End If
	End Method
	
	Method IsStrict:Int()
		Return (attrs & MODULE_STRICT)<>0
	End Method

	Method IsSuperStrict:Int()
		Return (attrs & MODULE_SUPERSTRICT)<>0
	End Method
	
	Method IsActualModule:Int()
		Return (attrs & MODULE_ACTUALMOD)<>0
	End Method
	
	Method GetDecl:Object( ident$ )
		' if we previously found it, return it from the cache
		Local decl:Object = _getDeclCache.ValueForKey(ident)

		If decl Then
			Return decl
		End If
		
		If _getDeclTreeCache Then
		
			Local declmod$
		
			For Local mdecl:TModuleDecl = EachIn _getDeclTreeCache

				If ident = mdecl.ident
					_getDeclCache.Insert(ident, mdecl)
					Return mdecl
				End If
			
				Local tdecl_:Object=mdecl.GetDecl2( ident )
			
				If tdecl_ And tdecl_<>decl
					If mdecl=Self
						_getDeclCache.Insert(ident, tdecl_)
						Return tdecl_
					End If
					If decl
						Err "Duplicate identifier '"+ident+"' found in module '"+declmod+"' and module '"+mdecl.ident+"'."
					EndIf
					decl=tdecl_
					declmod=mdecl.ident
				EndIf
			Next
		
		Else
		
			_getDeclTreeCache = New TList
	
			Local todo:TList=New TList'<TModuleDecl>
			'Local done:TIntMap=New TIntMap'<TModuleDecl>
			Local done:TMap = New TMap
			
			todo.AddLast Self
			'done.Insert _filePathId,Self
			done.Insert filePath,Self
			
			Local declmod$
			
			While Not todo.IsEmpty()
		
				Local mdecl:TModuleDecl=TModuleDecl(todo.RemoveLast())
				
				_getDeclTreeCache.AddLast(mdecl)
				
				Local imps:TUnorderedMap=mdecl.imported
	
				For Local mdecl2:TModuleDecl=EachIn imps.Values()
	
					'If Not done.Contains( mdecl2._filePathId )
					If Not done.Contains( mdecl2.filePath )
						todo.AddLast mdecl2
						'done.Insert mdecl2._filePathId,mdecl2
						done.Insert mdecl2.filePath,mdecl2
					EndIf
					
				Next
	
			Wend
	
			Return GetDecl(ident)
	
		End If
			
		' cache it for next time
		_getDeclCache.Insert(ident, decl)
		
		Return decl
	End Method
	
	Method GetDecl2:Object( ident$ )
		Return Super.GetDecl( ident )
	End Method


	Method GetDeclList:Object( ident$, declList:TFuncDeclList = Null, maxSearchDepth:Int )

		If Not declList Then
			declList = New TFuncDeclList
		End If

		Local decl:Object,declmod$

		If _getDeclTreeCache Then
		
'			Print "   Using Cache"
			
			Local declmod$
		
			For Local mdecl:TModuleDecl = EachIn _getDeclTreeCache
			
				If ident = mdecl.ident
					'_getDeclCache.Insert(identId, mdecl)
					Return mdecl
				End If
			
				Local tdecl_:Object=mdecl.GetDeclList2( ident, declList, maxSearchDepth )
			
				If tdecl_ And tdecl_<>decl
					If mdecl=Self
						_getDeclCache.Insert(ident, tdecl_)
						Return tdecl_
					End If
					If decl
						Err "Duplicate identifier '"+ident+"' found in module '"+declmod+"' and module '"+mdecl.ident+"'."
					EndIf
					decl=tdecl_
					declmod=mdecl.ident
				EndIf
			Next
		
		Else

			_getDeclTreeCache = New TList
	
			Local todo:TList=New TList'<TModuleDecl>
			Local done:TMap=New TMap'<TModuleDecl>
			
			todo.AddLast Self
			done.Insert filepath,Self
			
			'Local decl:Object,declmod$
			
			While Not todo.IsEmpty()
		
				Local mdecl:TModuleDecl=TModuleDecl(todo.RemoveLast())
				_getDeclTreeCache.AddLast(mdecl)
				
				Local imps:TUnorderedMap=mdecl.imported
	
				For Local mdecl2:TModuleDecl=EachIn imps.Values()
					If Not done.Contains( mdecl2.filepath )
						todo.AddLast mdecl2
						done.Insert mdecl2.filepath,mdecl2
					EndIf
					
				Next
	
			Wend
		
			Return GetDeclList( ident, declList, maxSearchDepth )
		
		End If
		
		Return decl
	End Method
	
	Method GetDeclList2:Object( ident$, declList:TFuncDeclList = Null, maxSearchDepth:Int )
		Return Super.GetDeclList( ident, declList, maxSearchDepth )
	End Method

	Method OnSemant()
		Local decl:TFuncDecl = FindFuncDecl( "__localmain", ,,,,,SCOPE_MODULE )
		If decl Then
			decl.Semant
		End If
	
		For Local gdecl:TGlobalDecl=EachIn _decls
			gdecl.Semant
		Next

		For Local cdecl:TClassDecl=EachIn _decls
			cdecl.Semant
		Next

		For Local fdecl:TFuncDecl=EachIn _decls
			fdecl.Semant
		Next

		For Local cdecl:TConstDecl=EachIn _decls
			cdecl.Semant
		Next
	End Method

End Type

Type TAppDecl Extends TScopeDecl

	Field imported:TUnorderedMap=New TUnorderedMap'<TModuleDecl>			'maps modpath->mdecl
	
	Field globalImports:TUnorderedMap = New TUnorderedMap
	
	Field mainModule:TModuleDecl
	Field mainFunc:TFuncDecl	
		
	Field semantedClasses:TList=New TList'<TClassDecl>			'in-order (ie: base before derived) list of _semanted classes
	Field semantedGlobals:TList=New TList'<TGlobalDecl>			'in-order (ie: dependancy sorted) list of _semanted globals

	Field fileImports:TList=New TList'StringList
	Field headers:TList = New TList
	
	Field stringConsts:TMap = New TMap
	Field stringConstCount:Int
	
	Field incbins:TList = New TList
	Field genIncBinHeader:Int = False
	
	Field dataDefs:TList = New TList
	Field scopeDefs:TMap = New TMap
	
	Method GetPathPrefix:String()
		If opt_buildtype = BUILDTYPE_MODULE Then
			Local prefix:String
			Local path:String[] = mainModule.filepath.split("/")
			Local c:Int = 0
			For Local dir:String = EachIn path
				If c Then
					prefix :+ dir.Replace(".mod", "") + "_"
					c:- 1
				End If
				If dir = "mod" Then
					c = 2
				End If
			Next
		Else
			Return "bb_"
		End If
	End Method
	
	Method InsertModule( mdecl:TModuleDecl )
		mdecl.scope=Self
		imported.Insert mdecl.filepath,mdecl
		If Not mainModule
			mainModule=mdecl
		EndIf
	End Method
	
	Method IsImported:Int(modpath:String)
		Return globalImports.Contains(modpath)
	End Method
	
	Method GetDecl:Object( ident$ )
		Local obj:Object = Super.GetDecl(ident)
		If Not obj And mainModule Then
			Return mainModule.GetDecl(ident)
		End If
		Return obj
	End Method

	Method OnSemant()
'DebugStop		
		_env=Null
		pushenv Self
		
		SemantDataDefs()	

		mainModule.Semant

		mainFunc=mainModule.FindFuncDecl( "__localmain",,,,,,SCOPE_MODULE )
		
		
		' FIXME
		If Not mainFunc Err "Function 'Main' not found."
	
		SemantDecls()

		Repeat
			Local more:Int
			For Local cdecl:TClassDecl=EachIn semantedClasses
				more:+cdecl.UpdateLiveMethods()
			Next
			If Not more Exit
		Forever
		
		For Local cdecl:TClassDecl=EachIn semantedClasses
			cdecl.FinalizeClass
		Next
	End Method
	
	Method SemantDataDefs()
		TDefDataDecl.count = 0
		
		For Local decl:TDecl = EachIn dataDefs
			decl.Semant
		Next
	End Method
	
	Method SemantDecls()
		For Local decl:TDecl=EachIn mainModule._decls

			decl.Semant
			
			' consts
			Local cdecl:TConstDecl=TConstDecl( decl )
			If cdecl
				cdecl.Semant()
				Continue
			End If

			' classes
			Local tdecl:TClassDecl=TClassDecl( decl )
			If tdecl
				tdecl.Semant()
				tdecl.SemantParts()
				Continue
			EndIf

			' functions
			Local fdecl:TFuncDecl=TFuncDecl( decl )
			If fdecl And fdecl <> _appInstance.mainFunc Then
				fdecl.Semant()
				Continue
			End If

			' globals
			Local gdecl:TGlobalDecl=TGlobalDecl( decl )
			If gdecl
				gdecl.Semant()
				Continue
			End If
		Next

	End Method
	
	Method hasStringConst:Int(value:String)
		Return stringConsts.ValueForKey(value) <> Null
	End Method
	
	Method mapStringConsts(value:String)
		Local sc:TStringConst = TStringConst(stringConsts.ValueForKey(value))
		
		If Not sc Then
			Local sc:TStringConst = New TStringConst
			sc.count = 1
		
			If value Then
				sc.id = "_s" + stringConstCount
			Else
				sc.id = "bbEmptyString"
			End If

			stringConsts.Insert(value, sc)

			If value Then
				stringConstCount:+ 1
			End If
		Else
			sc.count :+ 1
		End If
	End Method
	
	Method removeStringConst(value:String)
		If value Then
			Local sc:TStringConst = TStringConst(stringConsts.ValueForKey(value))
			If sc Then
				If sc.count > 0 Then
					sc.count :- 1
					'stringConsts.Remove(value)
				End If
			End If
		End If
	End Method
	
	Method FindDataLabel:TDecl(ident:String)
		For Local dd:TDefDataDecl = EachIn dataDefs
			If dd.label And dd.label.ident.ToLower() = ident.ToLower() Then
				Return dd
			End If
		Next
	End Method
	
End Type

Type TStringConst

	Field id:String
	Field count:Int

End Type
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'

Type TExpr
	Field exprType:TType

	Method ToString$()
		Return "<TExpr>"
	End Method

	Method Copy:TExpr()
		InternalErr
	End Method

	Method Semant:TExpr()
		InternalErr
	End Method

	Method SemantSet:TExpr( op$,rhs:TExpr )
		Err ToString()+" cannot be assigned to."
	End Method

	Method SemantFunc:TExpr( args:TExpr[] , throwError:Int = True, funcCall:Int = False )
		Err ToString()+" cannot be invoked."
	End Method

	Method SemantScope:TScopeDecl()
		Return Null
	End Method

	Method Eval$()
		Err ToString()+" cannot be statically evaluated."
	End Method

	Method EvalConst:TExpr()
		Local expr:TExpr = New TConstExpr.Create( exprType,Eval() ).Semant()
		If TStringType(TConstExpr(expr).ty) Then
			_appInstance.mapStringConsts(TConstExpr(expr).value)
		End If
		Return expr
	End Method

	Method Trans$()
		Todo
	End Method

	Method TransStmt$()
		Return Trans()
	End Method

	Method TransVar$()
		InternalErr
	End Method

	'semant and cast
	Method SemantAndCast:TExpr( ty:TType,castFlags:Int=0 )
		Local expr:TExpr=Semant()
		If expr.exprType.EqualsType( ty ) Return expr
		Return New TCastExpr.Create( ty,expr,castFlags ).Semant()
	End Method

	'expr and ty already semanted!
	Method Cast:TExpr( ty:TType,castFlags:Int=0 )
		If Not exprType Then
			Semant()
		End If
		If exprType.EqualsType( ty ) Return Self
		Return New TCastExpr.Create( ty,Self,castFlags ).Semant()
	End Method

	Method SemantArgs:TExpr[]( args:TExpr[] )
		args=args[..]
		For Local i:Int=0 Until args.Length
			If args[i] Then
				If TIdentExpr(args[i]) Then
					TIdentExpr(args[i]).isArg = True
				End If
				args[i]=args[i].Semant()

				' if an arg is a invocation without braces, it is *probably* a function pointer.
				If TInvokeExpr(args[i]) And Not TInvokeExpr(args[i]).invokedWithBraces Then
					' but not if we've already processed it...
					If Not (TInvokeExpr(args[i]).decl.attrs & FUNC_PTR) Then
						TInvokeExpr(args[i]).exprType = New TFunctionPtrType
						Local cp:TDecl = TInvokeExpr(args[i]).decl
						cp.Semant
						TInvokeExpr(args[i]).decl = TFuncDecl(TInvokeExpr(args[i]).decl.Copy(False))
						TInvokeExpr(args[i]).decl.actual = cp
						TInvokeExpr(args[i]).decl.attrs :| FUNC_PTR
						TFunctionPtrType(TInvokeExpr(args[i]).exprType).func = TInvokeExpr(args[i]).decl

						TInvokeExpr(args[i]).decl.semant()
					End If
				End If
				
			End If
		Next
		Return args
	End Method

	Method CastArgs:TExpr[]( args:TExpr[],funcDecl:TFuncDecl )
		If args.Length>funcDecl.argDecls.Length Then
			Err "Too many function parameters"
		End If

		' FIXME
		'args=args.Resize( funcDecl.argDecls.Length )
		' FIXME

		For Local i:Int=0 Until funcDecl.argDecls.Length
			' ensure funcdecl args are semanted before trying to use them.
			If Not funcDecl.argDecls[i].IsSemanted() Then
				funcDecl.argDecls[i].Semant()
			End If

			If i < args.length And args[i]
				If TInvokeExpr(args[i]) And Not TInvokeExpr(args[i]).invokedWithBraces Then
					If Not IsPointerType(funcDecl.argDecls[i].ty, TType.T_BYTE) And Not TFunctionPtrType(funcDecl.argDecls[i].ty) Then
						Err "Unable to convert from '" + args[i].exprType.ToString() + "()' to '" + funcDecl.argDecls[i].ty.ToString() + "'"
					End If
				End If

				If TInvokeMemberExpr(args[i]) And Not TInvokeMemberExpr(args[i]).invokedWithBraces Then
					If Not IsPointerType(funcDecl.argDecls[i].ty, TType.T_BYTE) And Not TFunctionPtrType(funcDecl.argDecls[i].ty) Then
						Err "Unable to convert from '" + args[i].exprType.ToString() + "()' to '" + funcDecl.argDecls[i].ty.ToString() + "'"
					End If
				End If

				If funcDecl.argDecls[i].ty._flags & TType.T_VAR Then

					If TConstExpr(args[i]) Or TBinaryExpr(args[i]) Or (TIndexExpr(args[i]) And TStringType(TIndexExpr(args[i]).expr.exprType)) Or ..
							TInvokeExpr(args[i]) Or TInvokeMemberExpr(args[i]) Then
						Err "Expression for 'Var' parameter must be a variable"
					End If

					' Passing a "new" object into a Var, requires us to create a local variable and pass its address instead.
					If TNewObjectExpr(args[i]) Then
						Local tmp:TLocalDecl=New TLocalDecl.Create( "",TNewObjectExpr(args[i]).ty,args[i],, True )
						tmp.Semant()
						Local v:TVarExpr = New TVarExpr.Create( tmp )
						Local stmt:TExpr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), v ).Semant()
						stmt.exprType = TNewObjectExpr(args[i]).ty
						args[i] = stmt
					End If
				End If
				
				If (funcDecl.argDecls[i].ty._flags & TType.T_VAR) And Not (funcDecl.argDecls[i].ty.EqualsType(args[i].exprType)) Then
					If (Not TObjectType(funcDecl.argDecls[i].ty)) Or (TObjectType(funcDecl.argDecls[i].ty) And Not args[i].exprType.ExtendsType(funcDecl.argDecls[i].ty)) Then
						err "Variable for 'Var' parameter is not of matching type"
					End If
				End If

				' re-test auto array for compatible consts.
				If TArrayExpr(args[i]) And TArrayType(funcDecl.argDecls[i].ty) And TNumericType(TArrayType(funcDecl.argDecls[i].ty).elemType) Then
					TArrayExpr(args[i]).toType = TArrayType(funcDecl.argDecls[i].ty).elemType
					args[i].exprType = Null
					args[i].Semant()
				End If
					
				args[i]=args[i].Cast( funcDecl.argDecls[i].ty )
			Else If funcDecl.argDecls[i].init
				If i = args.length Then
					' extend args to add default init entry
					args = args[..i + 1]
				End If
				args[i]=funcDecl.argDecls[i].init
			Else
				Err "Missing function argument '"+funcDecl.argDecls[i].ident+"'."
			EndIf
		Next
		Return args
	End Method

	Method BalanceTypes:TType( lhs:TType,rhs:TType )

		If TStringType( lhs ) Or TStringType( rhs ) Then
			If TObjectType(lhs) Or TObjectType(rhs) Then
				If TObjectType(lhs) And TObjectType(lhs).classDecl.ident = "Object" Then
					Return lhs
				End If
				If TObjectType(rhs) And TObjectType(rhs).classDecl.ident = "Object" Then
					Return rhs
				End If
			Else
				Return New TStringType
			End If
		End If
		If IsPointerType( lhs, 0, TType.T_POINTER ) Or IsPointerType( rhs, 0, TType.T_POINTER ) Then
			If IsPointerType( lhs, 0, TType.T_POINTER ) Return lhs
			If IsPointerType( rhs, 0, TType.T_POINTER ) Return rhs
		End If
		If TDouble128Type( lhs ) Or TDouble128Type( rhs ) Return New TDouble128Type
		If TFloat128Type( lhs ) Or TFloat128Type( rhs ) Return New TFloat128Type
		If TFloat64Type( lhs ) Or TFloat64Type( rhs ) Return New TFloat64Type
		If TDoubleType( lhs ) Or TDoubleType( rhs ) Return New TDoubleType
		If TFloatType( lhs ) Or TFloatType( rhs ) Return New TFloatType
		If TFunctionPtrType( lhs ) Or TFunctionPtrType( rhs ) Then
			If TFunctionPtrType( lhs ) Return lhs
			If TFunctionPtrType( rhs ) Return rhs
		End If
		If TInt128Type( lhs ) Or TInt128Type( rhs ) Return New TInt128Type
		If TULongType( lhs ) Or TULongType( rhs ) Return New TULongType
		If TSizeTType( lhs ) Or TSizeTType( rhs ) Return New TSizeTType
		If TWParamType( lhs ) Or TWParamType( rhs ) Return New TWParamType
		If TLongType( lhs ) And TUIntType( rhs ) Return New TULongType
		If TUIntType( lhs ) And TLongType( rhs ) Return New TULongType
		If TLParamType( lhs ) Or TLParamType( rhs ) Return New TLParamType
		If TLongType( lhs ) Or TLongType( rhs ) Return New TLongType
		If TUIntType( lhs ) Or TUIntType( rhs ) Return New TUIntType
		If TIntType( lhs ) Or TIntType( rhs ) Return New TIntType
		If TObjectType( lhs ) And TNullDecl(TObjectType( lhs ).classDecl) Then
			Return rhs
		End If
		If TObjectType( rhs ) And TNullDecl(TObjectType( rhs ).classDecl) Then
			Return lhs
		End If
		If lhs.ExtendsType( rhs ) Return rhs
		If rhs.ExtendsType( lhs ) Return lhs
		' balance arrays - only for objects... to the lowest common denominator.
		If TArrayType( lhs ) And TArrayType( rhs ) Then

			If TObjectType(TArrayType( lhs ).elemType) And TObjectType(TArrayType( rhs ).elemType) Then
				' lhs = Object[]
				If TObjectType(TArrayType( lhs ).elemType).classDecl.ident = "Object" Then
					Return lhs
				End If
				' rhs = Object[]
				If TObjectType(TArrayType( rhs ).elemType).classDecl.ident = "Object" Then
					Return rhs
				End If
				
				' does one extend the other? If so, return the base type
				If TObjectType(TArrayType( lhs ).elemType).ExtendsType(TObjectType(TArrayType( rhs ).elemType)) Then
					Return rhs
				End If

				If TObjectType(TArrayType( rhs ).elemType).ExtendsType(TObjectType(TArrayType( lhs ).elemType)) Then
					Return lhs
				End If
				
				' no? then we will fallback to an Object type array
				
				' find the Object classdecl instance
				Local modid$="brl.classes"
				Local mdecl:TModuleDecl=_env.FindModuleDecl( modid )
				' return an array of Objects
				Return New TArrayType.Create(New TObjectType.Create(TClassDecl(mdecl.FindDecl( "object" ))))
			End If
			
			If TObjectType(TArrayType( lhs ).elemType) And TObjectType(TArrayType( lhs ).elemType).classDecl.ident = "Object" And TStringType(TArrayType( rhs ).elemType) Then
				Return lhs
			End If

			If TObjectType(TArrayType( rhs ).elemType) And TObjectType(TArrayType( rhs ).elemType).classDecl.ident = "Object"  And TStringType(TArrayType( lhs ).elemType) Then
				Return rhs
			End If

			If TObjectType(TArrayType( lhs ).elemType) And TObjectType(TArrayType( lhs ).elemType).classDecl.ident = "Object"  And TArrayType(TArrayType( rhs ).elemType) Then
				Return lhs
			End If

			If TObjectType(TArrayType( rhs ).elemType) And TObjectType(TArrayType( rhs ).elemType).classDecl.ident = "Object"  And TArrayType(TArrayType( lhs ).elemType) Then
				Return rhs
			End If

			' balancing primitive types
			If Not TArrayType( lhs ).elemType.EqualsType(TArrayType( rhs ).elemType) Then
				Err "Types '" + TArrayType( lhs ).elemType.ToString() + " Array' and '" + TArrayType( rhs ).elemType.ToString() + " Array' are unrelated"
			End If
			
		End If
		Err "Can't balance types "+lhs.ToString()+" and "+rhs.ToString()+"."
	End Method

	Function CopyExpr:TExpr( expr:TExpr )
		If Not expr Return Null
		Return expr.Copy()
	End Function

	Function CopyArgs:TExpr[]( exprs:TExpr[] )
		exprs=exprs[..]
		For Local i:Int=0 Until exprs.Length
			exprs[i]=CopyExpr( exprs[i] )
		Next
		Return exprs
	End Function

End Type

'	exec a stmt, return an expr
Type TStmtExpr Extends TExpr
	Field stmt:TStmt
	Field expr:TExpr

	Method Create:TStmtExpr( stmt:TStmt,expr:TExpr )
		Self.stmt=stmt
		Self.expr=expr
		Return Self
	End Method

	Method Copy:TExpr()
		If exprType Return Self
		Return New TStmtExpr.Create( stmt,CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TStmtExpr(,"+expr.ToString()+")"
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		stmt.Semant()
		expr=expr.Semant()
		exprType=expr.exprType
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransStmtExpr( Self )
	End Method

	Method TransVar$()
		Semant
		Return _trans.TransStmtExpr( Self )
	End Method

End Type

'	literal
Type TConstExpr Extends TExpr
	Field ty:TType
	Field value$
	Field originalValue$
	' True if the const was identified as a specific type.
	Field typeSpecific:Int

	Method Create:TConstExpr( ty:TType,value$ )
		originalValue = value
		
		If TNumericType( ty ) And IsPointerType(ty, 0, TType.T_POINTER) Then
			Self.ty=ty
			If value Then
				Self.value = value
			Else
				Self.value="0"
			End If
			Return Self
		End If
		
		If TIntType( ty ) Or TShortType( ty ) Or TByteType( ty ) Or TLongType( ty ) Or TUIntType( ty ) Or TULongType( ty ) Or TWParamType(ty) Or TLParamType(ty)
			Local radix:Int
			If value.StartsWith( "%" )
				radix=1
			Else If value.StartsWith( "$" )
				radix=4
			EndIf

			If radix
				Local val:Long = 0

				For Local i:Int=1 Until value.Length
					Local ch:Int=value[i]
					If ch>=48 And ch<58
						val=val Shl radix | (ch & 15)
					Else
						val=val Shl radix | ((ch & 15)+9)
					EndIf
				Next
				If TIntType(ty) And val >= 2147483648:Long Then
					value = String( -2147483648:Long + (val - 2147483648:Long))
				Else
					If TShortType( ty ) Then
						value=String( Short(val) )
					Else If TByteType( ty ) Then
						value=String( Byte(val) )
					Else
						value=String( val )
					End If
				End If
			Else
				If TShortType( ty ) Then
					value = String.FromLong(Short(value.ToLong()))
				Else If TByteType( ty ) Then
					value = String.FromLong(Byte(value.ToLong()))
				Else
					Local buf:Byte[64]
					Local b:Int
					Local v:String = value.Trim()
					Local leading0:Int = True
					If v Then
						Local i:Int
						If v[0] = Asc("+") Then
							i = 1
						Else If v[0] = Asc("-") Then
							i = 1
							buf[b] = Asc("-")
							b:+ 1
						End If
						
						While i < value.Length
							If Not IsDigit(v[i]) Then
								Exit
							End If
							If leading0 And v[i] = Asc("0") Then
								i :+ 1
								Continue
							End If
							leading0 = False
							buf[b] = v[i]
							
							b :+ 1
							i :+ 1
						Wend
						
						If leading0 Then
							value = "0"
						Else
							value = String.FromBytes(buf, b)
						End If
					Else
						value = "0"
					End If
				End If
			EndIf

		Else If TDecimalType( ty )
			If Not (value.Contains("e") Or value.Contains("E") Or value.Contains(".") Or value.Contains("inf") Or value.Contains("nan"))
				value:+".0"
			EndIf
		EndIf
		Self.ty=ty
		Self.value=value
		Return Self
	End Method
	
	Method UpdateType(ty:TType)
		typeSpecific = True
		Create(ty, originalValue)
	End Method

	Method Copy:TExpr()
		Local e:TConstExpr = New TConstExpr.Create( ty,value )
		e.originalValue = originalValue
		e.typeSpecific = typeSpecific
		Return e
	End Method

	Method ToString$()
		Return "TConstExpr(~q"+value+"~q)"
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		exprType=ty.Semant()
		Return Self
	End Method

	Method Eval$()
		Return value
	End Method

	Method EvalConst:TExpr()
		Return Self
	End Method

	Method Trans$()
		Semant
		Return _trans.TransConstExpr( Self )
	End Method

	Method SemantAndCast:TExpr( ty:TType,castFlags:Int=0 )
		Local expr:TExpr=Semant()
		If expr.exprType.EqualsType( ty ) Return expr
		If value = "bbNullObject" Then
			Err "bbNullObject"
			Return expr
		End If
		Return New TCastExpr.Create( ty,expr,castFlags ).Semant()
	End Method
	
	Method CompatibleWithType:Int(ty:TType)
		If Not TDecimalType(ty) Then
			If value.Contains("e") Or value.Contains("E") Or value.Contains(".") Or value.Contains("inf") Or value.Contains("nan") Then
				Return False
			End If
			
			Local val:Long = value.ToLong()
			
			If val < 0 Then
				If TByteType(ty) Or TShortType(ty) Or TUIntType(ty) Or TULongType(ty) Or TSizeTType(ty) Or TInt128Type(ty) Or TWParamType(ty) Then
					Return False
				End If
			Else
				If TByteType(ty) Then
					If value <> String.FromInt(Byte(Val)) Then
						Return False
					End If
				End If

				If TUIntType(ty) Or ((TSizeTType(ty) Or TWParamType(ty)) And WORD_SIZE = 4) Then
					If val > 4294967296:Long Then
						Return False
					End If
				End If
				
				If TULongType(ty) Or ((TSizeTType(ty) Or TWParamType(ty)) And WORD_SIZE = 8) Then
					If value.length > 20 Then
						Return False
					Else If value.length = 20 Then
						For Local i:Int = 0 Until value.length
							Local v:Int = value[i]
							Local n:Int = "18446744073709551616"[i]
							If v < n Then
								Exit 
							Else If v > n Then
								Return False
							End If
						Next
					End If
				End If
			End If
			
			If TShortType(ty) Then
				If value <> String.FromInt(Short(val)) Then
					Return False
				End If
			End If

			If TIntType(ty) Or (TLParamType(ty) And WORD_SIZE = 4) Then
				If value <> String.FromInt(Int(val)) Then
					Return False
				End If
			End If

			If TLongType(ty) Or (TLParamType(ty) And WORD_SIZE = 8) Then
				If value <> String.FromLong(Long(val)) Then
					Return False
				End If
			End If
			
		End If
		
		Return True
	End Method

End Type

Type TVarExpr Extends TExpr
	Field decl:TVarDecl

	Method Create:TVarExpr( decl:TVarDecl )
		Self.decl=decl
		Return Self
	End Method

	Method Copy:TExpr()
		Return Self
	End Method

	Method ToString$()
		Return "TVarExpr("+decl.ToString()+")"
	End Method

	Method Semant:TExpr()
		If exprType Return Self
		If Not decl.IsSemanted() InternalErr
		exprType=decl.ty
		Return Self
	End Method

	Method SemantSet:TExpr( op$,rhs:TExpr )
		Return Semant()
	End Method

	Method Trans$()
		Semant
		Return _trans.TransTemplateCast( exprType,TVarDecl(decl.actual).ty,_trans.TransVarExpr( Self ) )
	End Method

	Method TransVar$()
		Semant
		Return _trans.TransVarExpr( Self )
	End Method

End Type

Type TMemberVarExpr Extends TExpr
	Field expr:TExpr
	Field decl:TVarDecl

	Method Create:TMemberVarExpr( expr:TExpr,decl:TVarDecl )
		Self.expr=expr
		Self.decl=decl
		Return Self
	End Method

	Method Copy:TExpr()
		Return Self
	End Method

	Method ToString$()
		Return "TMemberVarExpr("+expr.ToString()+","+decl.ToString()+")"
	End Method

	Method Semant:TExpr()
		If exprType Return Self
		If Not decl.IsSemanted() InternalErr
		exprType=decl.ty
		Return Self
	End Method

	Method SemantSet:TExpr( op$,rhs:TExpr )
		Return Semant()
	End Method

	Method Trans$()
		Return _trans.TransTemplateCast( exprType,TVarDecl(decl.actual).ty,_trans.TransMemberVarExpr( Self ) )
	End Method

	Method TransVar$()
		Return _trans.TransMemberVarExpr( Self )
 	End Method

End Type

Type TInvokeExpr Extends TExpr
	Field decl:TFuncDecl
	Field args:TExpr[]
	Field invokedWithBraces:Int
	Field isArg:Int
	Field isRhs:Int

	Method Create:TInvokeExpr( decl:TFuncDecl,args:TExpr[]=Null,invokedWithBraces:Int=True, isArg:Int=False, isRhs:Int = False )
		Self.decl=decl
		If args Then
			Self.args=args
		Else
			Self.args = New TExpr[0]
		End If
		Self.invokedWithBraces = invokedWithBraces
		Self.isArg = isArg
		Self.isRhs = isRhs
		Return Self
	End Method

	Method Copy:TExpr()
		Return Self
	End Method

	Method ToString$()
		Local t$="TInvokeExpr("+decl.ToString()
		For Local arg:TExpr=EachIn args
			t:+","+arg.ToString()
		Next
		Return t+")"
	End Method

	Method Semant:TExpr()

		If exprType Return Self

		If Not decl.retType
			decl.Semant()
		End If
		'If TIdentType(decl.retType) Then
			exprType = decl.retType.Semant()
		'Else
		'	exprType=decl.retType
		'End If

		If ((isArg Or isRhs) And Not invokedWithBraces) And (args = Null Or args.length = 0) Then
			' nothing to do here, as we are probably a function pointer. i.e. no braces and no 
			' and our expression type is a function ptr...
			exprType = New TFunctionPtrType.Create(decl)
			
		Else
			args=CastArgs( args,decl )
		End If
		Return Self
	End Method

	Method Trans$()
'		Return _trans.TransTemplateCast( exprType,TFuncDecl(decl.actual).retType,_trans.TransInvokeExpr( Self ) )
		Return _trans.TransInvokeExpr( Self )
	End Method

	Method TransStmt$()
		Return _trans.TransInvokeExpr( Self )
	End Method

	Method Eval$()
		Return Super.Eval()
	End Method

End Type

Type TInvokeMemberExpr Extends TExpr
	Field expr:TExpr
	Field decl:TFuncDecl
	Field args:TExpr[]
	Field isResize:Int	'FIXME - butt ugly!
	Field invokedWithBraces:Int

	Method Create:TInvokeMemberExpr( expr:TExpr,decl:TFuncDecl,args:TExpr[]=Null, invokedWithBraces:Int = True )
		Self.expr=expr
		Self.decl=decl
		If args
			Self.args=args
		Else
			Self.args = New TExpr[0]
		End If
		Self.invokedWithBraces = invokedWithBraces
		Return Self
	End Method

	Method Copy:TExpr()
		Return Self
	End Method

	Method ToString$()
		Local t$="TInvokeMemberExpr("+expr.ToString()+","+decl.ToString()
		For Local arg:TExpr=EachIn args
			t:+","+arg.ToString()
		Next
		Return t+")"
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		If Not decl.IsSemanted() decl.Semant()
		exprType=decl.retType

		args=SemantArgs( args )
		args=CastArgs( args,decl )

		'Array $resize hack!
		If TArrayType( exprType ) And TVoidType( TArrayType( exprType ).elemType )
			isResize=True
			exprType=expr.exprType
		EndIf

		Return Self
	End Method

	Method Trans$()
		'Array $resize hack!
		If isResize Return _trans.TransInvokeMemberExpr( Self )

		Return _trans.TransTemplateCast( exprType,TFuncDecl(decl.actual).retType,_trans.TransInvokeMemberExpr( Self ) )
	End Method

	Method TransStmt$()
		Return _trans.TransInvokeMemberExpr( Self )
	End Method

End Type

Type TNewObjectExpr Extends TExpr
	Field ty:TType
	Field args:TExpr[]
	Field ctor:TFuncDecl
	Field classDecl:TClassDecl
	Field instanceExpr:TExpr

	Method Create:TNewObjectExpr( ty:TType,args:TExpr[] )
		Self.ty=ty
		Self.args=args
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TNewObjectExpr.Create( ty,CopyArgs(args) )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		Local it:TIdentType = TIdentType(ty)
		Local iArgs:TExpr[] = SemantArgs(CopyArgs(args))

		ty=ty.Semant(True)
		If Not ty Then
			' maybe it's an instance of a type ?
			Local decl:TVarDecl = TVarDecl(_env.FindDecl(it.ident))
			If decl And TObjectType(decl.ty) Then
				ty = decl.ty
				instanceExpr = New TVarExpr.Create(decl).Semant()
			Else
				Err "Type '"+it.ident+"' not found"
			End If
		End If
		args=SemantArgs( args )

		Local objTy:TObjectType=TObjectType( ty )
		Local clsTy:TClassType=TClassType( ty )
		If Not objTy And Not clsTy
			Err "Expression is not a class."
		EndIf
		
		' 
		If clsTy And clsTy.instance Then
			instanceExpr = New TSelfExpr.Semant()
		End If

		If objTy Then
			classDecl=objTy.classDecl
		Else
			classDecl=clsTy.classDecl
		End If

		If Not instanceExpr Then
			If classDecl.IsInterface() Err "Cannot create instance of an interface."
			If classDecl.IsAbstract() Err "Cannot create instance of an abstract class."
		End If
		'If classDecl.IsTemplateArg() Err "Cannot create instance of a generic argument."
		If classDecl.args And Not classDecl.instanceof Err "Cannot create instance of a generic class."

		Local parts:String[]
		If it Then
			parts = it.ident.ToLower().Split(".")
		End If

		If classDecl.IsExtern()
			Err "Cannot create instance of an extern type"
			'If args Err "No suitable constructor found for class "+classDecl.ToString()+"."
		Else
			' if the New Type doesn't have extra idents (like a create method), then don't use the args in the search.
			' otherwise, the args are for the constructor.
			If Not parts Or parts.length = 1 Then
				ctor=classDecl.FindFuncDecl( "new",args,,,,,SCOPE_CLASS_HEIRARCHY )
				If Not ctor	Err "No suitable constructor found for class "+classDecl.ToString()+"."
				args=CastArgs( args,ctor )
			Else
				ctor=classDecl.FindFuncDecl( "new",,,,,,SCOPE_CLASS_HEIRARCHY )
				If Not ctor	Err "No suitable constructor found for class "+classDecl.ToString()+"."
			End If
		EndIf

		classDecl.attrs:|CLASS_INSTANCED

		exprType=ty
		
		If it Then
			'Local parts:String[] = it.ident.ToLower().Split(".")

			Local i:Int = 0
			
			While i < parts.length And parts[i] <> classDecl.IdentLower() And parts[i] <> "self"
				i :+ 1
			Wend
			
			i :+ 1

			Local expr:TExpr = Self
			Local cdecl:TClassDecl = classDecl
			Local eType:TType = ty
			
			Local errorDetails:String

			While i < parts.length
				Local id:String = parts[i]
				i :+ 1
				
				' find member function.method
				Local fdecl:TFuncDecl
				Try
					fdecl = cdecl.FindFuncDecl(id, iArgs,,,,True,SCOPE_CLASS_HEIRARCHY)
				Catch errorMessage:String
					If errorMessage.StartsWith("Compile Error") Then
						Throw errorMessage
					Else
						' couldn't find an exact match, look elsewhere
						If errorMessage.StartsWith("Unable") Then
							errorDetails = errorMessage
						End If
					End If
				End Try
				If fdecl Then
					expr = New TInvokeMemberExpr.Create( expr,fdecl, iArgs ).Semant()
					eType = expr.exprType
					If TObjectType(eType) Then
						cdecl = TObjectType(expr.exprType).classdecl
					End If
					If TArrayType(eType) Or TStringType(eType) Then
						cdecl = eType.GetClass()
					End If
					Continue
				End If
				
				' find other member decl (field, etc)
				If Not errorDetails Then
					Local decl:TVarDecl = TVarDecl(cdecl.GetDecl(id))
					If decl Then
						Local tmp:TLocalDecl=New TLocalDecl.Create( "", eType, expr,, True )
						Local varExpr:TExpr = New TMemberVarExpr.Create(New TVarExpr.Create( tmp ), decl).Semant()
						expr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), varExpr ).Semant()
						eType = decl.ty
						If TObjectType(eType) Then
							cdecl = TObjectType(expr.exprType).classdecl
						End If
						If TArrayType(eType) Or TStringType(eType) Then
							cdecl = eType.GetClass()
						End If
						Continue
					End If
				End If	

				' didn't match member or function??
				' probably an error...
				If errorDetails Then
					Err errorDetails
				Else
					Err "Identifier '" + id + "' not found."
				End If
			Wend
			
			Return expr
		End If

		Return Self
	End Method

	Method Trans$()
		Return _trans.TransNewObjectExpr( Self )
	End Method
End Type

Type TNewArrayExpr Extends TExpr
	Field ty:TType

	Field expr:TExpr[]
	
	Method Create:TNewArrayExpr( ty:TType,expr:TExpr[] )

		Self.ty=ty
		Self.expr=expr
		Return Self
	End Method

	Method Copy:TExpr()
		If exprType InternalErr
		Local cexpr:TExpr[expr.length]
		For Local i:Int = 0 Until expr.length
			cexpr[i] = CopyExpr(expr[i])
		Next
		Return New TNewArrayExpr.Create( ty,cexpr )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		ty=ty.Semant()
		exprType=New TArrayType.Create( ty, expr.length )
		For Local i:Int = 0 Until expr.length
			expr[i]=expr[i].SemantAndCast( New TIntType )
		Next
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransNewArrayExpr( Self )
	End Method

End Type

'	super.ident( args )
Type TInvokeSuperExpr Extends TExpr
	Field ident$
	Field args:TExpr[]
	Field origFuncDecl:TFuncDecl
	Field funcDecl:TFuncDecl
	Field classScope:TClassDecl
	Field superClass:TClassDecl
	
	Field _identLower:String

	Method Create:TInvokeSuperExpr( ident$,args:TExpr[] = Null, _identLower:String = Null )
		Self.ident=ident
		If args Then
			Self.args=args
		Else
			Self.args = New TExpr[0]
		End If
		Self._identLower = _identLower
		Return Self
	End Method

	Method IdentLower:String()
		If Not _identLower Then
			_identLower = ident.ToLower()
		End If
		Return _identLower
	End Method

	Method Copy:TExpr()
		Return New TInvokeSuperExpr.Create( ident,CopyArgs(args), _identLower )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		'If _env.FuncScope().IsStatic() Err "Illegal use of Super."

		classScope=_env.ClassScope()
		superClass=classScope.superClass
		
		If Not superClass Err "Type has no super class."
		
		args=SemantArgs( args )
		Try
			' get the local version of the method from local class scope
			origFuncDecl=classScope.FindFuncDecl(IdentLower(),args,,,,True,SCOPE_CLASS_LOCAL)
		Catch errorMessage:String
			If errorMessage.StartsWith("Compile Error") Then
				Throw errorMessage
			Else
				' if there isn't one, we'll just use a Super version of it anyway as a reference.
				origFuncDecl=classScope.FindFuncDecl(IdentLower(),args,,,,,SCOPE_CLASS_HEIRARCHY)
			End If
		End Try

		funcDecl=superClass.FindFuncDecl( IdentLower(),args,,,,,SCOPE_CLASS_HEIRARCHY )

		If Not funcDecl Err "Can't find superclass method '"+ident+"'."

		' ensure the super function has been semanted
		funcDecl.Semant()
		
		' for static scope, we need to change class scope to that of the super class
		If _env.FuncScope().IsStatic() Then
			classScope = TClassDecl(funcDecl.scope)
		End If
		
		args=CastArgs( args,funcDecl )
		exprType=funcDecl.retType
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransInvokeSuperExpr( Self )
	End Method

End Type

'	Self
Type TSelfExpr Extends TExpr

	Method Copy:TExpr()
		Return New TSelfExpr
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		'If _env.FuncScope().IsStatic() Err "Illegal use of Self within static scope."
		Local scope:TClassDecl = _env.ClassScope()
		If Not scope Then
			Err "'Self' can only be used within methods."
		End If
		
		Local funcScope:TFuncDecl = _env.FuncScope()
		If funcScope.IsAnyMethod() Then
			exprType=New TObjectType.Create( scope )
			TObjectType(exprType).instance = True
		Else
			exprType=New TClassType.Create( scope )
		End If

		Return Self
	End Method

	Method Trans$()
		Return _trans.TransSelfExpr( Self )
	End Method

End Type

Const CAST_EXPLICIT:Int=1

Type TCastExpr Extends TExpr
	Field ty:TType
	Field expr:TExpr
	Field flags:Int

	Method Create:TCastExpr( ty:TType,expr:TExpr,flags:Int=0 )
		Self.ty=ty
		Self.expr=expr
		Self.flags=flags
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TCastExpr.Create( ty,CopyExpr(expr),flags )
	End Method

	Method Semant:TExpr()

		If exprType Return Self

		ty=ty.Semant()
		
		If TInvokeExpr(expr) Then
			TInvokeExpr(expr).isRhs = True
		Else If TIdentExpr(expr) Then
			TIdentExpr(expr).isRhs = True
		End If
		
		expr=expr.Semant()

		Local src:TType=expr.exprType
		
		'equal?
		If src.EqualsType( ty ) Return expr

		'upcast?
		If src.ExtendsType( ty )
			'cast from void[] to T[]
			If TArrayType(src) And TVoidType( TArrayType(src).elemType )
				Return New TConstExpr.Create( ty,"" ).Semant()
			EndIf
			
			If src._flags & TType.T_VARPTR Then
				exprType = ty
				Return Self
			End If

			If TStringType(ty) And TObjectType(src)
				' only if explicitly cast
				If flags & CAST_EXPLICIT Then
					exprType = ty
					'Return Self
				End If
			End If
			'Box/unbox?...
			'If TObjectType( ty ) And Not TObjectType( src )

				'Box!
			'	expr=New TNewObjectExpr.Create( ty,[expr] ).Semant()

			'Else
			If TObjectType( src ) And Not TObjectType( ty ) And Not TStringType( ty )

				'Unbox!
				Local op$
				'If TBoolType( ty )
				'	op="ToBool"
				'Else
				If TIntType( ty )
					op="ToInt"
				Else If TFloatType( ty )
					op="ToFloat"
				Else If TStringType( ty )
					op="ToString"
				Else If IsPointerType(ty, 0, TType.T_POINTER)
					exprType = ty
					If flags = CAST_EXPLICIT Then
						Return Self
					Else
						If Not TObjectType( src ).classDecl.IsExtern() Then
							Return Self
						Else
							Return expr
						End If
					End If
				Else
					InternalErr
				EndIf
				Local fdecl:TFuncDecl=src.GetClass().FindFuncDecl( op,,,,,,SCOPE_ALL )
				expr=New TInvokeMemberExpr.Create( expr,fdecl ).Semant()

			EndIf
			
			If TNullType(src) Then
				exprType = ty
			End If
			
			If TBoolType(src) And (TNumericType(ty) Or TStringType(ty)) Then
				exprType = ty
			End If
			
			If TNumericType(src) And (TNumericType(ty) Or TStringType(ty)) Then
				' intrinsics can only cast between selves
				If (TIntrinsicType(src) And TIntrinsicType(ty)=Null) Or (TIntrinsicType(ty) And TIntrinsicType(src)=Null) Then
					If TFloat64Type(src) Or TFloat64Type(ty) Then
						If (TFloat64Type(src) And (TLongType(ty) Or TULongType(ty))) Or (TFloat64Type(ty) And (TLongType(src) Or TULongType(src))) Then
							' ok
						Else
							Err "Unable to convert from "+src.ToString()+" to "+ty.ToString()+"."
						End If
					Else
						Err "Unable to convert from "+src.ToString()+" to "+ty.ToString()+"."
					End If
				Else If TIntrinsicType(src) And TIntrinsicType(ty) Then
					If (TFloat64Type(src) And TFloat64Type(ty)=Null) Or (TFloat64Type(ty) And TFloat64Type(src)=Null) Then
						Err "Unable to convert from "+src.ToString()+" to "+ty.ToString()+"."
					End If
				End If
				exprType = ty
			End If
			
			If TObjectType(ty) And (TObjectType(src) Or TStringType(src) Or TArrayType(src)) Then
				exprType = ty
				Return Self
			End If
			
			If TFunctionPtrType(src) And IsPointerType(ty, 0, TType.T_POINTER) Then
				exprType = ty
			End If

		Else If TBoolType( ty )

			If TVoidType( src )
				Err "Cannot convert from Void to Int."
			EndIf

			If  flags & CAST_EXPLICIT
				exprType=ty
			EndIf

		Else If ty.ExtendsType( src )

			If flags & CAST_EXPLICIT

				'if both objects or both non-objects...
				If (TObjectType(ty)<>Null)=(TObjectType(src)<>Null) Then
					exprType=ty
					
					If TFunctionPtrType(ty) And TInvokeExpr(expr) And Not TInvokeExpr(expr).invokedWithBraces Then
						Return expr
					End If
					
					Return Self
				End If
				
				If (TStringType(ty) Or TArrayType(ty)) And TObjectType(src) Then
					exprType=ty
					Return Self
				End If
			'Else ' if not explicitly cast, we can't just auto-cast it ourselves here.
				'If (TObjectType(ty)<>Null) And (TObjectType(src)<>Null) exprType=ty
			EndIf

		EndIf


		If TArrayType(ty) And TArrayType(src) Then
			If TArrayType(ty).dims = TArrayType(src).dims Then
				If TArrayExpr(expr) Then
					Local last:TType
					For Local e:TExpr = EachIn TArrayExpr(expr).exprs
						If TNullType(e.exprType) Then
							Err "Auto array element has no type"
						End If

						If TObjectType(TArrayType(ty).elemType) And TObjectType(TArrayType(ty).elemType).classDecl.ident = "Object" And (TStringType(e.exprType) Or TObjectType(e.exprType) Or TArrayType(e.exprType)) Then
							' array takes generic objects, so we don't care if source elements are the same kinds.
						Else
							If last <> Null And Not last.EqualsType(e.exprType) Then
								Err "Auto array elements must have identical types"
							End If
							If Not TArrayType(ty).elemType.EqualsType(e.exprType) Then
								If (TObjectType(TArrayType(ty).elemType) = Null And TStringType(TArrayType(ty).elemType) = Null) Or (TObjectType(e.exprType) = Null And TStringType(e.exprType) = Null) Then
									Err "Unable to convert from "+src.ToString()+" to "+ty.ToString()+"."
								Else If TStringType(e.exprType) = Null And Not TObjectType(e.exprType).ExtendsType(TObjectType(TArrayType(ty).elemType)) Then
									Err "Unable to convert from "+src.ToString()+" to "+ty.ToString()+"."
								End If
							End If
						End If
						
						last = e.exprType
					Next
				End If
				
				exprType = ty
				Return Self
			End If
		End If

		'If TStringType(src) And TStringVarPtrType(ty) Then
		'	exprType = ty
		'	Return Self
		'End If

'		If TArrayType(src) And TPointerType(ty) Then
'			exprType = ty
'			Return expr
'		End If

		If TFunctionPtrType(ty) And TInvokeExpr(expr) Then
			' a function ptr to function ptr
			If Not TInvokeExpr(expr).invokedWithBraces Then
				src = New TFunctionPtrType
				TFunctionPtrType(src).func = TInvokeExpr(expr).decl
			
				' signatures should match
				If TFunctionPtrType(ty).func.EqualsFunc(TInvokeExpr(expr).decl) Then
					exprType = ty
					Return expr
				End If
			Else
				' return type should be function ptr?
				' TODO
				exprType = ty
				Return expr
			End If
		End If

		'If TIntType(ty) And Not IsPointerType(ty, 0, TType.T_POINTER) And IsPointerType(src, 0, TType.T_POINTER) Then
		'	exprType = ty
		'	If flags & CAST_EXPLICIT Then
		'		Return Self
		'	End If
		'	Return expr
		'End If

		' explicit cast to number
		If IsNumericType(ty) And IsPointerType(src, 0, TType.T_POINTER) Then
			If flags = CAST_EXPLICIT Then
				exprType = ty
				Return Self
			Else
				exprType = Null
			End If
		End If

'		If TPointerType(ty) And TIntType(src) Then
'			exprType = ty
'			Return expr
'		End If

'		If TIntType(ty) And TObjectType(src) Then
' DebugStop ' Bah woz ere
'			exprType = ty
'			Return expr
'		End If

		If TObjectType(src) And TNullDecl(TObjectType(src).classDecl) Then
			exprType = ty
			Return expr
		End If

		If TObjectType(src) And TObjectType(ty) And (ty._flags & TType.T_VAR) Then ' TODO : May be VARPTR instead?
			'exprType = NewPointerType(TType.T_BYTE)
			exprType = ty
			Return Self
		End If
		
		If TStringType(src) And ((src._flags & TType.T_CHAR_PTR) Or (src._flags & TType.T_SHORT_PTR)) And TStringType(ty) Then
			exprType = ty
			Return Self
		End If
		
		' cast from "some kind of object" array to Object[]
		If TArrayType(ty) And TArrayType(src)
			If (TObjectType(TArrayType(src).elemType) Or TStringType(TArrayType(src).elemType) Or TArrayType(TArrayType(src).elemType)) And TObjectType(TArrayType(ty).elemType) Then
				If TObjectType(TArrayType(ty).elemType).classDecl.ident = "Object" Then
					exprType = ty
					Return Self
				End If
			Else
				If TArrayType(ty).dims = TArrayType(src).dims Then
					exprType = ty
				End If
			End If
		End If
		
		If TArrayType(ty) And TObjectType(src) 
			If TObjectType(src).classDecl.ident = "___Array" Then
				exprType = ty
				Return expr
			Else If  TObjectType(src).classDecl.ident = "Object" Then
				exprType = ty
				Return Self
			End If
		End If

		If IsPointerType(ty, 0, TType.T_POINTER | TType.T_CHAR_PTR | TType.T_SHORT_PTR) Then
			If IsNumericType(src) And Not (src._flags & TType.T_VARPTR) Then
				'If IsPointerType(ty,0,TType.T_POINTER) Then
				'	exprType = TNumericType(src).ToPointer()
				'Else
					exprType = ty
				'End If
				Return Self
			Else If TNumericType(src) And (src._flags & TType.T_VARPTR) Then
				exprType = expr.exprType
			Else If TArrayType(src) Then
			
				' for functions and index access, use a new local variable
				If Not TVarExpr(expr) And Not TMemberVarExpr(expr) Then
					Local tmp:TLocalDecl=New TLocalDecl.Create( "", expr.exprType, expr,, True )
					tmp.Semant()
					Local v:TVarExpr = New TVarExpr.Create( tmp )
					expr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), v ).Semant()
				End If
			
				If TNumericType(TArrayType(src).elemType) Then
					exprType = TNumericType(TArrayType(src).elemType).ToPointer()
					Return Self
				Else
					' map arrays to byte ptr
					exprType = TType.MapToPointerType(New TByteType)
				End If
			Else If TStringType(src) Then
				exprType = ty
				Return Self
			End If
		End If
		
		If TStringType(src) And TStringType(ty) And (ty._flags & TType.T_VAR) Then
			exprType = ty
			Return Self
		End If

		If TVarPtrType(ty) Then
			If Not TVarExpr(expr) And Not TMemberVarExpr(expr) And Not (TStmtExpr(expr) And TIndexExpr(TStmtExpr(expr).expr)) Then
				If Not TIndexExpr(expr) Or (TIndexExpr(expr) And Not TVarExpr(TIndexExpr(expr).expr) And Not TMemberVarExpr(TIndexExpr(expr).expr))  Then
					Err "Subexpression for 'Ptr' must be a variable"
				End If
			End If
			exprType = src.Copy()
			exprType._flags :| TType.T_VARPTR
			ty = exprType
			Return Self
		End If
		
		If TFunctionPtrType(ty) And IsPointerType(src, 0, TType.T_POINTER) Then
			exprType = ty
			Return Self
		End If

		If TObjectType(ty) And TObjectType(src) And TObjectType(src).classdecl.IsInterface() And flags & CAST_EXPLICIT Then
			exprType = ty
			Return Self
		End If

		If Not exprType
			Err "Unable to convert from "+src.ToString()+" to "+ty.ToString()+"."
		EndIf

		If TConstExpr( expr ) Then

			Local ex:TExpr = EvalConst()
			If flags & CAST_EXPLICIT Then
				Return New TCastExpr.Create(exprType, ex, 1).Semant()
			Else
				Return ex
			End If
		End If
		
		Return Self
	End Method

	Method Eval$()
		Local val$=expr.Eval()
		If Not val Return val
		If TBoolType( exprType )
			If TIntegralType(expr.exprType)
				If Long( val ) Return "1"
				Return ""
			Else If TDecimalType( expr.exprType )
				If Double( val ) Return "1"
				Return ""
			Else If TStringType( expr.exprType )
				If val.Length Return "1"
				Return ""
			EndIf
		Else If TIntType( exprType )
			If TBoolType( expr.exprType )
				If val Return "1"
				Return "0"
			EndIf
			Return Int( val )
		Else If TUIntType( exprType )
			Return Long( val )
		Else If TShortType( exprType )
			Return Short( val )
		Else If TFloatType( exprType )
			Return Float( val )
		Else If TDoubleType( exprType )
			Return Double( val )
		Else If TLongType( exprType )
			Return Long( val )
		Else If TULongType( exprType )
			Return Long( val )
		Else If TSizeTType( exprType )
			Return Long( val )
		Else If TInt128Type( exprType )
			Return Long( val )
		Else If TFloat128Type( exprType )
			Return Float( val )
		Else If TDouble128Type( exprType )
			Return Float( val )
		Else If TFloat64Type( exprType )
			Return Float( val )
		Else If TStringType( exprType )
			Return String( val )
		Else If TByteType( exprType )
			Return Byte( val )
		Else If TWParamType( exprType )
			Return Long( val )
		Else If TLParamType( exprType )
			Return Long( val )
		Else If TObjectType( exprType )
			If TStringType( expr.exprType )
				Return val
			End If
		EndIf
		Return Super.Eval()
	End Method

	Method Trans$()
		Return _trans.TransCastExpr( Self )
	End Method

	Method ToString$()
		Local t$="TCastExpr(" + ty.ToString()
		If expr t:+","+expr.ToString()
		Return t+")"
	End Method

End Type

'op = '+', '-', '~'
Type TUnaryExpr Extends TExpr
	Field op$,expr:TExpr

	Method Create:TUnaryExpr( op$,expr:TExpr )
		Self.op=op
		Self.expr=expr
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TUnaryExpr.Create( op,CopyExpr(expr) )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		Select op
		Case "+","-"
			expr=expr.Semant()
			If Not TNumericType( expr.exprType ) Or IsPointerType(expr.exprType) Then
				Err expr.ToString()+" must be numeric for use with unary operator '"+op+"'"
			End If
			exprType=expr.exprType
			' Remove Var-ness, if required. "expr" will still be "Var"
			If exprType._flags & TType.T_VAR Then
				exprType = exprType.Copy()
				exprType._flags :~ TType.T_VAR
			End If
		Case "~~"
			expr=expr.SemantAndCast( New TIntType )
			exprType=New TIntType
		Case "not"
			expr=expr.SemantAndCast( New TBoolType,CAST_EXPLICIT )
			exprType=New TBoolType
		Default
			InternalErr
		End Select

		If TConstExpr( expr ) Return EvalConst()
		Return Self
	End Method

	Method Eval$()
		Local val$=expr.Eval()
		Select op
		Case "~~"
			Return ~Int( val )
		Case "+"
			Return val
		Case "-"
			If val.StartsWith( "-" ) Return val[1..]
			Return "-"+val
		Case "not"
			If val Return ""
			Return "1"
		End Select
		InternalErr
	End Method

	Method Trans$()
		Return _trans.TransUnaryExpr( Self )
	End Method

End Type

Type TBinaryExpr Extends TExpr
	Field op$
	Field lhs:TExpr
	Field rhs:TExpr

	Method Trans$()
		Return _trans.TransBinaryExpr( Self )
	End Method

	Method ToString$()
		Return "(" + lhs.ToString() + " " + op + " " + rhs.ToString() + ")"
	End Method

End Type

' * / + / & ~ | ^ shl shr
Type TBinaryMathExpr Extends TBinaryExpr

	Method Create:TBinaryMathExpr( op$,lhs:TExpr,rhs:TExpr )
		Self.op=op
		Self.lhs=lhs
		Self.rhs=rhs
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TBinaryMathExpr.Create( op,CopyExpr(lhs),CopyExpr(rhs) )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		lhs=lhs.Semant()

		If TIdentExpr(rhs) Then
			TIdentExpr(rhs).isRhs = True
		End If

		rhs=rhs.Semant()
		
		' operator overload?
		If TObjectType(lhs.exprType) Then
			Local args:TExpr[] = [rhs]
			Try
				Local decl:TFuncDecl = TFuncDecl(TObjectType(lhs.exprType).classDecl.FindFuncDecl(op, args,,,,True,SCOPE_CLASS_HEIRARCHY))
				If decl Then
					Return New TInvokeMemberExpr.Create( lhs, decl, args ).Semant()
				End If
			Catch error:String
				If error.StartsWith("Compile Error") Then
					Throw error
				Else
					Err "Operator " + op + " cannot be used with Objects."
				End If
			End Try
		End If

		Select op
		Case "&","~~","|","shl","shr"
			If TFloat128Type(lhs.exprType) Then
				exprType=New TInt128Type
			Else If TDouble128Type(lhs.exprType) Then
				exprType=New TInt128Type
			Else If TFloat64Type(lhs.exprType) Then
				exprType=New TInt128Type
			Else If TDoubleType(lhs.exprType) Then
				exprType=New TLongType
			Else If TFloatType(lhs.exprType) Then
				exprType=New TIntType
			Else If TUIntType(lhs.exprType) Then
				exprType=New TUIntType
			Else If TLongType(lhs.exprType) Then
				exprType=New TLongType
			Else If TULongType(lhs.exprType) Then
				exprType=New TULongType
			Else If TSizeTType(lhs.exprType) Then
				exprType=New TSizeTType
			Else If TWParamType(lhs.exprType) Then
				exprType=New TWParamType
			Else If TLParamType(lhs.exprType) Then
				exprType=New TLParamType
			Else
				exprType=New TIntType
			End If
		Case "^"
			exprType=New TDoubleType
		Default
			exprType=BalanceTypes( lhs.exprType,rhs.exprType )
			If TStringType( exprType )
				If op<>"+"
					Err "Illegal string operator."
				EndIf
			Else If TVoidType( exprType ) Then
				Err "Illegal operation on a void expression."
			Else If Not TNumericType( exprType ) And Not IsPointerType( exprType, 0, TType.T_POINTER ) And Not TArrayType( exprType ) And Not TBoolType( exprType )
				Err "Illegal expression type."
			Else If IsPointerType( exprType, 0, TType.T_POINTER ) And op <> "+" And op <> "-" Then
				Err "Illegal expression type."
			Else If IsPointerType( lhs.exprType, 0, TType.T_POINTER ) And IsPointerType( rhs.exprType, 0, TType.T_POINTER ) And op <> "-" Then
				Err "Illegal expression type."
			EndIf
		End Select

		If (op = "+" Or op = "-") And IsPointerType(exprType, 0, TType.T_POINTER) And TNumericType(lhs.exprType) Then
			' with pointer addition we don't cast the numeric to a pointer
		Else
			lhs=lhs.Cast( exprType )
		End If
		
		If (op = "+" Or op = "-") And IsPointerType(exprType, 0, TType.T_POINTER) And TNumericType(rhs.exprType) Then
			' with pointer addition we don't cast the numeric to a pointer
		Else
			rhs=rhs.Cast( exprType )
		End If
		
		If IsPointerType( lhs.exprType, 0, TType.T_POINTER ) And IsPointerType( rhs.exprType, 0, TType.T_POINTER ) And op = "-" Then
			exprType = New TIntType
		End If

		If TConstExpr( lhs ) And TConstExpr( rhs ) Return EvalConst()

		Return Self
	End Method

	Method Eval$()
		Local lhs$=Self.lhs.Eval()
		Local rhs$=Self.rhs.Eval()
		If TIntType( exprType )
			Local x:Int=Int(lhs),y:Int=Int(rhs)
			Select op
			Case "^" Return x^y
			Case "*" Return x*y
			Case "/" Return x/y
			Case "mod" Return x Mod y
			Case "shl" Return x Shl y
			Case "shr" Return x Shr y
			Case "+" Return x + y
			Case "-" Return x - y
			Case "&" Return x & y
			Case "~~" Return x ~ y
			Case "|" Return x | y
			End Select
		Else If TLongType( exprType ) Or TSizeTType(exprType) Or TUIntType(exprType) Or TULongType(exprType) Or TInt128Type(exprType) Or TWParamType(exprType) Or TLParamType(exprType) 
			Local x:Long=Long(lhs),y:Long=Long(rhs)
			Select op
			Case "^" Return x^y
			Case "*" Return x*y
			Case "/" Return x/y
			Case "mod" Return x Mod y
			Case "shl" Return x Shl y
			Case "shr" Return x Shr y
			Case "+" Return x + y
			Case "-" Return x - y
			Case "&" Return x & y
			Case "~~" Return x ~ y
			Case "|" Return x | y
			End Select
		Else If TFloatType( exprType )
			Local x:Float=Float(lhs),y:Float=Float(rhs)
			Select op
			Case "^" Return x^y
			Case "*" Return x * y
			Case "/" Return x / y
			Case "mod" Return x Mod y
			Case "+" Return x + y
			Case "-" Return x - y
			End Select
		Else If TDoubleType( exprType ) Or TFloat128Type(exprType) Or TDouble128Type(exprType) Or TFloat64Type(exprType)
			Local x:Double=Double(lhs),y:Double=Double(rhs)
			Select op
			Case "^" Return x^y
			Case "*" Return x * y
			Case "/" Return x / y
			Case "mod" Return x Mod y
			Case "+" Return x + y
			Case "-" Return x - y
			End Select
		Else If TStringType( exprType )
			Select op
			Case "+" 
				_appInstance.removeStringConst(lhs)
				_appInstance.removeStringConst(rhs)
				Return lhs+rhs
			End Select
		EndIf
		InternalErr
	End Method

End Type

'=,<>,<,<=,>,>=
Type TBinaryCompareExpr Extends TBinaryExpr
	Field ty:TType

	Method Create:TBinaryCompareExpr( op$,lhs:TExpr,rhs:TExpr )
		Self.op=op
		Self.lhs=lhs
		Self.rhs=rhs
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TBinaryCompareExpr.Create( op,CopyExpr(lhs),CopyExpr(rhs) )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		lhs=lhs.Semant()
		rhs=rhs.Semant()

		' operator overload?
		If TObjectType(lhs.exprType) Then
			Local args:TExpr[] = [rhs]
			Try
				Local decl:TFuncDecl = TFuncDecl(TObjectType(lhs.exprType).classDecl.FindFuncDecl(op, args,,,,True,SCOPE_CLASS_HEIRARCHY))
				If decl Then
					Return New TInvokeMemberExpr.Create( lhs, decl, args ).Semant()
				End If
			Catch error:String
				' no overload, continue...
			End Try
		End If


		ty=BalanceTypes( lhs.exprType,rhs.exprType )

		lhs=lhs.Cast( ty )
		rhs=rhs.Cast( ty )

		exprType=New TBoolType

		If TConstExpr( lhs ) And TConstExpr( rhs ) Return EvalConst()

		Return Self
	End Method

	Method Eval$()
		Local r:Int=-1
		If TBoolType( ty )
			Local lhs:Int=Int(Self.lhs.Eval())
			Local rhs:Int=Int(Self.rhs.Eval())
			Select op
			Case "="  r=(lhs= rhs)
			Case "<>" r=(lhs<>rhs)
			End Select
		Else If TIntType( ty )
			Local lhs:Int=Int( Self.lhs.Eval() )
			Local rhs:Int=Int( Self.rhs.Eval() )
			Select op
			Case "="  r=(lhs= rhs)
			Case "<>" r=(lhs<>rhs)
			Case "<"  r=(lhs< rhs)
			Case "<=", "=<" r=(lhs<=rhs)
			Case ">"  r=(lhs> rhs)
			Case ">=", "=>" r=(lhs>=rhs)
			End Select
		Else If TLongType( ty ) Or TSizeTType( ty ) Or TUIntType( ty ) Or TULongType( ty ) Or TInt128Type(ty) Or TWParamType(ty) Or TLParamType(ty)
			Local lhs:Long=Long( Self.lhs.Eval() )
			Local rhs:Long=Long( Self.rhs.Eval() )
			Select op
			Case "="  r=(lhs= rhs)
			Case "<>" r=(lhs<>rhs)
			Case "<"  r=(lhs< rhs)
			Case "<=", "=<" r=(lhs<=rhs)
			Case ">"  r=(lhs> rhs)
			Case ">=", "=>" r=(lhs>=rhs)
			End Select
		Else If TFloatType( ty )
			Local lhs:Float=Float( Self.lhs.Eval() )
			Local rhs:Float=Float( Self.rhs.Eval() )
			Select op
			Case "="  r=(lhs= rhs)
			Case "<>" r=(lhs<>rhs)
			Case "<"  r=(lhs< rhs)
			Case "<=", "=<" r=(lhs<=rhs)
			Case ">"  r=(lhs> rhs)
			Case ">=", "=>" r=(lhs>=rhs)
			End Select
		Else If TDoubleType( ty ) Or TFloat128Type(ty) Or TDouble128Type(ty) Or TFloat64Type(ty)
			Local lhs:Double=Double( Self.lhs.Eval() )
			Local rhs:Double=Double( Self.rhs.Eval() )
			Select op
			Case "="  r=(lhs= rhs)
			Case "<>" r=(lhs<>rhs)
			Case "<"  r=(lhs< rhs)
			Case "<=", "=<" r=(lhs<=rhs)
			Case ">"  r=(lhs> rhs)
			Case ">=", "=>" r=(lhs>=rhs)
			End Select
		Else If TStringType( ty )
			Local lhs:String=String( Self.lhs.Eval() )
			Local rhs:String=String( Self.rhs.Eval() )
			Select op
			Case "="  r=(lhs= rhs)
			Case "<>" r=(lhs<>rhs)
			Case "<"  r=(lhs< rhs)
			Case "<=", "=<" r=(lhs<=rhs)
			Case ">"  r=(lhs> rhs)
			Case ">=", "=>" r=(lhs>=rhs)
			End Select
		EndIf
		If r=1 Return "1"
		If r=0 Return ""
		InternalErr
	End Method
End Type

'and, or
Type TBinaryLogicExpr Extends TBinaryExpr

	Method Create:TBinaryLogicExpr( op$,lhs:TExpr,rhs:TExpr )
		Self.op=op
		Self.lhs=lhs
		Self.rhs=rhs
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TBinaryLogicExpr.Create( op,CopyExpr(lhs),CopyExpr(rhs) )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		lhs=lhs.SemantAndCast( New TBoolType,CAST_EXPLICIT )
		rhs=rhs.SemantAndCast( New TBoolType,CAST_EXPLICIT )

		exprType=New TBoolType

		If TConstExpr( lhs ) And TConstExpr( rhs ) Return EvalConst()

		Return Self
	End Method

	Method Eval$()
		Select op
		Case "and" If lhs.Eval() And rhs.Eval() Return "1" Else Return ""
		Case "or"  If lhs.Eval() Or rhs.Eval() Return "1" Else Return ""
		End Select
		InternalErr
	End Method
End Type

Type TIndexExpr Extends TExpr
	Field expr:TExpr
	Field index:TExpr[]

	Method Create:TIndexExpr( expr:TExpr,index:TExpr[] )
		Self.expr=expr
		Self.index=index
		Return Self
	End Method

	Method Copy:TExpr()
		If exprType Return Self
		
		Local ind:TExpr[]
		For Local i:Int = 0 Until index.length
			ind = ind + [CopyExpr(index[i])]
		Next
		Return New TIndexExpr.Create( CopyExpr(expr),ind )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()

		' for functions and index access, use a new local variable
		If Not TVarExpr(expr) And Not TMemberVarExpr(expr) Then
			Local tmp:TLocalDecl=New TLocalDecl.Create( "", TType.MapVarPointerToPointerType(expr.exprType.Copy()), expr,, True )
			tmp.Semant()
			Local v:TVarExpr = New TVarExpr.Create( tmp )
			expr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), v ).Semant()
		End If

		For Local i:Int = 0 Until index.length
			index[i]=index[i].SemantAndCast( New TUIntType, True )
		Next

		If TStringType( expr.exprType )
			exprType=New TIntType
			If index.length > 1 Then
				Err "Illegal subexpression for string index"
			End If
		Else If TArrayType( expr.exprType )
			exprType= TArrayType( expr.exprType ).elemType

			If TArrayType( expr.exprType ).dims > 1 Then

				' a multi-dimensional array of arrays is slightly more complex
				If TArrayType(exprType) Then

				'	Local tmpArr:TLocalDecl=New TLocalDecl.Create( "", NewPointerType(TType.T_ARRAY), expr )
				'	Local stmt:TExpr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), Self ).Semant()

					Local sizeExpr:TExpr = New TArraySizeExpr.Create(expr, Null, index)
					index = [sizeExpr]
					Local tmp:TLocalDecl=New TLocalDecl.Create( "", NewPointerType(TType.T_UINT), sizeExpr,,True )
					TArraySizeExpr(sizeExpr).val = tmp
					Local stmt:TExpr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), Self ).Semant()
					stmt.exprType = exprType

					Return stmt
				Else
					Local sizeExpr:TExpr = New TArraySizeExpr.Create(expr, Null, index).Semant()
					index = [sizeExpr]
					Local tmp:TLocalDecl=New TLocalDecl.Create( "", NewPointerType(TType.T_UINT), sizeExpr,,True )
					TArraySizeExpr(sizeExpr).val = tmp
					Local stmt:TExpr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), Self ).Semant()
					stmt.exprType = exprType
					Return stmt
				End If
			End If
			'If TObjectType(exprType) And Not TStringType(exprType) And Not TArrayType(exprType) Then
			'	Local tmp:TLocalDecl=New TLocalDecl.Create( "", exprType,expr )
			'	Local stmt:TExpr = New TStmtExpr.Create( New TDeclStmt.Create( tmp ),New TVarExpr.Create( tmp ) ).Semant()
			'	stmt.exprType = exprType
			'	Return stmt
			'End If
		Else If TNumericType(expr.exprType) And IsPointerType( expr.exprType, 0 , TType.T_POINTER | TType.T_VARPTR)' And Not TFunctionPtrType( expr.exprType )
			exprType=TType.MapPointerToPrim(TNumericType(expr.exprType))
			'exprType=TType.intType
		Else If TObjectType(expr.exprType) And TObjectType(expr.exprType).classDecl.IsStruct() And IsPointerType( expr.exprType, 0 , TType.T_POINTER | TType.T_VARPTR)' And Not TFunctionPtrType( expr.exprType )
			exprType = expr.exprType
		Else
			Err "Only strings, arrays and pointers may be indexed."
		EndIf

		Return Self
	End Method

	Method SemantSet:TExpr( op$,rhs:TExpr )
		Return Semant()
		'Return Self
	End Method
	
	Method SemantFunc:TExpr( args:TExpr[] , throwError:Int = True, funcCall:Int = False )
		Local ex:TExpr = Semant()
		
		If TArrayType( expr.exprType ) And TFunctionPtrType(exprType) Then
			exprType = TFunctionPtrType(exprType).func.retType
		End If
		
		Return ex
	End Method


	Method Trans$()
		Return _trans.TransIndexExpr( Self )
	End Method

	Method TransVar$()
		Return _trans.TransIndexExpr( Self )
	End Method

	Method ToString$()
		Return "<TIndexExpr<"+ expr.ToString() +"[" + index[0].ToString() + "]>>"
	End Method
	
End Type

Type TSliceExpr Extends TExpr
	Field expr:TExpr
	Field from:TExpr
	Field term:TExpr

	Method Create:TSliceExpr( expr:TExpr,from:TExpr,term:TExpr )
		Self.expr=expr
		Self.from=from
		Self.term=term
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TSliceExpr.Create( CopyExpr(expr),CopyExpr(from),CopyExpr(term) )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()
		If (TArrayType( expr.exprType ) And TArrayType( expr.exprType ).dims = 1) Or TStringType( expr.exprType )
			If from from=from.SemantAndCast( New TIntType )
			If term term=term.SemantAndCast( New TIntType )

			exprType=expr.exprType
			' remove var-ness
			If exprType._flags & TType.T_VAR Then
				exprType = exprType.Copy()
				exprType._flags :~ TType.T_VAR
			End If
		Else
			Err "Slices can only be used with strings or one dimensional arrays"
		EndIf

'		If TConstExpr( expr ) And TConstExpr( from ) And TConstExpr( term ) Return EvalConst()

		Return Self
	End Method

	Method Eval$()
		Local from:Int=Int( Self.from.Eval() )
		Local term:Int=Int( Self.term.Eval() )
		If TStringType( expr.exprType )
			Return expr.Eval()[ from..term ]
		Else If TArrayType( expr.exprType )
			Todo
		EndIf
	End Method

	Method Trans$()
		Return _trans.TransSliceExpr( Self )
	End Method
End Type

Type TArrayExpr Extends TExpr
	Field exprs:TExpr[]
	
	Field toType:TType

	Method Create:TArrayExpr( exprs:TExpr[] )
		Self.exprs=exprs
		Return Self
	End Method

	Method Copy:TExpr()
		Local expr:TArrayExpr = New TArrayExpr.Create( CopyArgs(exprs) )
		expr.toType = toType
		Return expr
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		If TIdentExpr(exprs[0]) Then
			TIdentExpr(exprs[0]).isRhs = True
		End If
		exprs[0]=exprs[0].Semant()
		Local ty:TType=exprs[0].exprType
		' convert from varptr to ptr if required
		ty = TType.MapVarPointerToPointerType(ty.Copy())
		
		If TInvokeExpr(exprs[0]) And Not TInvokeExpr(exprs[0]).invokedWithBraces Then
			ty = New TFunctionPtrType
			Local cp:TDecl = TInvokeExpr(exprs[0]).decl
			TInvokeExpr(exprs[0]).decl = TFuncDecl(TInvokeExpr(exprs[0]).decl.Copy())
			TInvokeExpr(exprs[0]).decl.actual = cp
			TInvokeExpr(exprs[0]).decl.attrs :| FUNC_PTR
			TFunctionPtrType(ty).func = TInvokeExpr(exprs[0]).decl

			For Local i:Int=1 Until exprs.Length
				If TIdentExpr(exprs[1]) Then
					TIdentExpr(exprs[1]).isRhs = True
				End If
				exprs[i]=exprs[i].Semant()
				
				If TInvokeExpr(exprs[i]) And Not TInvokeExpr(exprs[i]).invokedWithBraces
					cp = TInvokeExpr(exprs[i]).decl
					
					TInvokeExpr(exprs[i]).decl = TFuncDecl(TInvokeExpr(exprs[i]).decl.Copy())
					TInvokeExpr(exprs[i]).decl.actual = cp
					TInvokeExpr(exprs[i]).decl.attrs :| FUNC_PTR
					
					ty=BalanceTypes( ty, New TFunctionPtrType )
				Else
					ty=BalanceTypes( ty,exprs[i].exprType )
				End If
			Next
		Else
			For Local i:Int=1 Until exprs.Length
				exprs[i]=exprs[i].Semant()
				ty=BalanceTypes( ty,exprs[i].exprType )
			Next
		End If

		Local comp:Int = True
		Local last:TType
		For Local i:Int=0 Until exprs.Length

			Local expr:TExpr = exprs[i]

			' don't cast null types
			If TNullType(expr.exprType) <> Null Then
				Err "Auto array element has no type"
			End If

			Local ety:TType = expr.exprType
			If TBoolType(ety) Then
				ety = New TIntType
			End If
			
			If last <> Null And Not last.EqualsType(ety) Then
				If (Not TConstExpr(expr) And Not IsNumericType(ety)) Or (TConstExpr(expr) And IsNumericType(ety) And Not TConstExpr(expr).CompatibleWithType(ty)) Then
					Err "Auto array elements must have identical types : Index " + i
				End If
			End If
			
			If toType And TConstExpr(expr) And Not TConstExpr(expr).CompatibleWithType(toType) Then
				comp = False
			End If
		
			last = ety
			
			exprs[i]=expr.Cast( ty )
		Next

		If comp And toType Then
			exprType=New TArrayType.Create( toType )
		Else
			exprType=New TArrayType.Create( ty )
		End If
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransArrayExpr( Self )
	End Method

End Type

Type TArraySizeExpr Extends TExpr

	Field expr:TExpr
	Field val:TDecl
	Field index:TExpr[]

	Method Create:TArraySizeExpr( expr:TExpr, val:TDecl, index:TExpr[] )
		Self.expr=expr
		Self.val=val
		Self.index=index
		Return Self
	End Method

	Method Copy:TExpr()
		Local ind:TExpr[]
		For Local i:Int = 0 Until index.length
			ind = ind + [CopyExpr(index[i])]
		Next
		Return New TArraySizeExpr.Create( CopyExpr(expr), val, ind )
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()
		
		For Local i:Int = 0 Until index.length
			index[i]=index[i].SemantAndCast( New TUIntType )
		Next
		
		exprType=NewPointerType(TType.T_UINT)
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransArraySizeExpr( Self )
	End Method

	Method ToString$()
		Return expr.ToString() + ".Size"
	End Method

End Type

Type TIdentTypeExpr Extends TExpr
	Field cdecl:TClassDecl

	Method Create:TIdentTypeExpr( ty:TType )
		Self.exprType=ty
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TIdentTypeExpr.Create( exprType )
	End Method

	Method _Semant()
		If cdecl Return
		exprType=exprType.Semant()
		If TArrayType(exprType) And TObjectType(TArrayType(exprType).elemType) Then
			cdecl=TObjectType(TArrayType(exprType).elemType).classDecl
		Else
			cdecl=exprType.GetClass()
		End If
		If Not cdecl InternalErr
	End Method

	Method Semant:TExpr()
		_Semant
		Err "Expression can't be used in this way"
	End Method

	Method SemantFunc:TExpr( args:TExpr[] , throwError:Int = True, funcCall:Int = False )
		_Semant
		If args.Length=1 And args[0] Then
			If TArrayType(exprType) Then
				Return args[0].Cast( exprType,CAST_EXPLICIT )
			Else
				Return args[0].Cast( cdecl.objectType,CAST_EXPLICIT )
			End If
		End If
		Err "Illegal number of arguments for type conversion"
	End Method

	Method SemantScope:TScopeDecl()
		_Semant
		Return cdecl
	End	Method

	Method Trans$()
		Return _trans.TransIdentTypeExpr( Self )
	End Method

End Type

Type TIdentExpr Extends TExpr
	Field ident$
	Field expr:TExpr
	Field scope:TScopeDecl
	Field static:Int
	Field isArg:Int
	Field isRhs:Int
	Field fixedScope:Int
	
	Field _identLower:String

	Method IdentLower:String()
		If Not _identLower Then
			_identLower = ident.ToLower()
		End If
		Return _identLower
	End Method

	Method Create:TIdentExpr( ident$,expr:TExpr=Null, _identLower:String = Null )
		Self.ident=ident
		Self.expr=expr
		Self._identLower = _identLower
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TIdentExpr.Create( ident,CopyExpr(expr), _identLower )
	End Method

	Method ToString$()
		Local t$="TIdentExpr(~q"+ident+"~q"
		If expr t:+","+expr.ToString()
		Return t+")"
	End Method

	Method _Semant()

		If scope Return

		If expr Then
			scope=expr.SemantScope()
			If scope
				static=True
			Else
				expr=expr.Semant()
				scope=expr.exprType.GetClass()
				If Not scope Then
					Err "Expression has no scope"
				End If
			End If
			fixedScope = True
		Else
			scope=_env
			' determines if access is via static (like Function, or via a Type)
			' However, for Field->Field access this is not strictly true.
			If _env.FuncScope()=Null
				static = TModuleDecl(_env) = Null
			Else
				static=_env.FuncScope().IsStatic()
			End If
		End If

	End Method

	Method IdentScope:TScopeDecl()
		If Not expr Return _env

		Local scope:TScopeDecl=expr.SemantScope()
		If scope
			expr=Null
		Else
			expr=expr.Semant()
			scope=expr.exprType.GetClass()
			If Not scope Err "Expression has no scope."
		EndIf
		Return scope
	End Method

	Method IdentErr( errorDetails:String = Null )
		If errorDetails Then
			Err errorDetails
		Else
			Err "Identifier '"+ident+"' not found."
		End If
	End Method

	Method IdentNotFound()
	End Method

	Method IsVar()
		InternalErr
	End Method

	Method Semant:TExpr()
		Return SemantSet( "",Null )
	End Method

	Method SemantSet:TExpr( op$,rhs:TExpr )
		_Semant

		'Local scope:TScopeDecl=IdentScope()
		Local vdecl:TValDecl=scope.FindValDecl( IdentLower(), static )
		
		If TLocalDecl( vdecl )
			' local variable should (at least) be in the same function scope.
			If vdecl.FuncScope() <> scope.FuncScope() Then
				' or the local can be in localmain..
				If TModuleDecl(scope) And vdecl.FuncScope() And vdecl.FuncScope().ident = "__LocalMain" Then
					' ok
				Else
					vdecl = Null
				End If
			End If
		End If
		
		If vdecl And fixedScope And static Then
			If TClassDecl(vdecl.scope) And TClassDecl(scope) Then
				If Not TClassDecl(scope).ExtendsClass(TClassDecl(vdecl.scope)) Then
					vdecl = Null
				End If
			Else
				If vdecl.scope <> scope Then
					vdecl = Null
				End If
			End If
		End If
		
		If vdecl

			If TConstDecl( vdecl )
'				If rhs Err "Constant '"+ident+"' cannot be modified."
'				Return New TConstExpr.Create( vdecl.ty,TConstDecl( vdecl ).value ).Semant()
				If rhs Err "Constant '"+ident+"' cannot be modified."
				Local cexpr:TConstExpr =New TConstExpr.Create( vdecl.ty,TConstDecl( vdecl ).value )
				If Not static And (TInvokeExpr( expr ) Or TInvokeMemberExpr( expr )) Return New TStmtExpr.Create( New TExprStmt.Create( expr ),cexpr ).Semant()
				Return cexpr.Semant()

			Else If TFieldDecl( vdecl ) 
				If static Err "Field '"+ident+"' cannot be accessed from here."
				If expr Return New TMemberVarExpr.Create( expr,TVarDecl( vdecl ) ).Semant()
'				If expr Return New TMemberVarExpr.Create( expr,TVarDecl( vdecl ) ).Semant()
'				If scope<>_env Or Not _env.FuncScope() Or _env.FuncScope().IsStatic() Err "Field '"+ident+"' cannot be accessed from here."

			EndIf

			Return New TVarExpr.Create( TVarDecl( vdecl ) ).Semant()
		EndIf

		If op And op<>"="

			Local fdecl:TFuncDecl=scope.FindFuncDecl( IdentLower(),,,,,,SCOPE_ALL )
			If Not fdecl IdentErr

			If _env.ModuleScope().IsStrict() And Not fdecl.IsProperty() Err "Identifier '"+ident+"' cannot be used in this way."

			Local lhs:TExpr

			If fdecl.IsStatic() Or (scope=_env And Not _env.FuncScope().IsStatic())
				lhs=New TInvokeExpr.Create( fdecl )
			Else If expr
				Local tmp:TLocalDecl=New TLocalDecl.Create( "",Null,expr,, True )
				lhs=New TInvokeMemberExpr.Create( New TVarExpr.Create( tmp ),fdecl )
				lhs=New TStmtExpr.Create( New TDeclStmt.Create( tmp ),lhs )
			Else
				Return Null
			EndIf

			Local bop$=op[..1]
			Select bop
			Case "*","/","shl","shr","+","-","&","|","~~"
				rhs=New TBinaryMathExpr.Create( bop,lhs,rhs )
			Default
				InternalErr
			End Select
			rhs=rhs.Semant()
		EndIf

		Local args:TExpr[]
		If rhs args=[rhs]

		Local fdecl:TFuncDecl
		
		Try
			fdecl=scope.FindFuncDecl( IdentLower(),args, , isArg, True,True,SCOPE_ALL )
		Catch errorMessage:String
			If errorMessage.StartsWith("Compile Error") Then
				Throw errorMessage
			End If
		End Try

		If fdecl
			If _env.ModuleScope().IsStrict() And Not fdecl.IsProperty() And Not isArg And Not fdecl.maybeFunctionPtr Err "Identifier '"+ident+"' cannot be used in this way."

			fdecl.maybeFunctionPtr = False
			
			If Not fdecl.IsStatic()
				If expr Return New TInvokeMemberExpr.Create( expr,fdecl,args, False ).Semant()
				If scope<>_env Or Not _env.FuncScope() Or _env.FuncScope().IsStatic() Err "Method '"+ident+"' cannot be accessed from here."
			EndIf

			Return New TInvokeExpr.Create( fdecl,args, False, isArg, isRhs ).Semant()
		End If
		
		' maybe it's a classdecl?
		Local cdecl:TClassDecl = TClassDecl(scope.FindDecl(IdentLower()))
		
		If cdecl Then
			Local e:TIdentTypeExpr = New TIdentTypeExpr.Create(cdecl.objectType)
			e.cdecl = cdecl
			Return e
		End If

		Local loopLabel:String = "#" + IdentLower()

		' maybe it's a loop label?
		Local stmt:TLoopStmt = TLoopStmt(scope.FindLoop(loopLabel))
		
		If stmt Then
			Return New TLoopLabelExpr.Create(stmt)
		End If
		
		' maybe it's a data label?
		Local ddecl:TDefDataDecl = TDefDataDecl(_appInstance.FindDataLabel(loopLabel))
		
		If ddecl Then
			Return New TDataLabelExpr.Create(ddecl)
		End If
		
		IdentErr
	End Method

	Method SemantFunc:TExpr( args:TExpr[], throwError:Int = True, funcCall:Int = False )

		_Semant

		Local errorDetails:String
		Local nearestScopeError:String

		'Local scope:TScopeDecl=IdentScope()
		Local initialScope:Int = SCOPE_ALL
		If scope And TClassDecl(scope) Then
			initialScope = SCOPE_CLASS_HEIRARCHY
		End If
		
		Local fdecl:TFuncDecl
		Try
			fdecl=scope.FindFuncDecl( IdentLower(),args,,,,True,initialScope )
'			Local decl:Object=scope.FindFuncDecl( IdentLower(),args,,,,True,SCOPE_ALL )
'			If decl Then
'				If TFuncDecl(decl) Then
'					fdecl = TFuncDecl(decl)
'				Else If TFuncDeclList(decl) Then
'					If Not TFuncDeclList(decl).IsEmpty() Then
'						fdecl = TFuncDecl(TFuncDeclList(decl).First())
'					End If
'				End If
'			End If
		Catch errorMessage:String
			If errorMessage.StartsWith("Compile Error") Then
				Throw errorMessage
			Else
				' couldn't find an exact match, look elsewhere
				errorDetails = errorMessage
				If errorMessage.StartsWith("Unable") Then
					nearestScopeError = errorDetails
				End If
			End If
		End Try

		' if our scope is static, but the scope of the found function/method is not
		' then we should ignore it and continue looking higher up the scope stack.
		If static And fdecl And Not fdecl.IsStatic() Then
			Local scope2:TScopeDecl = fdecl.scope
			
			fdecl = Null
			
			' if fdecl was a method, this would be the Type's scope (ie. file/module)
			If scope2.scope Then
				fdecl = scope2.scope.FindFuncDecl( IdentLower(),args,,,,,SCOPE_CLASS_HEIRARCHY )
			End If
		Else If static And Not fdecl And Not fixedScope Then
			If _env.classScope() Then
				' try searching from our class scope
				'fdecl = _env.classScope().FindFuncDecl( IdentLower(),args )

				If Not fdecl Then				
					' try searching from our class parent scope
					Try
						fdecl = _env.classScope().scope.FindFuncDecl( IdentLower(),args,,,,True,SCOPE_ALL )
					Catch errorMessage:String
						If errorMessage.StartsWith("Compile Error") Then
							Throw errorMessage
						Else
							' couldn't find an exact match, look elsewhere
							errorDetails = errorMessage
							If Not nearestScopeError And errorDetails.StartsWith("Unable") Then
								nearestScopeError = errorDetails
							End If
						End If
					End Try
				End If
			Else If _env.ModuleScope() Then ' bah
				' finally, try searching from our module scope
				Try
					fdecl = _env.ModuleScope().FindFuncDecl( IdentLower(),args,,,,True,SCOPE_ALL )
				Catch errorMessage:String
					If errorMessage.StartsWith("Compile Error") Then
						Throw errorMessage
					Else
						' couldn't find an exact match, look elsewhere
						errorDetails = errorMessage
						If Not nearestScopeError And errorDetails.StartsWith("Unable") Then
							nearestScopeError = errorDetails
						End If
					End If
				End Try
			End If
		End If

		' couldn't find it? try a global search
		If Not fdecl And Not fixedScope Then
			For Local mdecl:TModuleDecl = EachIn _appInstance.globalImports.Values()
				Try
					fdecl=mdecl.FindFuncDecl( IdentLower(), args,,,,True,SCOPE_ALL )
				Catch errorMessage:String
					If errorMessage.StartsWith("Compile Error") Then
						Throw errorMessage
					Else
						' couldn't find an exact match, look elsewhere
						errorDetails = errorMessage
						If Not nearestScopeError And errorDetails.StartsWith("Unable") Then
							nearestScopeError = errorDetails
						End If
					End If
				End Try
				If fdecl Exit
			Next
		End If

		If fdecl
			If Not fdecl.IsStatic()
				If static Err "Method '"+ident+"' cannot be accessed from here."
				If expr Return New TInvokeMemberExpr.Create( expr,fdecl,args ).Semant()
				'If scope<>_env Or _env.FuncScope().IsStatic() Err "Method '"+ident+"' cannot be accessed from here."
			EndIf
			If expr And Not static Then
				Return New TInvokeMemberExpr.Create( expr,fdecl,args ).Semant()
			Else
				Return New TInvokeExpr.Create( fdecl,args, funcCall ).Semant()
			End If
		EndIf

		'If args.Length=1 And args[0] And TObjectType( args[0].exprType )
		'	Local cdecl:TClassDecl=TClassDecl( scope.FindScopeDecl( ident ) )
		'	If cdecl Return args[0].Cast( New TObjectType.Create(cdecl),CAST_EXPLICIT )
		'EndIf

		Local ty:TType=scope.FindType( IdentLower(),Null )
		If ty Then
			If args.Length=1 And args[0] Return args[0].Cast( ty,CAST_EXPLICIT )
			Err "Illegal number of arguments for type conversion"
		End If

		If throwError Then
			If nearestScopeError Then
				IdentErr(nearestScopeError)
			Else
				IdentErr(errorDetails)
			End If
		End If
	End Method

	Method SemantScope:TScopeDecl()
		If Not expr Return _env.FindScopeDecl( IdentLower() )
		Local scope:TScopeDecl=expr.SemantScope()

		' If scope is a namespace, then we are a module. Look up the module id and return it as the real scope.
		If TNamespaceDecl(scope) Then
			Local mdecl:TModuleDecl=TModuleDecl(scope.FindDecl(scope.IdentLower() + "." + IdentLower()))
			If mdecl Then
				Return mdecl
			End If
		End If

		If scope Return scope.FindScopeDecl( IdentLower() )
	End Method

'	Method Trans$()
'		Return _trans.TransIdentExpr( Self )
'	End Method

End Type

Type TBuiltinExpr Extends TExpr

	Field id:String
	Field expr:TExpr

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()
		exprType=expr.exprType
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransBuiltinExpr( Self )
	End Method

End Type

Type TLenExpr Extends TBuiltinExpr

	Method Create:TLenExpr( expr:TExpr )
		Self.id="len"
		Self.expr=expr
		Return Self
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()

		' anything other than a string or array will become "1", and
		' return a length of 1 accordingly.
		If Not TStringType(expr.exprType) And Not TArrayType(expr.exprType) Then
			expr = New TConstExpr.Create( New TIntType, 1 ).Semant()
			'this is not useful for numerics
			'expr = New TConstExpr.Create( TType.stringType, "1" ).Semant()
			_appInstance.mapStringConsts(TConstExpr(expr).value)
		End If

		exprType=New TIntType
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TLenExpr.Create( CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TLenExpr("+expr.ToString()+")"
	End Method

End Type

Type TAbsExpr Extends TBuiltinExpr

	Method Create:TAbsExpr( expr:TExpr )
		Self.id="abs"
		Self.expr=expr
		Return Self
	End Method

	Method Semant:TExpr()

		If exprType Return Self

		expr=expr.Semant()

		If TNumericType(expr.exprType) Or TBoolType(expr.exprType) Then

			If TInt128Type(expr.exprType) Err "'Abs' does not support Int128 type. Use specific intrinsic function instead."
			If TFloat64Type(expr.exprType) Err "'Abs' does not support Float64 type. Use specific intrinsic function instead."
			If TFloat128Type(expr.exprType) Err "'Abs' does not support Float128 type. Use specific intrinsic function instead."
			If TDouble128Type(expr.exprType) Err "'Abs' does not support Double128 type. Use specific intrinsic function instead."

			If TIntType(expr.exprType) Or TByteType(expr.exprType) Or TShortType(expr.exprType) Then
				exprType=New TIntType
			Else
				exprType=expr.exprType
			End If
		Else
			Err "Subexpression for 'Abs' must be of numeric type"
		End If

		Return Self
	End Method

	Method Copy:TExpr()
		Return New TAbsExpr.Create( CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TAbsExpr("+expr.ToString()+")"
	End Method

End Type

Type TAscExpr Extends TBuiltinExpr

	Method Create:TAscExpr( expr:TExpr )
		Self.id="asc"
		Self.expr=expr
		Return Self
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		If TConstExpr(expr) Then
			Local cexpr:TExpr = New TConstExpr.Create(New TIntType, Asc(TConstExpr(expr).value))
			_appInstance.removeStringConst(TConstExpr(expr).value)
			cexpr.Semant()
			Return cexpr
		End If
		
		expr = expr.SemantAndCast( New TStringType )
		exprType = New TIntType
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TAscExpr.Create( CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TAscExpr("+expr.ToString()+")"
	End Method

End Type

Type TSgnExpr Extends TBuiltinExpr

	Method Create:TSgnExpr( expr:TExpr )
		Self.id="sgn"
		Self.expr=expr
		Return Self
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		If TConstExpr(expr) Then
			'use different calls to only return a "float sgn"
			'when param is a float
			Local val:String = TConstExpr(expr).value
			Local cexpr:TExpr
			If String(Int(val)) = val
				cexpr = New TConstExpr.Create(New TIntType, Sgn(Int(TConstExpr(expr).value)))
			Else
				cexpr = New TConstExpr.Create(New TFloatType, Sgn(Float(TConstExpr(expr).value)))
			End If
			
			_appInstance.removeStringConst(TConstExpr(expr).value)
			cexpr.Semant()
			Return cexpr
		End If
		
		expr = expr.Semant()
		
		If Not TNumericType(expr.exprType) Then
			Err "Subexpression for 'Sgn' must be of numeric type"
		End If

		If TInt128Type(expr.exprType) Err "'Sgn' does not support Int128 type. Use specific intrinsic function instead."
		If TFloat64Type(expr.exprType) Err "'Sgn' does not support Float64 type. Use specific intrinsic function instead."
		If TFloat128Type(expr.exprType) Err "'Sgn' does not support Float128 type. Use specific intrinsic function instead."
		If TDouble128Type(expr.exprType) Err "'Sgn' does not support Double128 type. Use specific intrinsic function instead."
		
		exprType=expr.exprType
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TSgnExpr.Create( CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TSgnExpr("+expr.ToString()+")"
	End Method

End Type

Type TMinExpr Extends TBuiltinExpr

	Field expr2:TExpr

	Method Create:TMinExpr( lhs:TExpr, rhs:TExpr )
		Self.id="min"
		Self.expr=lhs
		Self.expr2=rhs
		Return Self
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()
		expr2=expr2.Semant()
		
		If TInt128Type(expr.exprType) Or TInt128Type(expr2.exprType) Err "'Min' does not support Int128 type. Use specific intrinsic function instead."
		If TFloat64Type(expr.exprType) Or TFloat64Type(expr2.exprType) Err "'Min' does not support Float64 type. Use specific intrinsic function instead."
		If TFloat128Type(expr.exprType) Or TFloat128Type(expr2.exprType) Err "'Min' does not support Float128 type. Use specific intrinsic function instead."
		If TDouble128Type(expr.exprType) Or TDouble128Type(expr2.exprType) Err "'Min' does not support Double128 type. Use specific intrinsic function instead."

		exprType=BalanceTypes(expr.exprType, expr2.exprType)
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TMinExpr.Create( CopyExpr(expr), CopyExpr(expr2) )
	End Method

	Method ToString$()
		Return "TMinExpr("+expr.ToString()+"," + expr2.ToString() + ")"
	End Method

End Type

Type TMaxExpr Extends TBuiltinExpr

	Field expr2:TExpr

	Method Create:TMaxExpr( lhs:TExpr, rhs:TExpr )
		Self.id="max"
		Self.expr=lhs
		Self.expr2=rhs
		Return Self
	End Method

	Method Semant:TExpr()
		If exprType Return Self

		expr=expr.Semant()
		expr2=expr2.Semant()

		If TInt128Type(expr.exprType) Or TInt128Type(expr2.exprType) Err "'Max' does not support Int128 type. Use specific intrinsic function instead."
		If TFloat64Type(expr.exprType) Or TFloat64Type(expr2.exprType) Err "'Max' does not support Float64 type. Use specific intrinsic function instead."
		If TFloat128Type(expr.exprType) Or TFloat128Type(expr2.exprType) Err "'Max' does not support Float128 type. Use specific intrinsic function instead."
		If TDouble128Type(expr.exprType) Or TDouble128Type(expr2.exprType) Err "'Max' does not support Double128 type. Use specific intrinsic function instead."

		exprType=BalanceTypes(expr.exprType, expr2.exprType)
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TMaxExpr.Create( CopyExpr(expr), CopyExpr(expr2) )
	End Method

	Method ToString$()
		Return "TMaxExpr("+expr.ToString()+"," + expr2.ToString() + ")"
	End Method

End Type

Type TSizeOfExpr Extends TBuiltinExpr

	Method Create:TSizeOfExpr( expr:TExpr )
		Self.id="sizeof"
		Self.expr=expr
		Return Self
	End Method

	Method Semant:TExpr()
		If exprType Return Self
		expr=expr.Semant()
		exprType=New TIntType
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TSizeOfExpr.Create( CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TSizeOfExpr("+expr.ToString()+")"
	End Method

End Type

Type TChrExpr Extends TBuiltinExpr

	Method Create:TChrExpr( expr:TExpr )
		Self.id="chr"
		Self.expr=expr
		Return Self
	End Method
	
	Method Semant:TExpr()
		If exprType Return Self

		If TConstExpr(expr) Then
			Local cexpr:TConstExpr = New TConstExpr.Create(New TStringType, Chr(Int(TConstExpr(expr).value)))
			cexpr.Semant()
			_appInstance.mapStringConsts(cexpr.value)
			Return cexpr
		End If
		
		expr = expr.SemantAndCast( New TIntType )
		exprType = New TStringType
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TChrExpr.Create( CopyExpr(expr) )
	End Method

	Method ToString$()
		Return "TChrExpr("+expr.ToString()+")"
	End Method

End Type


Type TFuncCallExpr Extends TExpr
	Field expr:TExpr
	Field args:TExpr[]

	Method Create:TFuncCallExpr( expr:TExpr,args:TExpr[]=Null )
		Self.expr=expr
		If args Then
			Self.args=args
		Else
			Self.args = New TExpr[0]
		End If
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TFuncCallExpr.Create( CopyExpr(expr),CopyArgs(args) )
	End Method

	Method ToString$()
		Local t$="TFuncCallExpr("+expr.ToString()
		For Local arg:TExpr=EachIn args
			t:+","+arg.ToString()
		Next
		Return t+")"
	End Method

	Method Semant:TExpr()
		args=SemantArgs( args )
		If TIndexExpr(expr) Then
			expr = expr.SemantFunc( args, True, True )
			exprType = expr.exprType
			Return Self
		Else
			Return expr.SemantFunc( args, True, True )
		End If
	End Method

	Method SemantFunc:TExpr( args:TExpr[] , throwError:Int = True, funcCall:Int = False )
		' we are only likely to be called if a function returns and invokes a function pointer.

		Local ex:TExpr = Semant()
		
		If TFunctionPtrType(ex.exprType) Then
			exprType = TFunctionPtrType(ex.exprType).func.retType
		End If
		
		Self.args = SemantArgs(args)
		expr = ex
		
		Return Self
	End Method

	Method Trans$()
		Return _trans.TransFuncCallExpr( Self )
	End Method

End Type

Type TScopeExpr Extends TExpr
	Field scope:TScopeDecl

	Method Create:TScopeExpr( scope:TScopeDecl )
		Self.scope=scope
		Return Self
	End Method

	Method Copy:TExpr()
		Return Self
	End Method

	Method ToString$()
		Return "TScopeExpr("+scope.ToString()+")"
	End Method

	Method Semant:TExpr()
		Err "Syntax error."
	End Method

	Method SemantScope:TScopeDecl()
		Return scope
	End Method
End Type

Type TNewExpr Extends TExpr
	Field isSuper:Int
	Field args:TExpr[]
	Field ctor:TFuncDecl

	Method Create:TNewExpr( args:TExpr[]=Null, isSuper:Int = False )
		If args Then
			Self.args=args
		Else
			Self.args = New TExpr[0]
		End If
		Self.isSuper = isSuper
		Return Self
	End Method

	Method Semant:TExpr()

		Local fdecl:TFuncDecl = _env.FuncScope()
		If Not fdecl Or TNewDecl(fdecl) = Null Or Not _env.ClassScope() Then
			Err "Call to constructor not valid in this context."
		End If
	
		' must be first statement of New() method
		Local stmt:TStmt = TStmt(fdecl.stmts.First())
		
		If TExprStmt(stmt) = Null Or TExprStmt(stmt).expr <> Self Then
			Err "Call to constructor must be first statement in New()."
		End If
	
		args=SemantArgs( args )
		
		' validate called constructor
		Try
			Local cDecl:TClassDecl = _env.ClassScope()
			If isSuper Then
				cDecl = cDecl.superClass
			End If
			ctor = cDecl.FindFuncDecl("new",args,,,,True,SCOPE_CLASS_HEIRARCHY )
		Catch errorMessage:String
			If errorMessage.StartsWith("Compile Error") Then
				Throw errorMessage
			Else
				Err errorMessage
			End If
		End Try
		
		' TODO : expand to full recursive test
		If ctor = fdecl Then
			Err "Recursive constructor invocation."
		End If
		
		ctor.Semant
		
		' attach to ctor
		TNewDecl(fdecl).chainedCtor = Self
		
		Return Self
	End Method

	Method Trans$()
		'Return _trans.TransFuncCallExpr( Self )
	End Method

End Type

Type TNullExpr Extends TExpr

	Method Create:TNullExpr(ty:TType)
		exprType = ty
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TNullExpr.Create(exprType)
	End Method

	Method Semant:TExpr()
		Return Self
	End Method

	Method Trans$()
		Return "NULL"
	End Method

	Method Eval$()
		Return ""
	End Method

End Type

Type TLoopLabelExpr Extends TExpr

	Field loop:TLoopStmt

	Method Create:TLoopLabelExpr(loop:TLoopStmt)
		Self.loop = loop
		Return Self
	End Method
	
	Method Copy:TExpr()
		Return New TLoopLabelExpr.Create(loop)
	End Method

	Method Semant:TExpr()
		Return Self
	End Method

	Method Trans$()
		DebugStop
	End Method

	Method Eval$()
		Return ""
	End Method

End Type

Type TDataLabelExpr Extends TExpr

	Field dataDef:TDefDataDecl
	
	Method Create:TDataLabelExpr(dataDef:TDefDataDecl)
		Self.dataDef = dataDef
		Return Self
	End Method

	Method Copy:TExpr()
		Return New TDataLabelExpr.Create(dataDef)
	End Method

	Method Semant:TExpr()
		Return Self
	End Method

	Method Trans$()
		DebugStop
	End Method

	Method Eval$()
		Return ""
	End Method

End Type
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
' 
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
' 
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
' 
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
' 
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
' 
'    3. This notice may not be removed or altered from any source
'    distribution.
' 
SuperStrict

Import BRL.MaxUtil

Import "toker.bmx"


Const DECL_GLOBAL:Int = $10
Const DECL_FIELD:Int = $20
Const DECL_CONST:Int = $40
Const DECL_LOCAL:Int = $80


Type TIParser

	Field _toker:TToker
	Field _toke$
	Field _tokeType:Int
	Field _tokeSpace:Int
	Field _tokerStack:TList=New TList'<TToker>

	Method ParseModuleImport:Int(pmod:TModuleDecl, modpath:String, path:String, imp:String = Null, iData:String = Null, attrs:Int = 0, relPath:String = "", isFileImport:Int = 0)

		Const STATE_CLASS:Int = 1

		If Not modpath Then
			modpath = imp
		End If

		' already imported??
		If _appInstance.IsImported(modpath)
			' add import to the scope (so we can find decls in it later)
			' but don't add it if pmod is the apps' main module
			If _appInstance.mainModule <> pmod Then
				pmod.AddImport(modpath, _appInstance.globalImports.ValueForKey(modpath))
			End If
			Return False
		Else If imp Then
			' if "imp" is set, this is a file import. We need to check for it too, or we may end up importing it twice.
			If _appInstance.IsImported(imp)
				' add import to the scope (so we can find decls in it later)
				' but don't add it if pmod is the apps' main module
				If _appInstance.mainModule <> pmod Then
					pmod.AddImport(imp, _appInstance.globalImports.ValueForKey(imp))
				End If
				Return False
			End If
		End If
		
		Local prefix:String
		If isFileImport And opt_buildtype = BUILDTYPE_APP Then
			prefix = "m_"
		End If
		Local _mod:TModuleDecl = New TModuleDecl.Create(prefix + modpath, "bb" + modpath, path, attrs)
		Select modpath
			Case "brl.classes", "brl.blitzkeywords"
				_mod.UpdateFilePath(_mod.filepath + "." + modpath)
		End Select

		_mod.declImported = True
		_mod.relpath = relPath
		_mod.pmod = pmod

		If modpath = "brl.blitz" Then
			If pmod.imported.Contains(modpath) Then
				_mod = TModuleDecl(pmod.imported.ValueForKey(modpath))
			Else
				pmod.AddImport(modpath, _mod)
			End If
			
			' import Object and String definitions
			Local par:TIParser = New TIParser
			If FileType(modulepath("brl.blitz") + "\blitz_classes." + opt_platform + ".i") Then
				par.ParseModuleImport(_mod, "brl.classes", modulepath("brl.blitz"), modulepath("brl.blitz") + "\blitz_classes." + opt_platform + ".i")
			Else
				par.ParseModuleImport(_mod, "brl.classes", modulepath("brl.blitz"), modulepath("brl.blitz") + "\blitz_classes.i")
			End If
	
			' set up built-in keywords
			par = New TIParser
			par.ParseModuleImport(_mod, "brl.blitzkeywords", "", "", MakeKeywords())

		Else
			pmod.AddImport(modpath, _mod)
		End If

		_appInstance.globalImports.Insert(modpath, _mod)
		
		Local ipath:String
		
		'Local ipath:String = path + "\" + ModuleIdent(modpath) + ".release.macos.x86.i"
		If imp Then
			ipath = imp

			' add to imports
			pmod.AddImport(ipath, _mod)
			_appInstance.globalImports.Insert(ipath, _mod)
		Else
			ipath = path + "/" + ModuleIdent(modpath) + FileMung() + ".i"
		End If
		
		If Not iData Then

			If Not FileType(ipath) Then
				Err "Can't find interface for module '" + modpath + "'"
				Return False
			End If

			'Local ifile:String[] = LoadString(ipath).Split("~n")

			_toker = New TToker.Create( ipath,LoadString( ipath ) )
		Else
			_toker = New TToker.Create( ipath, iData)
		End If


	Local toker:TToker = _toker
	
		
	 Repeat
		Local pos:Int
	
		pos = toker._tokePos
		toker.NextToke
	
		
		Local line:Int
		Local state:Int
		Local class:TClassDecl
		Local stm:String
		
		
		
		Select toker.Toke().ToLower()
			Case "superstrict"
				_mod.attrs :| MODULE_SUPERSTRICT
				Continue
			Case "import"
			
				toker.NextToke()
				If toker.TokeType()=TOKE_SPACE toker.NextToke()
				
				' skip non-module imports
				If toker.TokeType()=TOKE_STRINGLIT

					Local iRelPath:String = ParseStringLit()

					SetErr
					
					If iRelPath.EndsWith(".bmx") Then
							
						Local origPath:String = RealPath(ExtractDir(path) + "/" + iRelPath)
						Local iPath:String = OutputFilePath(origPath, FileMung(), "i")
				
						If FileType( iPath )<>FILETYPE_FILE
							Err "File '"+ iPath +"' not found."
						EndIf
	
	
						If _mod.imported.Contains( iPath ) Continue
				
						Local modpath:String
						If opt_buildtype = BUILDTYPE_MODULE Then
							Local dir:String = ExtractDir(origPath).ToLower()
							dir = dir[dir.findLast("/") + 1..]
							If dir.EndsWith(".mod") Then
								dir = ""
							Else
								dir :+ "_"
							End If
							Local file:String = StripDir(origPath).ToLower()
			
							modpath = opt_modulename + "_" + dir + StripExt(file)
							'sanitize the path, remove non-allowed chars
							modpath = TStringHelper.Sanitize(modpath.ToLower())
						Else
							' todo file imports for apps
							'internalErr
						End If


'					Local mdecl:TDecl=TDecl(pmod.GetDecl( modpath ))

'					If Not mdecl
						New TIParser.ParseModuleImport( _mod, modpath, origPath, iPath, , , iRelPath)
'					Else
'						_mod.imported.Insert(modpath, mdecl)
'					EndIf
					Else
						If iRelPath.StartsWith("-") Then
							If Not _mod.fileImports.Contains(iRelPath) Then
								_mod.fileImports.AddLast(iRelPath)
							End If
						End If
					End If
				Else
				

					Local m:String = toker._toke
					toker.NextToke()
					
					Parse(".")
					
					m :+ "." + toker._toke
					
					SetErr
					Local mdecl:TDecl=TDecl(pmod.GetDecl( m ))
	
					If Not mdecl
						Local path:String = modulepath(m)
						' parse the imported module
						New TIParser.ParseModuleImport( _mod, m, path )
					Else
						_mod.AddImport(m, mdecl)
					EndIf

				End If
				
				Continue
				
			
			Case "moduleinfo"
				toker.nextToke()
				If toker.TokeType()=TOKE_SPACE toker.NextToke()
				Continue
			Case "~r", "~n"
				Continue
			Default

				stm = toker.Toke()
				
				Local v:String = toker.NextToke()			

				Select v
					Case "^"

						toker.rollback(pos)
						toker.NextToke()
						' class decl
						class = ParseClassDecl( stm,0 )
						class.declImported = True
						_mod.InsertDecl(class)

						If CParse("F")
							class.attrs :| DECL_FINAL

						Else If CParse("A")
							class.attrs :| DECL_ABSTRACT

						Else If CParse("S")
							class.attrs :| CLASS_STRUCT

						Else If CParse("AF")
							class.attrs :| DECL_ABSTRACT | DECL_FINAL

						Else If CParse("E")
							class.attrs :| DECL_EXTERN
							ApplyFunctionAttributes(class, DECL_EXTERN)

						Else If CParse("EW")
							class.attrs :| DECL_EXTERN | DECL_API_WIN32 
							ApplyFunctionAttributes(class, DECL_EXTERN | DECL_API_WIN32)
						
						Else If CParse("AI")
							class.attrs :| CLASS_INTERFACE | DECL_ABSTRACT
							ApplyFunctionAttributes(class, DECL_ABSTRACT)

						Else If CParse("EI")
							class.attrs :| DECL_EXTERN | CLASS_INTERFACE
							ApplyFunctionAttributes(class, DECL_EXTERN | DECL_ABSTRACT)

						Else If CParse("EIW")
							class.attrs :| DECL_EXTERN | CLASS_INTERFACE | DECL_API_WIN32
							ApplyFunctionAttributes(class, DECL_EXTERN | DECL_ABSTRACT | DECL_API_WIN32)

						Else If CParse("ES")
							class.attrs :| DECL_EXTERN | CLASS_STRUCT

						Else If CParse("ESW")
							class.attrs :| DECL_EXTERN | CLASS_STRUCT | DECL_API_WIN32 

						End If
'DebugStop
						If CParse( "=" )
'DebugStop
							If Not class.IsExtern() Then
								class.munged=ParseStringLit()

								If class.ident <> "String" Then
									For Local fdecl:TFieldDecl = EachIn class._decls
										fdecl.munged = "_" + class.munged + "_" + fdecl.ident
										fdecl.munged = fdecl.munged.ToLower()
									Next
								End If
							Else
								Parse "0"
								If Not class.munged Then
									class.munged = class.ident
									
								End If
							End If
						EndIf

						'state = STATE_CLASS
						'Exit
				'	Case "%"
				Default
					If toker._tokeType = TOKE_EOF
'DebugStop
						Exit
					End If

					Local a:Int
					Local ty:TType = ParseDeclType(a)

					If CParse("(") Then
						toker.rollback(pos)
						toker.NextToke()

						Local decl:TFuncDecl = ParseFuncDecl( _toke, 0 )
						decl.declImported = True

						' an array of function pointers?
						If CParse( "&" ) Then
						End If

						While IsArrayDef()
							ty = ParseArrayType(ty)
				
							If CParse( "&" ) Then
							End If
						Wend
						
						If decl.attrs & FUNC_PTR Then

							Local fpty:TType = New TFunctionPtrType
							TFunctionPtrType(fpty).func = decl
							
							If TArrayType(ty) Then
								TArrayType(ty).elemType = fpty
							Else
								ty = fpty
							End If
							
							'Local declInit:TExpr = decl.declInit
							'decl.declInit = Null
							Local gdecl:TGlobalDecl = New TGlobalDecl.Create( decl.ident,ty, Null, DECL_GLOBAL )
							gdecl.munged = decl.munged
							_mod.InsertDecl gdecl
							gdecl.declImported = True
							
							If CParse( "=" )
				
								If CParse("mem")
								
									If CParse(":")
										If CParse("p")
											If CParse("(") Then
				
												gdecl.munged = ParseStringLit()
				
												' for function pointers, ensure actual function reference is set too.
												'If TFunctionPtrType(gdecl.declTy) Then
												'	TFunctionPtrType(gdecl.declTy).func.munged = gdecl.munged
												'Else If TArrayType(gdecl.declTy) Then
												'	
												'End If
												TFunctionPtrType(fpty).func.munged = gdecl.munged
				
												Parse(")")
				
											EndIf
										End If
									Else
										If CParse("(") Then
				
											gdecl.munged = ParseStringLit()
				
											Parse(")")
				
										EndIf
									End If
								Else
									If TStringType(ty)
										If CParse("$") Then
											gdecl.declInit = ParseUnaryExpr()
										End If
									Else
										' a default value ?
										gdecl.declInit = ParseUnaryExpr()
									End If
								End If
							End If
	
						Else
							_mod.InsertDecl decl
						End If
						
					Else

						toker.rollback(pos)
						toker.NextToke()

						Local decl:TDecl = ParseDecl( _toke, DECL_CONST | DECL_EXTERN)'DECL_GLOBAL | DECL_EXTERN )
						_mod.InsertDecl decl
						decl.declImported = True

					End If

				End Select
				
		End Select
			line :+ 1
			
		Forever
		
		
		Return True
		
	End Method

	Method ParseUnaryExpr:TExpr()

		SkipEols
	
		Local op$=_toke
		Select op
		Case "+","-","~~","not"
			NextToke
			Local expr:TExpr=ParseUnaryExpr()
			Return New TUnaryExpr.Create( op,expr )
		End Select
		Return ParsePrimaryExpr( False )
	End Method

	Method ParsePrimaryExpr:TExpr( stmt:Int )

		Local expr:TExpr

			Select _tokeType
			'Case TOKE_IDENT
			'	expr=New TIdentExpr.Create( ParseIdent() )
			Case TOKE_INTLIT
				expr=New TConstExpr.Create( New TIntType,_toke )
				NextToke
			Case TOKE_LONGLIT
				expr=New TConstExpr.Create( New TLongType,_toke )
				NextToke
			Case TOKE_FLOATLIT
				Local value:String = _toke
				NextToke
				If CParse("!") Then
					expr=New TConstExpr.Create( New TDoubleType,value )
				Else
					CParse("#")
					expr=New TConstExpr.Create( New TFloatType,value )
				End If
			Case TOKE_STRINGLIT
				expr=New TConstExpr.Create( New TStringType,BmxUnquote( _toke, True ) )
				NextToke
			Case TOKE_IDENT
				If _toke = "nan" Or _toke = "inf" Then
					Local value:String = _toke
					NextToke
					If CParse("!") Then
						expr=New TConstExpr.Create( New TDoubleType,value )
					Else
						CParse("#")
						expr=New TConstExpr.Create( New TFloatType,value )
					End If
				Else
					Err "Syntax error - unexpected token '"+_toke+"'"
				End If
			Default
				Err "Syntax error - unexpected token '"+_toke+"'"
			End Select

		Return expr
		
	End Method

	Method ParseClassDecl:TClassDecl( toke$,attrs:Int )
		SetErr

		'If toke Parse toke
		
		Local id$=ParseIdent()
		Local args:String[]
		Local superTy:TIdentType
		Local imps:TIdentType[]

		If CParse( "^" )

			If CParse( "null" )
			
				superTy=Null
				
			Else
				superTy=ParseIdentType()
				'If superTy.ident <> "Object" Then
				'	superTy = TIdentType(superTy.Semant())
				'EndIf
			EndIf
		Else
			superTy = New TIdentType.Create( "brl.classes.object" )
		EndIf

		' implements
		If CParse("@") Then
			Local nimps:Int
			Repeat
				If imps.Length=nimps imps=imps + New TIdentType[10]
				imps[nimps]=ParseIdentType()
				nimps:+1
			Until Not CParse(",")
			imps=imps[..nimps]
		End If
		
		Local classDecl:TClassDecl=New TClassDecl.Create( id,args,superTy,imps,attrs )
		
		If classDecl.IsExtern()
			classDecl.munged=classDecl.ident
			If CParse( "=" ) classDecl.munged=ParseStringLit()
		EndIf
		
		'If classDecl.IsTemplateArg() Return classDecl

		Local decl_attrs:Int=(attrs & DECL_EXTERN)
		
		Local method_attrs:Int=decl_attrs
		If attrs & CLASS_INTERFACE method_attrs:|DECL_ABSTRACT

		Repeat
			SkipEols
			'If IsSpace(Asc(_toker._toke))
			'	_toker.NextToke
			'End If
			
			Select _toker._toke
			Case "{"
				'_toker.
				NextToke
			Case "}"
				'_toker.
				NextToke
				Exit
			Case "-" ' method
				'DebugStop
				'_toker.
				NextToke
				
				Local decl:TFuncDecl = ParseFuncDecl( _toke,method_attrs|FUNC_METHOD )
				'If decl.IsCtor() decl.retTypeExpr=New TObjectType.Create( classDecl )
				classDecl.InsertDecl decl
				
			Case "+" ' function
				NextToke
				
				Local decl:TFuncDecl = ParseFuncDecl( _toke,method_attrs )
				'If decl.IsCtor() decl.retTypeExpr=New TObjectType.Create( classDecl )
				classDecl.InsertDecl decl

			Case "." ' field
				NextToke
				decl_attrs :| DECL_FIELD
				Local decl:TDecl= ParseDecl( _toke,decl_attrs )
				classDecl.InsertDecl decl
			Rem
			Case "private"
				NextToke
				decl_attrs=decl_attrs | DECL_PRIVATE
			Case "public"
				NextToke
				decl_attrs=decl_attrs & ~DECL_PRIVATE
			Case "const","global","field"
				If (attrs & CLASS_INTERFACE) And _toke<>"const"
					Err "Interfaces can only contain constants and methods."
				EndIf
				classDecl.InsertDecls ParseDecls( _toke,decl_attrs )
			Case "method"
				Local decl:TFuncDecl=ParseFuncDecl( _toke,method_attrs )
				If decl.IsCtor() decl.retTypeExpr=New TObjectType.Create( classDecl )
				classDecl.InsertDecl decl
			Case "function"
				If (attrs & CLASS_INTERFACE) And _toke<>"const"
					Err "Interfaces can only contain constants and methods."
				EndIf
				Local decl:TFuncDecl=ParseFuncDecl( _toke,decl_attrs )
				classDecl.InsertDecl decl
				End Rem
			'Default
			'	Err "Syntax error - expecting class member declaration."
			End Select
			
			If _toker._tokeType = TOKE_IDENT Then
				' Const / Global?
				'NextToke

				'decl_attrs :| DECL_CONST
				
				Local decl:TDecl= ParseDecl( _toke,decl_attrs | DECL_CONST)
				classDecl.InsertDecl decl
			End If
			
		Forever
		
		If toke CParse toke

		Return classDecl

	End Method

	Method Parse( toke$ )
		If Not CParse( toke )
			Err "Syntax error - expecting '"+toke+"'."
		EndIf
	End Method

	Method ParseIdent$()
		Select _toker._toke.tolower()
		Case "@" _toker.NextToke
		Case "string","___array","object"
		Default	
			If _toker._tokeType<>TOKE_IDENT Err "Syntax error - expecting identifier."
		End Select
		Local id$=_toker._toke
		NextToke

		Return id
	End Method

	Method ParseIdentType:TIdentType()
		Local id$=ParseIdent()
		
		While CParse( "." )
			id:+"."+ParseIdent()
		Wend
		Local args:TIdentType[]
		Return New TIdentType.Create( id,args )
	End Method

	Method NextToke$()
		Local toke$=_toke
		
		_tokeSpace=False
		
		Repeat
			_toke=_toker.NextToke()
			_tokeType=_toker.TokeType()
			If _tokeType<>TOKE_SPACE Exit
			_tokeSpace=True
		Forever
		
		If _tokeType=TOKE_KEYWORD _toke=_toke.ToLower()

		If toke="," SkipEols

		Return _toke
	End Method
	
	Method CParse:Int( toke$ )
		If _toker._toke.tolower()<>toke.tolower()
			Return False
		EndIf
		'_toker.
		NextToke
		Return True
	End Method

	Method CParseToker:Int( toker:TToker, toke$ )
		If toker._toke.ToLower()<>toke
			Return False
		EndIf
		NextTokeToker(toker)
		Return True
	End Method

	Method NextTokeToker$(toker:TToker)
		Repeat
			toker.NextToke()
		Until toker.tokeType()<>TOKE_SPACE

		Return toker._toke
	End Method

	Method SkipEols()
		Local found:Int = True
		While found
			found = False
			If CParse( "~n" )
				found = True
			End If
			If CParse("~r")
				found = True
			End If
		Wend
		
		SetErr
	End Method

	Method ParseStringLit$()
		If _toker._tokeType<>TOKE_STRINGLIT Err "Expecting string literal."
		Local str$=BmxUnquote( _toker._toke, True )
		'_toker.
		NextToke
		Return str
	End Method

	Method ParseFuncDecl:TFuncDecl( toke$,attrs:Int, returnType:TType = Null )
		SetErr

		'If toke Parse toke
	
		Local id$
		Local ty:TType
		Local meth:Int = attrs & FUNC_METHOD

		If Not returnType Then		
			If attrs & FUNC_METHOD
				If _toker._toke.tolower() = "new"
					If attrs & DECL_EXTERN
						Err "Extern classes cannot have constructors"
					EndIf
					id=_toker._toke
					NextToke
					attrs:|FUNC_CTOR
					attrs:&~FUNC_METHOD
					ty=ParseDeclType(attrs, True)
				Else
					If _toker._tokeType = TOKE_STRINGLIT Then
						id = ParseStringLit()
					Else
						id=ParseIdent()
					End If
					ty=ParseDeclType(attrs, True)
				EndIf
			Else
				id=ParseIdent()
				ty=ParseDeclType(attrs, True)
			EndIf
		End If
		
		Local args:TArgDecl[]
		
		Parse "("
		SkipEols

		If _toker._toke<>")"
			Local nargs:Int
			Repeat

				Local pos:Int, tokeType:Int
				pos = _toker._tokePos
				tokeType = _toker._tokeType
'DebugStop
				Local id$=ParseIdent()
'If id = "compareFunc" DebugStop
				Local ty:TType=ParseDeclType(attrs)
				Local init:TExpr

				If CParse( "(") Then
'DebugStop
					' function pointer
					_toker.rollback(pos, tokeType)
					_toker._toke = id
					'_toker.NextToke()
					Local decl:TFuncDecl = ParseFuncDecl( id, FUNC_PTR | FUNC_INIT )
					ty = New TFunctionPtrType
					TFunctionPtrType(ty).func = decl
					
				End If
				
				If CParse("Var") Then
					ty = TType.MapToVarType(ty)
				End If

				If CParse( "=" ) Then
					'DebugLog "TODO : parse default values..."
					If CParse("$") Then
						' a string default
						init = ParseUnaryExpr()
					Else
						If Not TFunctionPtrType(ty) Then
							init = ParseUnaryExpr()
							If TArrayType(ty) Then
								If TConstExpr(init) And TConstExpr(init).value="bbEmptyArray" Then
									init = New TNullExpr.Create(TType.nullObjectType)
								End If
							Else If TObjectType(ty) Or TIdentType(ty) Then
								If TConstExpr(init) And TConstExpr(init).value="bbNullObject" Then
									init = New TNullExpr.Create(TType.nullObjectType)
								End If
							End If
						Else
							' munged reference to default function pointer
							Local defaultFunc:String = ParseStringLit()
							Local func:TFuncDecl = TFuncDecl(TFunctionPtrType(ty).func.Copy())
							init = New TInvokeExpr.Create(func)
							func.munged = defaultFunc
							init.exprType = ty
							
						End If
					End If
					' has a default value
					'DebugStop
					'init=ParseExpr()
				End If
				
				Local arg:TArgDecl=New TArgDecl.Create( id,ty,init )
				If args.Length=nargs args=args + New TArgDecl[10]
				args[nargs]=arg
				nargs:+1
				If _toker._toke=")" Exit
				Parse ","
			Forever
			args=args[..nargs]
		EndIf
		Parse ")"
		
		If returnType Then
			Return New TFuncDecl.CreateF(Null, returnType, args, 0)
		End If

		Local fdecl:TFuncDecl
		' wait.. so everything until now was a function pointer return type, and we still have to process the function declaration...
		If _toke = "(" Then
			Local retTy:TType = New TFunctionPtrType
			TFunctionPtrType(retTy).func = New TFuncDecl.CreateF("",ty,args,attrs )
			TFunctionPtrType(retTy).func.attrs :| FUNC_PTR
			fdecl = ParseFuncDecl("", attrs, retTy)
			ty = retTy
		End If

		Repeat		
			If CParse( "F" )
				attrs:|DECL_FINAL
			Else If CParse( "FW" )
				attrs:|DECL_FINAL | DECL_API_WIN32
			Else If CParse( "FP" )
				attrs:|DECL_FINAL|DECL_PRIVATE
			Else If CParse( "FPW" )
				attrs:|DECL_FINAL|DECL_PRIVATE| DECL_API_WIN32
			Else If CParse( "FR" )
				attrs:|DECL_FINAL|DECL_PROTECTED
			Else If CParse( "FRW" )
				attrs:|DECL_FINAL|DECL_PROTECTED| DECL_API_WIN32
			Else If CParse( "A" )
				attrs:|DECL_ABSTRACT
			Else If CParse( "AW" )
				attrs:|DECL_ABSTRACT | DECL_API_WIN32
			Else If CParse( "AP" )
				attrs:|DECL_ABSTRACT|DECL_PRIVATE
			Else If CParse( "APW" )
				attrs:|DECL_ABSTRACT|DECL_PRIVATE| DECL_API_WIN32
			Else If CParse( "AR" )
				attrs:|DECL_ABSTRACT|DECL_PROTECTED
			Else If CParse( "ARW" )
				attrs:|DECL_ABSTRACT|DECL_PROTECTED| DECL_API_WIN32
			Else If CParse( "W" )
				attrs:|DECL_API_WIN32
			Else If CParse( "O" )
				attrs:|FUNC_OPERATOR
			Else If CParse( "OW" )
				attrs:|FUNC_OPERATOR| DECL_API_WIN32
			Else If CParse( "OP" )
				attrs:|FUNC_OPERATOR|DECL_PRIVATE
			Else If CParse( "OPW" )
				attrs:|FUNC_OPERATOR|DECL_PRIVATE| DECL_API_WIN32
			Else If CParse( "OR" )
				attrs:|FUNC_OPERATOR|DECL_PROTECTED
			Else If CParse( "ORW" )
				attrs:|FUNC_OPERATOR|DECL_PROTECTED| DECL_API_WIN32
			Else If CParse( "P" )
				attrs:|DECL_PRIVATE
			Else If CParse( "PW" )
				attrs:|DECL_PRIVATE| DECL_API_WIN32
			Else If CParse( "R" )
				attrs:|DECL_PROTECTED
			Else If CParse( "RW" )
				attrs:|DECL_PROTECTED| DECL_API_WIN32
			Else If CParse( "FO" )
				attrs:|DECL_FINAL|FUNC_OPERATOR
			Else If CParse( "FOW" )
				attrs:|DECL_FINAL|FUNC_OPERATOR| DECL_API_WIN32
			Else If CParse( "FOP" )
				attrs:|DECL_FINAL|FUNC_OPERATOR|DECL_PRIVATE
			Else If CParse( "FOPW" )
				attrs:|DECL_FINAL|FUNC_OPERATOR|DECL_PRIVATE| DECL_API_WIN32
			Else If CParse( "FOR" )
				attrs:|DECL_FINAL|FUNC_OPERATOR|DECL_PROTECTED
			Else If CParse( "FORW" )
				attrs:|DECL_FINAL|FUNC_OPERATOR|DECL_PROTECTED| DECL_API_WIN32
			Else If CParse( "AO" )
				attrs:|DECL_ABSTRACT|FUNC_OPERATOR
			Else If CParse( "AOW" )
				attrs:|DECL_ABSTRACT|FUNC_OPERATOR| DECL_API_WIN32
			Else If CParse( "AOP" )
				attrs:|DECL_ABSTRACT|FUNC_OPERATOR|DECL_PRIVATE
			Else If CParse( "AOPW" )
				attrs:|DECL_ABSTRACT|FUNC_OPERATOR|DECL_PRIVATE| DECL_API_WIN32
			Else If CParse( "AOR" )
				attrs:|DECL_ABSTRACT|FUNC_OPERATOR|DECL_PROTECTED
			Else If CParse( "AORW" )
				attrs:|DECL_ABSTRACT|FUNC_OPERATOR|DECL_PROTECTED| DECL_API_WIN32
			'Else If CParse( "property" )
			'	If attrs & FUNC_METHOD
			'		attrs:|FUNC_PROPERTY
			'	Else
			'		Err "Only methods can be properties."
			'	EndIf
			Else
				Exit
			EndIf
		Forever
		
		Local funcDecl:TFuncDecl
		If attrs & FUNC_CTOR Then
			funcDecl = New TNewDecl.CreateF( id,ty,args,attrs )
		Else
			If fdecl Then
				funcDecl = fdecl
				funcDecl.ident = id
			Else
				funcDecl = New TFuncDecl.CreateF( id,ty,args,attrs )
			End If
		End If
		
		funcDecl.retType = ty
		
		If CParse("&") Then
			funcDecl.attrs :| DECL_POINTER
		End If

		'If funcDecl.IsExtern()
		If Not (funcDecl.attrs & (FUNC_PTR | FUNC_INIT)) Then
		'	funcDecl.munged=funcDecl.ident
			If CParse( "=" )

				If CParse("mem")
					If CParse(":")
						If CParse("p")
							If CParse("(") Then
								
								funcDecl.munged = ParseStringLit()
								
								Cparse(")")

							EndIf
						End If
					End If
				Else
					funcDecl.munged=ParseStringLit()
				End If

			End If
		End If
		
		' read function cast stuff
		If CParse(":") Then
			' ret type
			Local rt$=_toker._toke

			If CParse("unsigned") Then
				rt :+ " " + _toker._toke
			End If

			NextToke
			If CParse("*") Then
				rt:+ "*"
				
				If CParse("*") Then
					rt:+ "*"
				End If
			End If
			
			funcDecl.castTo = rt

			' fname
			Local fn$=_toker._toke
			NextToke

			' args
			Parse("(")

			If Not CParse(")") Then
				Local i:Int = 0			
				Repeat
					Local at$=_toker._toke
					
					If CParse("const") Then
						at :+ " " + _toker._toke
					End If
					
					If CParse("unsigned") Then
						at :+ " " + _toker._toke
					End If


					NextToke
					If CParse("*") Then
						at:+ "*"
						
						If CParse("*") Then
							at:+ "*"
						End If
					End If


					' function pointer
					If CParse("(") Then

						Parse("*")
						Parse(")")
						at :+ "(*)"
						
						Parse("(")
						at :+ "("
						
						While Not CParse(")")
							NextToke
							at :+ _toker._toke
						Wend
						
						at :+ ")"
					End If



					args[i].castTo = at
					
				
					If _toker._toke=")" Exit
					Parse ","
					
					i:+ 1
				Forever
			End If
				

		End If
			
		'	Return funcDecl
		'EndIf
		
		If funcDecl.attrs & DECL_POINTER Then
			funcDecl.attrs :| FUNC_PTR
		End If
		
		'If funcDecl.IsAbstract() Return funcDecl
		Return funcDecl
		
	End Method
	
	Method ParseDecl:TDecl( toke$,attrs:Int )
		SetErr
		Local pos:Int, tokeType:Int
		pos = _toker._tokePos
		tokeType = _toker._tokeType

		Local id$=ParseIdent()
		Local ty:TType
		Local init:TExpr

		If attrs & DECL_EXTERN
			ty=ParseDeclType(attrs)

		'Else If CParse( ":=" )
	'		init=ParseExpr()
		Else
			ty=ParseDeclType(attrs)
			
			
				If CParse( "(") Then
'DebugStop
					' function pointer
					_toker.rollback(pos, tokeType)
					_toker._toke = id
					'_toker.NextToke()
					Local decl:TFuncDecl = ParseFuncDecl( id, FUNC_PTR | FUNC_INIT )
					ty = New TFunctionPtrType
					TFunctionPtrType(ty).func = decl
					
					If attrs & DECL_FIELD Then
						decl.attrs :| FUNC_METHOD
					End If
					
					' an array of function pointers?
					If CParse( "&" ) Then
					End If

					While IsArrayDef()
						ty = ParseArrayType(ty)
			
						If CParse( "&" ) Then
						End If
					Wend

				End If
				
				If CParse("`") Then
					If CParse("`") Then
						attrs :| DECL_PROTECTED
					Else
						attrs :| DECL_PRIVATE
					End If
				End If
				

Rem
			If CParse( "=" )
				' TODO init=ParseExpr()
				If CParse("$") Then
					' string value
					init = ParseUnaryExpr()
				Else
					init = ParseUnaryExpr()
				End If
				'DebugLog "TODO : ParseExpression"
			Else If CParse( "[" )
				'Local ln:TExpr=ParseExpr()
				Parse "]"
				'While CParse( "[]" )
				'	ty=New TArrayType.Create(ty)
				'Wend
				'init=New TNewArrayExpr.Create( ty,ln)
				'ty=New TArrayType.Create( ty )
			Else If toke<>"const"
				init=New TConstExpr.Create( ty,"" )
			Else
				Err "Constants must be initialized."
			EndIf
End Rem
		EndIf

		Local decl:TValDecl
		
		If attrs & DECL_GLOBAL
			decl=New TGlobalDecl.Create( id,ty,init,attrs )
		Else If attrs & DECL_FIELD
			decl=New TFieldDecl.Create( id,ty,init,attrs )
		Else If attrs & DECL_CONST
			decl=New TConstDecl.Create( id,ty,init,attrs )
		Else If attrs & DECL_LOCAL
			decl=New TLocalDecl.Create( id,ty,init,attrs )
		EndIf
'DebugStop
'		If decl.IsExtern() 
			If CParse( "=" )

				If CParse("mem")
					' Change to global
					' Until this point, it was "probably" a const, but now we know for sure
					' that it must be a global.
					If attrs & DECL_CONST Then
						attrs :| DECL_GLOBAL
						attrs :~ DECL_CONST
						decl=New TGlobalDecl.Create( id,ty,init,attrs )
					End If
				
				
					If CParse(":")
						If CParse("p")
							If CParse("(") Then

								decl.munged = ParseStringLit()

								' for function pointers, ensure actual function reference is set too.
								If TFunctionPtrType(decl.declTy) Then
									TFunctionPtrType(decl.declTy).func.munged = decl.munged
								End If

								Parse(")")

							EndIf
						End If
					Else
						If CParse("(") Then

							decl.munged = ParseStringLit()

							Parse(")")

						EndIf
					End If
				Else
					If TStringType(ty)
						If CParse("$") Then
							decl.declInit = ParseUnaryExpr()
						End If
					Else
						' a default value ?
						decl.declInit = ParseUnaryExpr()
					End If
				End If
				
				
				
			Else
				decl.munged=decl.ident
			EndIf
'		EndIf

		Return decl
	End Method

	' replaces While CParse( "[]" ) sections, with support for multi-dimension arrays
	Method ParseArrayType:TType(ty:TType)
		While True
			Local dims:Int = 1
			
			If CParse("[]") Then
				ty=New TArrayType.Create( ty )
				Exit
			End If
			
			If Not CParse("[") Then
				Exit
			End If
		
			While CParse( ",")
				dims :+ 1
			Wend
			
			Parse "]"
			
			ty=New TArrayType.Create( ty, dims )
			Exit
		Wend
		Return ty
	End Method

	Method IsArrayDef:Int()
		Local isDef:Int = True
		Local toker:TToker=New TToker.Copy(_toker)
		While True
			If CParseToker(toker, "[]") Then
				Exit
			End If
			
			If Not CParseToker(toker, "[") Then
				isDef = False
				Exit
			End If
		
			While CParseToker(toker, ",")
			Wend
			
			If Not CParseToker(toker, "]") Then
				isDef = False
				Exit
			End If
			Exit
		Wend
		Return isDef
	End Method

	Method ParseDeclType:TType(attrs:Int Var, fn:Int = False)
		Local ty:TType
		Select _toker._toke
		'Case "?"
		'	NextToke
		'	ty=TType.boolType
		Case "%"
			NextToke
			ty=New TIntType

			If CParse("%") Then
				ty = New TLongType
			ElseIf CParse("z") Then
				ty = New TSizetType
			ElseIf CParse("j") Then
				ty = New TInt128Type
			ElseIf CParse("w") Then
				ty = New TWParamType
			ElseIf CParse("x") Then
				ty = New TLParamType
			End If
			
			If CParse("&") And Not (attrs & DECL_FIELD) Then
				attrs :| DECL_GLOBAL
				attrs :~ DECL_CONST
			End If

			' pointer
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			
		Case "|"
			NextToke
			ty=New TUIntType

			If CParse("|") Then
				ty = New TULongType
			End If
			
			If CParse("&") And Not (attrs & DECL_FIELD) Then
				attrs :| DECL_GLOBAL
				attrs :~ DECL_CONST
			End If

			' pointer
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			
		Case "#"
			NextToke
			ty=New TFloatType

			If CParse("&")  And Not (attrs & DECL_FIELD) Then
				attrs :| DECL_GLOBAL
				attrs :~ DECL_CONST
			End If

			' pointer
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			
		Case "$"
			NextToke
			ty=New TStringType

			If CParse("z") Then
				ty._flags :| TType.T_CHAR_PTR
			Else If CParse("w") Then
				ty._flags :| TType.T_SHORT_PTR
			End If

			If CParse( "&" )  And Not (attrs & DECL_FIELD)
				attrs :| DECL_GLOBAL
				attrs :~ DECL_CONST
			End If
		Case "!"
			NextToke
			ty=New TDoubleType
			
			If CParse("k") Then
				ty = New TFloat128Type
			Else If CParse("m") Then
				ty = New TDouble128Type
			Else If CParse("h") Then
				ty = New TFloat64Type
			End If

			If CParse("&")  And Not (attrs & DECL_FIELD) Then
				attrs :| DECL_GLOBAL
				attrs :~ DECL_CONST
			End If

			' pointer
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend

		Case ":"
			NextToke
			ty=ParseNewType()
			
			If CParse("*") Then
				If TIdentType(ty) Then
					ty = TType.MapToPointerType(ty)

					While CParse( "*" )
						ty = TType.MapToPointerType(ty)
					Wend

				End If
			End If
			
			CParse("&")
		Case "?"
			NextToke
			
			attrs :| DECL_EXTERN
			
			If CParse("?") Then
				attrs :| CLASS_INTERFACE
			End If
			
			ty=ParseNewType()
			
			If CParse("*") Then
				If TIdentType(ty) Then
					ty = TType.MapToPointerType(ty)

					While CParse( "*" )
						ty = TType.MapToPointerType(ty)
					Wend

				End If
			End If
			
			CParse("&")
		Case "~~"
			NextToke
			
			attrs :| DECL_EXTERN | CLASS_STRUCT
			
			ty=ParseNewType()
			
			If CParse("*") Then
				If TIdentType(ty) Then
					ty = TType.MapToPointerType(ty)

					While CParse( "*" )
						ty = TType.MapToPointerType(ty)
					Wend

				End If
			End If
			
			CParse("&")
		Case "@"
			NextToke
			ty=New TByteType
			
			If CParse("@") Then
				ty = New TShortType
			End If

			
			If CParse( "&" )
'DebugStop
			End If
			
			' pointer
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
' TODO
'		Case "!" ' BaH Double
'			NextToke
'			ty=TType.doubleType
		Default
			'If _module.IsStrict() Err "Illegal type expression."
'DebugStop
			If Not fn Then
				ty=New TIntType
			End If
		End Select

		If CParse( "&" ) Then
		End If

		While IsArrayDef()
			ty = ParseArrayType(ty)

			If CParse( "&" ) Then
			End If
		Wend

		If CParse( "&" ) Then
		End If
		
		Return ty
	End Method

	Method ParseNewType:TType()
		If CParse( "byte" ) Or CParse( "@" )
			Local ty:TType = New TByteType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "short" )
			Local ty:TType = New TShortType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "int" ) Or CParse( "%" )
			Local ty:TType = New TIntType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "uint" ) Or CParse( "|" )
			Local ty:TType = New TUIntType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "float" )
			Local ty:TType = New TFloatType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "string" ) Return New TStringType
		If CParse( "object" ) Return New TIdentType.Create( "brl.classes.object" )
		If CParse( "long" )
			Local ty:TType = New TLongType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "ulong" )
			Local ty:TType = New TULongType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "double" )
			Local ty:TType = New TDoubleType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "size_t" )
			Local ty:TType = New TSizeTType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "int128" )
			Local ty:TType = New TInt128Type
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "float64" )
			Local ty:TType = New TFloat64Type
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "float128" )
			Local ty:TType = New TFloat128Type
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "double128" )
			Local ty:TType = New TDouble128Type
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "wparam" )
			Local ty:TType = New TWParamType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		If CParse( "lparam" )
			Local ty:TType = New TLParamType
			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
			While CParse( "*" )
				ty = TType.MapToPointerType(ty)
			Wend
			Return ty
		End If
		Return ParseIdentType()
	End Method
	
	Method ApplyFunctionAttributes(classDecl:TClassDecl, attrs:Int)
		For Local decl:TFuncDecl = EachIn classDecl._decls
			decl.attrs :| attrs
		Next
	End Method

	Method SetErr()
		If _toker.Path()
			_errInfo=FormatError(_toker.Path(), _toker.Line(), 0)
		EndIf
	End Method

End Type


' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import "base.configmap.bmx"

Const version:String = "0.87"

Const BUILDTYPE_APP:Int = 0
Const BUILDTYPE_MODULE:Int = 1

Const APPTYPE_NONE:Int = 0
Const APPTYPE_CONSOLE:Int = 1
Const APPTYPE_GUI:Int = 2

Global WORD_SIZE:Int = 4

' buildtype
'    module
'    app
Global opt_buildtype:Int = BUILDTYPE_APP
' modulename
'    name of the module to build
Global opt_modulename:String
' arch
'    x86
'    ppc
'    x64
'    arm
'    armeabi
'    armeabiv7a
'    armv7
'    arm64
Global opt_arch:String
' platform
'    win32
'    macos
'    osx
'    ios
'    linux
'    android
'    raspberrypi
Global opt_platform:String
' framework
Global opt_framework:String
' filename
'    the base filename for app/module to compile against
Global opt_filename:String
' outfile
'    full path to the outputfile (excluding final extension - there will be a .h, .c and .i generated)
Global opt_outfile:String
' apptype
'    console
'    gui
Global opt_apptype:Int = APPTYPE_NONE
' debug
Global opt_debug:Int = True
' threaded
Global opt_threaded:Int = False
' release
Global opt_release:Int = False
' quiet
Global opt_quiet:Int = False
' verbose
Global opt_verbose:Int = False
' ismain
'    this is the main file for either the module, or the application.
Global opt_ismain:Int = False
' issuperstrict
'
Global opt_issuperstrict:Int = False
' gdbdebug
'    output debug useful for gdb, #line <bmx line> <bmx file> 
Global opt_gdbdebug:Int = False
' 
'    upgrade strict subclass method/function return types to match superstrict superclass.
'    default is to auto-upgrade. Set flag if you want to throw an error - because of mismatch. (strict is Int, superstrict is Void).
Global opt_strictupgrade:Int = True
' overload warnings
'    generate warnings (and accept) instead of errors for calling methods with arguments that need to be cast down.
'    May cause issues using overloaded methods.
Global opt_warnover:Int = False
' musl libc support
'    
Global opt_musl:Int = False

Global opt_filepath:String

Function CmdError(details:String = Null, fullUsage:Int = False)
	Local s:String = "Compile Error"
	If details Then
		s:+ ": " + details
	End If
	s:+ "~n"
	
	's:+ Usage(fullUsage)
	
	Throw s
End Function

Function ParseArgs:String[](args:String[])

	DefaultOptions()
	
	CheckConfig()
	
	Local count:Int

	While count < args.length
	
		Local arg:String = args[count]
		
		If arg[..1] <> "-" Then
			Exit
		End If
		
		Select arg[1..]
			Case "q"
				opt_quiet=True
			Case "v"
				opt_verbose=True
			Case "r"
				opt_debug=False
				opt_release=True
			Case "h"
				opt_threaded=True
			Case "s"
				' disable with option
				opt_strictupgrade=False
			Case "g"
				count:+1
				If count = args.length Then
					CmdError "Command line error - Missing arg for '-g'"
				End If
				opt_arch = args[count].ToLower()
			Case "m"
				count:+1
				If count = args.length Then
					CmdError "Command line error - Missing arg for '-m'"
				End If
				opt_buildtype = BUILDTYPE_MODULE
				opt_modulename = args[count].ToLower()
			Case "o"
				count:+1
				If count = args.length Then
					CmdError "Command line error - Missing arg for '-o'"
				End If
				opt_outfile = args[count]
			Case "p"
				count:+1
				If count = args.length Then
					CmdError "Command line error - Missing arg for '-p'"
				End If
				opt_platform = args[count].ToLower()
			Case "t"
				count:+1
				If count = args.length Then
					CmdError "Command line error - Missing arg for '-t'"
				End If
				Local apptype:String = args[count].ToLower()
				Select apptype
					Case "console"
						opt_apptype = APPTYPE_CONSOLE
					Case "gui"
						opt_apptype = APPTYPE_GUI
					Default
						CmdError "Command line error - Invalid app type '" + opt_apptype + "'"
				End Select
			Case "f"
				count:+1
				If count = args.length Then
					CmdError "Command line error - Missing arg for '-f'"
				End If
				opt_framework = args[count]
			Case "d"
				opt_gdbdebug=True
			Case "w"
				opt_warnover=True
			Case "musl"
				opt_musl=True
		End Select
	
		count:+ 1
	Wend
	
	If opt_buildtype = BUILDTYPE_MODULE Then
		opt_apptype = APPTYPE_NONE
	End If
	
	If opt_arch = "x64" Or opt_arch = "arm64v8a" Or opt_arch = "arm64" Then
		WORD_SIZE = 8
	End If

	Return args[count..]

End Function

Function DefaultOptions()
?x86
	opt_arch = "x86"
?ppc
	opt_arch = "ppc"
?x64
	opt_arch = "x64"
?arm
	opt_arch = "arm"
?arm64
	opt_arch = "arm64"
?armeabi
	opt_arch = "armeabi"
?armeabiv7a
	opt_arch = "armeabiv7a"
?arm64v8a
	opt_arch = "arm64v8a"
?js
	opt_arch = "js"
?

?win32
	opt_platform = "win32"
?macos
	opt_platform = "macos"
?linux
	opt_platform = "linux"
?android
	opt_platform = "android"
?raspberrypi
	opt_platform = "raspberrypi"
?emscripten
	opt_platform = "emscripten"
?
End Function

Function CheckConfig()
	Local config:TConfigMap = New TConfigMap.Init("bbcc.conf")

	'try to load an OS-specific path (so all bcc builds could share
	'one single bbcc.conf)
	Local osBmxPath:String = ""
	?win32
		osBmxPath = config.GetString("BMXPATH_WIN32")
	?linux
		osBmxPath = config.GetString("BMXPATH_LINUX")
	?macos
		osBmxPath = config.GetString("BMXPATH_MACOS")
	?android
		' override BMXPATH_LINUX if available
		Local tmp:String = config.GetString("BMXPATH_ANDROID")
		If tmp Then
			osBmxPath = tmp
		End If
	?raspberrypi
		' override BMXPATH_LINUX if available
		Local tmp:String = config.GetString("BMXPATH_RASPBERRYPI")
		If tmp Then
			osBmxPath = tmp
		End If
	?
	'load default/generic path
	If osBmxPath = "" Then osBmxPath = config.GetString("BMXPATH")

	'replace windows backslashes with crossplatform slashes
	osBmxPath = osBmxPath.Replace("\", "/")

	If osBmxPath <> "" Then putenv_("BMXPATH="+osBmxPath)
End Function
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import BRL.MaxUtil
Import "toker.bmx"
Import "iparser.bmx"


Global FILE_EXT$="bmx"

Type TForEachinStmt Extends TLoopStmt
	Field varid$
	Field varty:TType
	Field varlocal:Int
	Field expr:TExpr
	Field block:TBlockDecl
	Field varExpr:TExpr
	
	Field stmts:TList=New TList

	Method Create:TForEachinStmt( varid$,varty:TType,varlocal:Int,expr:TExpr,block:TBlockDecl,loopLabel:TLoopLabelDecl,varExpr:TExpr )
		Self.varid=varid
		Self.varty=varty
		Self.varlocal=varlocal
		Self.expr=expr
		Self.block=block
		block.extra = Self
		Self.loopLabel=loopLabel
		Self.varExpr = varExpr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TForEachinStmt.Create( varid,varty,varlocal,expr.Copy(),block.CopyBlock( scope ),TLoopLabelDecl(loopLabel.Copy()), varExpr.Copy() )
	End Method

	Method OnSemant()
		expr=expr.Semant()

		If TArrayType( expr.exprType ) Or TStringType( expr.exprType )

			Local exprTmp:TLocalDecl=New TLocalDecl.Create( "",Null,expr,,True )
			Local indexTmp:TLocalDecl=New TLocalDecl.Create( "",Null,New TConstExpr.Create( New TUIntType,"0" ),,True )

			Local lenExpr:TExpr=New TIdentExpr.Create( "Length",New TVarExpr.Create( exprTmp ) )

			Local cmpExpr:TExpr=New TBinaryCompareExpr.Create( "<",New TVarExpr.Create( indexTmp ),lenExpr )

			Local indexExpr:TExpr=New TIndexExpr.Create( New TVarExpr.Create( exprTmp ),[New TVarExpr.Create( indexTmp )] )
			Local addExpr:TExpr=New TBinaryMathExpr.Create( "+",New TVarExpr.Create( indexTmp ),New TConstExpr.Create( New TIntType,"1" ) )

			Local cont:TContinueStmt
			
			If varlocal

				' array of object ?

				If TArrayType( expr.exprType ) And TObjectType(TArrayType( expr.exprType ).elemType) And (Not TObjectType(TArrayType( expr.exprType ).elemType).classdecl.IsExtern() ..
							Or (TObjectType(TArrayType( expr.exprType ).elemType).classdecl.IsExtern() ..
							And IsPointerType(TArrayType( expr.exprType ).elemType))) Then

					Local cExpr:TExpr
					
					If TIdentType(varty) And TIdentType(varty).ident = "Object" Then
						cExpr = indexExpr
					Else
						cExpr = New TCastExpr.Create( varty, indexExpr,CAST_EXPLICIT )
					End If

					' local variable
					Local varTmp:TLocalDecl=New TLocalDecl.Create( varid,varty,cExpr )

					' local var as expression
					Local expr:TExpr=New TVarExpr.Create( varTmp )

					' var = Null
					expr=New TBinaryCompareExpr.Create( "=",expr, New TNullExpr.Create(TType.nullObjectType))

					' then continue
					Local thenBlock:TBlockDecl=New TBlockDecl.Create( block.scope )
					Local elseBlock:TBlockDecl=New TBlockDecl.Create( block.scope )
					cont = New TContinueStmt
					thenBlock.AddStmt cont

					block.stmts.AddFirst New TIfStmt.Create( expr,thenBlock,elseBlock )
					block.stmts.AddFirst New TAssignStmt.Create( "=",New TVarExpr.Create( indexTmp ),addExpr )
					block.stmts.AddFirst New TDeclStmt.Create( varTmp )

				Else
					Local varTmp:TLocalDecl=New TLocalDecl.Create( varid,varty,indexExpr )
					block.stmts.AddFirst New TAssignStmt.Create( "=",New TVarExpr.Create( indexTmp ),addExpr, True )
					block.stmts.AddFirst New TDeclStmt.Create( varTmp, True )
				End If
			Else
				
				If TArrayType( expr.exprType ) And TObjectType(TArrayType( expr.exprType ).elemType) Then
				' var = Null
					If Not varty Then
						varExpr = varExpr.Semant()
						varty = varExpr.exprType
						'Local decl:TValDecl = block.scope.FindValDecl(varid.ToLower())
						
						'If decl Then
						'	decl.Semant()
						'	
						'	varty = decl.ty.Copy()
						'End If
					End If

'					expr=New TBinaryCompareExpr.Create( "=",New TIdentExpr.Create( varid ), New TNullExpr.Create(TType.nullObjectType))
					expr=New TBinaryCompareExpr.Create( "=",varExpr, New TNullExpr.Create(TType.nullObjectType))

					' then continue
					Local thenBlock:TBlockDecl=New TBlockDecl.Create( block.scope )
					Local elseBlock:TBlockDecl=New TBlockDecl.Create( block.scope )
					cont = New TContinueStmt
					thenBlock.AddStmt cont

					block.stmts.AddFirst New TIfStmt.Create( expr,thenBlock,elseBlock )
					'block.stmts.AddFirst New TDeclStmt.Create( varTmp )

					block.stmts.AddFirst New TAssignStmt.Create( "=",New TVarExpr.Create( indexTmp ),addExpr, True )
'					block.stmts.AddFirst New TAssignStmt.Create( "=",New TIdentExpr.Create( varid ),New TCastExpr.Create( varty, indexExpr,CAST_EXPLICIT ), True )
					block.stmts.AddFirst New TAssignStmt.Create( "=",varExpr,New TCastExpr.Create( varty, indexExpr,CAST_EXPLICIT ), True )
				Else
					block.stmts.AddFirst New TAssignStmt.Create( "=",New TVarExpr.Create( indexTmp ),addExpr, True )
'					block.stmts.AddFirst New TAssignStmt.Create( "=",New TIdentExpr.Create( varid ),indexExpr, True )
					block.stmts.AddFirst New TAssignStmt.Create( "=",varExpr,indexExpr, True )
				End If

			EndIf

			Local whileStmt:TWhileStmt=New TWhileStmt.Create( cmpExpr,block,loopLabel, True )

			block=New TBlockDecl.Create( block.scope, True )
			block.AddStmt New TDeclStmt.Create( exprTmp, True )
			block.AddStmt New TDeclStmt.Create( indexTmp, True )
			block.AddStmt whileStmt
			
			If cont Then
				cont.loop = whileStmt
			End If

		Else If TObjectType( expr.exprType )
			Local tmpDecl:TDeclStmt

			If TInvokeExpr(expr) Or TInvokeMemberExpr(expr) Then
				Local tmpVar:TLocalDecl=New TLocalDecl.Create( "",expr.exprType,expr,,True )
				tmpVar.Semant()
				tmpDecl = New TDeclStmt.Create( tmpVar, True )
				expr = New TVarExpr.Create( tmpVar )
			End If

			Local enumerInit:TExpr=New TFuncCallExpr.Create( New TIdentExpr.Create( "ObjectEnumerator",expr ) )
			Local enumerTmp:TLocalDecl=New TLocalDecl.Create( "",Null,enumerInit,,True )

			Local hasNextExpr:TExpr=New TFuncCallExpr.Create( New TIdentExpr.Create( "HasNext",New TVarExpr.Create( enumerTmp ) ) )
			Local nextObjExpr:TExpr=New TFuncCallExpr.Create( New TIdentExpr.Create( "NextObject",New TVarExpr.Create( enumerTmp ) ) )

			Local cont:TContinueStmt
			
			If varlocal
'				Local varTmp:TLocalDecl=New TLocalDecl.Create( varid,varty,nextObjExpr )
'				block.stmts.AddFirst New TDeclStmt.Create( varTmp )

				Local cExpr:TExpr
				
				If TIdentType(varty) And TIdentType(varty).ident = "Object" Then
					cExpr = nextObjExpr
				Else
					cExpr = New TCastExpr.Create( varty, nextObjExpr,CAST_EXPLICIT )
				End If

				' local variable
				Local varTmp:TLocalDecl=New TLocalDecl.Create( varid,varty,cExpr)

				' local var as expression
				Local expr:TExpr=New TVarExpr.Create( varTmp )

				' var = Null
				expr=New TBinaryCompareExpr.Create( "=",expr, New TNullExpr.Create(TType.nullObjectType))

				' then continue
				Local thenBlock:TBlockDecl=New TBlockDecl.Create( block.scope, True )
				Local elseBlock:TBlockDecl=New TBlockDecl.Create( block.scope, True )
				cont = New TContinueStmt.Create(Null, True)
				thenBlock.AddStmt cont

				block.stmts.AddFirst New TIfStmt.Create( expr,thenBlock,elseBlock, True )
				block.stmts.AddFirst New TDeclStmt.Create( varTmp, True )
			Else

				If Not varty Then
					varExpr = varExpr.Semant()
					varty = varExpr.exprType
				End If
				
'				If Not varty Then
'					Local decl:TValDecl = block.scope.FindValDecl(varid.ToLower())
'					
'					If decl Then
'						decl.Semant()
'						
'						varty = decl.ty.Copy()
'					End If
'				End If
				
				' var = Null
'				Local expr:TExpr=New TBinaryCompareExpr.Create( "=",New TIdentExpr.Create( varid ), New TNullExpr.Create(TType.nullObjectType))
				Local expr:TExpr=New TBinaryCompareExpr.Create( "=",varExpr, New TNullExpr.Create(TType.nullObjectType))

				' then continue
				Local thenBlock:TBlockDecl=New TBlockDecl.Create( block.scope )
				Local elseBlock:TBlockDecl=New TBlockDecl.Create( block.scope )
				cont = New TContinueStmt
				thenBlock.AddStmt cont

				block.stmts.AddFirst New TIfStmt.Create( expr,thenBlock,elseBlock )
				'block.stmts.AddFirst New TDeclStmt.Create( varTmp )

'				block.stmts.AddFirst New TAssignStmt.Create( "=",New TIdentExpr.Create( varid ),New TCastExpr.Create( varty, nextObjExpr,CAST_EXPLICIT ))
				block.stmts.AddFirst New TAssignStmt.Create( "=",varExpr,New TCastExpr.Create( varty, nextObjExpr,CAST_EXPLICIT ))
			EndIf

			Local whileStmt:TWhileStmt=New TWhileStmt.Create( hasNextExpr,block, loopLabel, True )

			block=New TBlockDecl.Create( block.scope, True )
			If tmpDecl Then
				block.AddStmt tmpDecl
			End If
			block.AddStmt New TDeclStmt.Create( enumerTmp, True )
			block.AddStmt whileStmt
			
			If cont Then
				cont.loop = whileStmt
			End If

		Else
			InternalErr
		EndIf

		block.Semant
	End Method

	Method Trans$()
		_trans.EmitBlock block
	End Method

End Type



Type TIncbin

	Field file:String
	Field path:String
	Field id:Int
	Field length:Int

	Global count:Int

	Method Create:TIncbin(file:String, source:String)
		count :+ 1

		Self.file = file

		' find the file
		If Not FileType(file) Then
			' maybe relative to source
			Local dir:String = ExtractDir(source) + "/" + file
			If FileType(dir) = FILETYPE_FILE Then
				path = RealPath(dir)
			Else
				Return Null
			End If
		Else
			path = RealPath(file)
		End If

		id = count
		Return Self
	End Method

End Type

'***** Parser *****
Type TParser

	Field _toker:TToker
	Field _toke:String
	Field _tokeType:Int
	'Ronny: _tokerStack is unused
	'Field _tokerStack:TList=New TList'<TToker>

	Field _block:TBlockDecl
	Field _blockStack:TList=New TList'<TBlockDecl>
	Field _errStack:TStringList=New TStringList

	Field _app:TAppDecl
	Field _module:TModuleDecl

	Field _externCasts:TMap = New TMap

	Method SetErr(toker:TToker = Null)
		Local t:TToker = _toker
		If toker Then
			t = toker
		End If
		If t.Path()
			_errInfo=FormatError(t.Path(),t.Line(),0)
		EndIf
	End Method

	Method DoErr(error:String, toker:TToker = Null)
		SetErr(toker)
		Err error
	End Method

	Method PushBlock( block:TBlockDecl )
		If _block <> Null Then
			_blockStack.AddLast _block
		End If
		_errStack.AddLast _errInfo
		_block=block
	End Method

	Method PopBlock()
		_block=TBlockDecl(_blockStack.RemoveLast())
		_errInfo=String(_errStack.RemoveLast())
	End Method

	Method RealPath$( path$ )
		Local popDir$=CurrentDir()
		ChangeDir ExtractDir( _toker.Path() )
		path=BRL.FileSystem.RealPath( path )
		ChangeDir popDir
		Return path
	End Method

	Method ActualPath:String(path:String)
		Local dir:String = ExtractDir(path)
		Local origFile:String = StripDir(path)
		Local lowerFile:String = origFile.ToLower()
		
		Local actualDir:String = ExtractDir(RealPath(path))

		Local files:String[] = LoadDir(actualDir)
		For Local file:String = EachIn files

			If file.ToLower() = lowerFile Then
				If file <> origFile Then
					' we could raise as a warning instead, but an error encourages the user to fix their code ;-)
					Err "Actual file '" + file + "' differs in case with import '" + origFile + "'"
					
					' what we might do were we to warn instead...
					If dir Then
						Return dir + "/" + file
					Else
						Return file
					End If
				End If
				Exit
			End If
		Next
		Return path
	End Method
	

	Method NextToke$()
		Local toke$=_toke

		Repeat
			_toke=_toker.NextToke()
			_tokeType=_toker.TokeType()
		Until _tokeType<>TOKE_SPACE

		If _tokeType=TOKE_KEYWORD _toke=_toker._tokeLower

		If toke="," SkipEols

		Return _toke
	End Method

	Method NextTokeToker$(toker:TToker)
'		Local toke$=toker._toke

		Repeat
			toker.NextToke()
		Until toker.tokeType()<>TOKE_SPACE

		Return toker._toke
	End Method

	Method DescribeToke:String( toke:String )
		Select toke
			Case "~n"
				Return "end-of-line"
		End Select
		Return toke
	End Method

	Method CParse:Int( toke$ )
		If _toke.ToLower()<>toke
			Return False
		EndIf
		NextToke
		Return True
	End Method

	Method CParseToker:Int( toker:TToker, toke$ )
		If toker._toke.ToLower()<>toke
			Return False
		EndIf
		NextTokeToker(toker)
		Return True
	End Method

	Method Parse( toke$ )
		If Not CParse( toke )
			DoErr "Syntax error - expecting '"+toke+"'."
		EndIf
	End Method

	Method ParseToker( toker:TToker, toke$ )
		If Not CParseToker( toker, toke )
			DoErr "Syntax error - expecting '"+toke+"'.", toker
		EndIf
	End Method

	Method AtEos:Int()
		Return _toke="" Or _toke=";" Or _toke="~n" Or _toke="else"
	End Method

	Method SkipEols()
		While CParse( "~n" ) Or CParse(";")
		Wend
		SetErr
	End Method

	Method SkipEolsToker(toker:TToker)
		While CParseToker( toker, "~n" )
		Wend
		SetErr
	End Method

	Method ParseStringLit$()
		If _tokeType<>TOKE_STRINGLIT Err "Expecting string literal."
		Local str$=BmxUnquote( _toke )
		NextToke
		Return str
	End Method

	Method ParseIdent$()
		Select _toke
		Case "@" NextToke
		Case "string","object", "self"
		Default
			If _tokeType<>TOKE_IDENT Err "Syntax error - expecting identifier."
		End Select
		Local id$=_toke
		NextToke
		Return id
	End Method

	Method ParseIdentType:TIdentType()
		Local id$=ParseIdent()
'DebugLog "ParseIdentType : " + id
		If CParse( "." ) id:+"."+ParseIdent()
		If CParse( "." ) id:+"."+ParseIdent()

		Local args:TIdentType[]
		If CParse( "<" )
			Local nargs:Int
			Repeat
				Local arg:TIdentType=ParseIdentType()
				If args.Length=nargs args=args+ New TIdentType[10]
				args[nargs]=arg
				nargs:+1
			Until Not CParse(",")
			args=args[..nargs]
			Parse ">"
		EndIf
		Return New TIdentType.Create( id,args )
	End Method

	Method CParseIdentType:TIdentType( inner:Int=False )
		If _tokeType<>TOKE_IDENT Return Null
		Local id$=ParseIdent()
		While CParse( "." )
			If _tokeType<>TOKE_IDENT Return Null
			id:+"."+ParseIdent()
		Wend
		If Not CParse( "<" )
			If inner Return New TIdentType.Create( id,Null )
			Return Null
		EndIf
		Local args:TType[]
		Local nargs:Int
		Repeat
			Local arg:TType=CParsePrimitiveType()
			If Not arg
				arg=CParseIdentType( True )
				If Not arg Return Null
			EndIf
			While IsArrayDef()
				arg = ParseArrayType(arg)
			Wend
'			While CParse( "[]" )
'				arg=arg.ArrayOf()
'			Wend
			args = args + [arg]
			nargs :+ 1
		Until Not CParse(",")
		If Not CParse( ">" ) Return Null
		Return New TIdentType.Create( id,args )
	End Method

	Method CParsePrimitiveType:TType()
		If CParse( "string" ) Return TType.stringType
		If CParse( "object" ) Return New TIdentType.Create( "brl.classes.object" )

		Local ty:TType
		If CParse( "short" )
			ty = New TShortType
		Else If CParse( "byte" )
			ty = New TByteType
		Else If CParse( "int" )
			ty = New TIntType
		Else If CParse( "uint" )
			ty = New TUIntType
		Else If CParse( "float" )
			ty = New TFloatType
		Else If CParse( "long" )
			ty = New TLongType
		Else If CParse( "ulong" )
			ty = New TULongType
		Else If CParse( "double" )
			ty = New TDoubleType
		Else If CParse( "size_t" )
			ty = New TSizeTType
		Else If CParse( "int128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			ty = New TInt128Type
		Else If CParse( "float128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			ty = New TFloat128Type
		Else If CParse( "double128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			ty = New TDouble128Type
		Else If CParse( "float64" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			ty = New TFloat64Type
		Else If CParse( "wparam" ) Then
			If opt_platform <> "win32" Err "WParam types only available on Win32"
			ty = New TWParamType
		Else If CParse( "lparam" ) Then
			If opt_platform <> "win32" Err "LParam types only available on Win32"
			ty = New TLParamType
		End If

		While CParse("ptr")
			ty = TType.MapToPointerType(ty)
		Wend
		Return ty
	End	Method

	Method CParsePrimitiveNumberType:TType()
		If CParse( "short" ) Return New TShortType
		If CParse( "byte" ) Return New TByteType
		If CParse( "int" ) Return New TIntType
		If CParse( "uint" ) Return New TUIntType
		If CParse( "float" ) Return New TFloatType
		If CParse( "long" ) Return New TLongType
		If CParse( "ulong" ) Return New TULongType
		If CParse( "double" ) Return New TDoubleType
		If CParse( "size_t" ) Return New TSizeTType
		If CParse( "int128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TInt128Type
		End If
		If CParse( "float128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TFloat128Type
		End If
		If CParse( "double128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TDouble128Type
		End If
		If CParse( "float64" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TFloat64Type
		End If
		If CParse( "wparam" ) Then
			If opt_platform <> "win32" Err "WParam types only available on Win32"
			Return New TWParamType
		End If
		If CParse( "lparam" ) Then
			If opt_platform <> "win32" Err "LParam types only available on Win32"
			Return New TLParamType
		End If
	End	Method

	Method ParseNewType:TType()
		If CParse( "void" ) Return New TVoidType
		If CParse( "short" ) Return New TShortType
		If CParse( "byte" ) Return New TByteType
		If CParse( "int" ) Return New TIntType
		If CParse( "uint" ) Return New TUIntType
		If CParse( "float" ) Return New TFloatType
		If CParse( "string" ) Return TType.stringType
		If CParse( "object" ) Return New TIdentType.Create( "brl.classes.object" )
		If CParse( "long" ) Return New TLongType
		If CParse( "ulong" ) Return New TULongType
		If CParse( "double" ) Return New TDoubleType
		If CParse( "size_t" ) Return New TSizeTType
		If CParse( "int128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TInt128Type
		End If
		If CParse( "float128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TFloat128Type
		End If
		If CParse( "double128" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TDouble128Type
		End If
		If CParse( "float64" ) Then
			If opt_arch <> "x64" Err "Intrinsic types only available on x64"
			Return New TFloat64Type
		End If
		If CParse( "wparam" ) Then
			If opt_platform <> "win32" Err "WParam types only available on Win32"
			Return New TWParamType
		End If
		If CParse( "lparam" ) Then
			If opt_platform <> "win32" Err "LParam types only available on Win32"
			Return New TLParamType
		End If
		Return ParseIdentType()
	End Method

	Method ParseType:TType()
		Local ty:TType=CParsePrimitiveType()
		If ty Return ty
		Return ParseIdentType()
	End Method

	Method ParseConstNumberType:TType()
		Local ty:TType
		Select _toke
		Case "@"
			NextToke
			ty=New TByteType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "@@"
			NextToke
			ty=New TShortType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "%"
			NextToke
			ty=New TIntType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "#"
			NextToke
			ty=New TFloatType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "$"
			NextToke
			ty=New TStringType
		Case "!"
			NextToke
			ty=New TDoubleType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "%%"
			NextToke
			ty=New TLongType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case ":"
			NextToke
			ty=CParsePrimitiveNumberType()
			If Not ty Then
				If CParse("string") Then
					ty=New TStringType
				Else
					ty = ParseIdentType()
				End If
			Else
				While CParse("ptr")
					ty = TType.MapToPointerType(ty)
				Wend
			End If
		End Select

		While IsArrayDef()
			ty = ParseArrayType(ty)
		Wend
		'While CParse( "[]" )
		'	ty=New TArrayType.Create( ty )
		'Wend

		Return ty
	End Method

	Method ParseDeclType:TType()
		Local ty:TType
		Select _toke
		Case "@"
			NextToke
			ty=New TByteType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "@@"
			NextToke
			ty=New TShortType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "%"
			NextToke
			ty=New TIntType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "%%"
			NextToke
			ty=New TLongType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case "#"
			NextToke
			ty=New TFloatType

			If CParse("ptr") Then
				ty = TType.MapToPointerType(ty)
			End If
		Case "$"
			NextToke
			ty=New TStringType

			If CParse("z") Then
				ty._flags :| TType.T_CHAR_PTR
			Else If CParse("w") Then
				ty._flags :| TType.T_SHORT_PTR
			End If

		Case "!"
			NextToke
			ty=New TDoubleType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		Case ":"
			NextToke
			ty=ParseType()

			If CParse("ptr") Then
			
				' FIXME #200
				'If TStringType(ty) = Null And (TObjectType(ty) = Null Or (TObjectType(ty) <> Null And TObjectType(ty).classDecl.IsExtern())) And TArrayType(ty) = Null Then
					ty = TType.MapToPointerType(ty)
	
					While CParse("ptr")
						ty = TType.MapToPointerType(ty)
					Wend
				'Else
				'	ty = Null
				'End If

				If Not ty DoErr "Invalid Pointer type."
			End If

		Case "("
			' for Strict code, void will be converted to Int during semanting.
			ty=New TVoidType
		Default
			If _module.IsSuperStrict() Err "Illegal type expression."
			ty=New TIntType

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend
		End Select
		
		' array ?
		While IsArrayDef()
			ty = ParseArrayType(ty)
		Wend
		
		Return ty
	End Method

	Method ParseArrayExpr:TArrayExpr()
		Parse "["
		Local args:TExpr[],nargs:Int
		Repeat
			Local arg:TExpr=ParseExpr()
			If args.Length=nargs args=args + New TExpr[10]
			args[nargs]=arg
			nargs:+1
		Until Not CParse(",")
		args=args[..nargs]
		Parse "]"
		Return New TArrayExpr.Create( args )
	End Method

	' replaces While CParse( "[]" ) sections, with support for multi-dimension arrays
	Method ParseArrayType:TType(ty:TType)
		While True
			Local dims:Int = 1
			
			If CParse("[]") Then
				ty=New TArrayType.Create( ty )
				Exit
			End If
			
			If Not CParse("[") Then
				Exit
			End If
		
			While CParse( ",")
				dims :+ 1
			Wend
			
			Parse "]"
			
			ty=New TArrayType.Create( ty, dims )
			Exit
		Wend
		Return ty
	End Method
	
	Method IsArrayDef:Int()
		Local isDef:Int = True
		Local toker:TToker=New TToker.Copy(_toker)
		While True
			'Local dims:Int = 1
			
			If CParseToker(toker, "[]") Then
				Exit
			End If
			
			If Not CParseToker(toker, "[") Then
				isDef = False
				Exit
			End If
		
			While CParseToker(toker, ",")
				'dims :+ 1
			Wend
			
			If Not CParseToker(toker, "]") Then
				isDef = False
				Exit
			End If
			Exit
		Wend
		Return isDef
	End Method

	Method ParseArgs:TExpr[]( stmt:Int )
		Local args:TExpr[]

		If stmt
			If AtEos() Return args
		Else
			If _toke<>"(" Return args
		EndIf

		Local nargs:Int,eat:Int

		If _toke="("
			If stmt
				Local toker:TToker=New TToker.Copy(_toker),bra:Int=1
				Repeat
					toker.NextToke
					toker.SkipSpace
					Select toker.Toke().ToLower()
					Case "","else"
						Err "Parenthesis mismatch error."
					Case "(","["
						bra:+1
					Case "]",")"
						bra:-1
						If bra Continue
						toker.NextToke
						toker.SkipSpace
						Select toker.Toke().ToLower()
						Case ".","(","[","",";","~n","else"
							eat=True
						End Select
						Exit
					Case ","
						If bra<>1 Continue
						eat=True
						Exit
					End Select
				Forever
			Else
				eat=True
			EndIf
			If eat And NextToke()=")"
				NextToke
				Return args
			EndIf
		EndIf

		Repeat
			Local arg:TExpr
			If _toke And _toke<>"," arg=ParseExpr()
			If args.Length=nargs args=args + New TExpr[10]
			args[nargs]=arg
			nargs:+1
		Until Not CParse(",")
		args=args[..nargs]

		If eat Parse ")"

		Return args
	End Method

	Method ParsePrimaryExpr:TExpr( stmt:Int )

		Local expr:TExpr

		Select _toke.ToLower()
		Case "("
			NextToke
			expr=ParseExpr()
			Parse ")"
		Case "["
			expr=ParseArrayExpr()
		Case "[]"
			NextToke
			expr=New TConstExpr.Create( TType.emptyArrayType,"" )
		Case "."
			expr=New TScopeExpr.Create( _module )
		Case "new"
			NextToke
			
			If _toke = "(" Then
				' call constructor
				expr=New TNewExpr.Create( ParseArgs(stmt) )
			Else
				Local ty:TType=ParseType()
	
				While CParse("ptr")
					ty = TType.MapToPointerType(ty)
				Wend
	
				If _toke = "[" Or _toke = "[]" Then
					Local depth:Int = 0
					Local ln:TExpr[]
					Local tmpTy:TType = ty.Copy()
	
					Repeat
						Local dims:Int = 1
						
						If CParse("[]") Then
							tmpTy=New TArrayType.Create( tmpTy )
							depth :+ 1
							Continue
						End If
	
						' looking for an array with expression					
						If Not ln Then
							Parse "["
						Else
							If Not CParse("[") Then
								Exit
							Else
								Err "Unexpected '[' after array size declaration"
							End If
						End If
	
						Repeat
							If CParse(",") Then
								dims :+ 1
								Continue
							End If
							If CParse("]") Exit
							ln = ln + [ParseExpr()]
							If CParse("]") Exit
							Parse(",")
							dims :+ 1
						Forever
	
						If Not ln Then
							tmpTy=New TArrayType.Create( tmpTy, dims )
						End If
					Forever
	
					If ln Then
						ty = tmpTy
					End If
	
	'				Repeat
						'If CParse( "[" )
	'					Repeat
	'						ln = ln + [ParseExpr()]
	'						If CParse("]") Exit
	'						Parse ","
	'					Forever
						'Parse "]"
	'					ty = ParseArrayType(ty)
	'				Forever
					'While CParse( "[]" )
					'	ty=New TArrayType.Create( ty)
					'Wend
					expr=New TNewArrayExpr.Create( ty,ln )
				Else
					expr=New TNewObjectExpr.Create( ty,ParseArgs( stmt ) )
				EndIf
			End If
		Case "null"
			NextToke
			expr = New TNullExpr.Create(TType.nullObjectType)
			'expr=New TConstExpr.Create( TType.nullObjectType,"" )
		Case "true"
			NextToke
			expr=New TConstExpr.Create( New TIntType,"1" )
		Case "false"
			NextToke
			expr=New TConstExpr.Create( New TIntType,"" )
		Case "int","long","float","double","object","short","byte","size_t","uint","ulong","int128","float64","float128","double128","lparam","wparam"
			Local id$=_toke
			Local ty:TType=ParseType()

			If TIntType(ty) And id.ToLower() <> "int" Then
				Select id.ToLower()
					Case "byte"
						ty = New TByteType
					Case "short"
						ty = New TShortType
					Case "uint"
						ty = New TUIntType
					Case "long"
						ty = New TLongType
					Case "ulong"
						ty = New TULongType
					Case "float"
						ty = New TFloatType
					Case "double"
						ty = New TDoubleType
					Case "size_t"
						ty = New TSizeTType
					Case "int128"
						If opt_arch <> "x64" Err "Intrinsic types only available on x64"
						ty = New TInt128Type
					Case "float128"
						If opt_arch <> "x64" Err "Intrinsic types only available on x64"
						ty = New TFloat128Type
					Case "double128"
						If opt_arch <> "x64" Err "Intrinsic types only available on x64"
						ty = New TDouble128Type
					Case "float64"
						If opt_arch <> "x64" Err "Intrinsic types only available on x64"
						ty = New TFloat64Type
					Case "wparam"
						If opt_platform <> "win32" Err "WParam types only available on Win32"
						ty = New TWParamType
					Case "lparam"
						If opt_platform <> "win32" Err "LParam types only available on Win32"
						ty = New TLParamType
				End Select
			End If

			While CParse("ptr")
				ty = TType.MapToPointerType(ty)
			Wend

			' array
			ty = ParseArrayType(ty)
			'While CParse( "[]" )
			'	ty=New TArrayType.Create( ty)
			'Wend

			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TCastExpr.Create( ty,expr,CAST_EXPLICIT )
			Else
				expr=ParseExpr()
				
				If TBinaryExpr(expr) Then
					' cast lhs and apply to rhs
					Local cexpr:TCastExpr=New TCastExpr.Create( ty,TBinaryExpr(expr).lhs,CAST_EXPLICIT )
					TBinaryExpr(expr).lhs = cexpr 
				Else
					expr=New TCastExpr.Create( ty,expr,CAST_EXPLICIT )
				End If

			EndIf
		Case "sizeof"
			NextToke

			Local ty:TType = ParseConstNumberType()
			If ty Then
				If Not TIntType(ty) Then
					Err "Return type for 'SizeOf' must be Int"
				End If
			End If

			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TSizeOfExpr.Create( expr )
			Else
				expr=ParseExpr()
				expr=New TSizeOfExpr.Create( expr )
			EndIf
		Case "len"
			NextToke
			
			Local ty:TType = ParseConstNumberType()
			If ty Then
				If Not TIntType(ty) Then
					Err "Return type for 'Len' must be Int"
				End If
			End If

			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TLenExpr.Create( expr )
			Else
				expr=ParseExpr()
				expr=New TLenExpr.Create( expr )
			EndIf
		Case "abs"
			NextToke
			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TAbsExpr.Create( expr )
			Else
				expr=ParseExpr()
				expr=New TAbsExpr.Create( expr )
			EndIf
		Case "min"
			NextToke
			' optional brackets
			Local b:Int = CParse( "(" )

			expr=ParseExpr()
			Parse ","
			Local expr2:TExpr=ParseExpr()

			If b Then
				Parse ")"
			End If

			expr=New TMinExpr.Create( expr, expr2 )
		Case "max"
			NextToke
			' optional brackets
			Local b:Int = CParse( "(" )

			expr=ParseExpr()
			Parse ","
			Local expr2:TExpr=ParseExpr()

			If b Then
				Parse ")"
			End If

			expr=New TMaxExpr.Create( expr, expr2 )
		Case "asc"
			NextToke

			Local ty:TType = ParseConstNumberType()
			If ty Then
				If Not TIntType(ty) Then
					Err "Return type for 'Asc' must be Int"
				End If
			End If
			
			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TAscExpr.Create( expr )
			Else
				expr=ParseExpr()
				expr=New TAscExpr.Create( expr )
			EndIf
		Case "chr"
			NextToke

			Local ty:TType = ParseConstNumberType()
			If ty Then
				If Not TStringType(ty) Then
					Err "Return type for 'Chr' must be String"
				End If
			End If
			
			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TChrExpr.Create( expr )
			Else
				expr=ParseExpr()
				expr=New TChrExpr.Create( expr )
			EndIf
		Case "sgn"
			NextToke
			' optional brackets
			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TSgnExpr.Create( expr )
			Else
				expr=ParseExpr()
				expr=New TSgnExpr.Create( expr )
			EndIf
		Case "string"
			Local id$=_toke
			Local ty:TType=ParseType()

			If CParse("ptr") Then
				ty = TType.MapToPointerType(ty)
			End If

			' string array
			ty = ParseArrayType(ty)
			'While CParse( "[]" )
			'	ty=New TArrayType.Create( ty)
			'Wend

			If CParse( "(" )
				expr=ParseExpr()
				Parse ")"
				expr=New TCastExpr.Create( ty,expr,CAST_EXPLICIT )
			Else
				expr=New TIdentExpr.Create( id )
			EndIf

		Case "varptr"
			NextToke
			expr=ParseExpr()
			expr=New TCastExpr.Create( New TVarPtrType, expr, CAST_EXPLICIT )
		Case "pi"
			NextToke
			expr=New TConstExpr.Create( New TDoubleType, Pi )
		Case "self"
			NextToke
			expr=New TSelfExpr
		Case "super"
			NextToke
			Parse "."
			If _toke="new"
				Err "Call to super class constructor must be first statement in a constructor."
			EndIf
			Local id$=ParseIdent()
			
			' eat any type stuff
			ParseConstNumberType()

			expr=New TInvokeSuperExpr.Create( id,ParseArgs( stmt ) )
		Default
			Select _tokeType
			Case TOKE_IDENT
				Local tok:TToker=New TToker.Copy( _toker )

				Local ty:TType=CParseIdentType()
				If ty
					expr=New TIdentTypeExpr.Create( ty )
				Else
					_toker=tok
					_toke=_toker.Toke()
					_tokeType=_toker.TokeType()
					expr=New TIdentExpr.Create( ParseIdent() )
					ty = ParseConstNumberType()
					
					If TArrayType(ty) Then
						If Not TArrayType(ty).elemType Then
							TArrayType(ty).elemType = New TIdentType.Create(TIdentExpr(expr).ident)
							expr=New TIdentTypeExpr.Create( ty )
						End If
					End If

				EndIf

				'expr=New TIdentExpr.Create( ParseIdent() )
			Case TOKE_INTLIT

				expr=New TConstExpr.Create( New TIntType,_toke )
				NextToke

				Local ty:TType = ParseConstNumberType()
				If ty Then
					TConstExpr(expr).UpdateType(ty)
				End If
			Case TOKE_LONGLIT
				expr=New TConstExpr.Create( New TLongType,_toke )
				NextToke
				
				Local ty:TType = ParseConstNumberType()
				If ty Then
					TConstExpr(expr).UpdateType(ty)
				End If
			Case TOKE_FLOATLIT
				expr=New TConstExpr.Create( New TFloatType,_toke )
				NextToke

				Local ty:TType = ParseConstNumberType()
				If ty Then
					TConstExpr(expr).ty = ty
				End If
			Case TOKE_STRINGLIT
				expr=New TConstExpr.Create( TType.stringType,BmxUnquote( _toke ) )
				_app.mapStringConsts(BmxUnquote( _toke ))
				NextToke
			Default
				Err "Expecting expression but encountered '"+_toke+"'"
			End Select
		End Select

		Repeat

			Select _toke
			Case "."
				NextToke
				
				expr=New TIdentExpr.Create( ParseIdent(),expr )
				
				ParseConstNumberType()
'DebugLog expr.ToString()
			Case "("

				If expr = Null Then
					NextToke
					expr=ParseExpr()
					Parse ")"
				Else
					expr=New TFuncCallExpr.Create( expr,ParseArgs( stmt ) )
				End If

			Case "["
				NextToke
				If CParse( ".." )
					If _toke="]"
						expr=New TSliceExpr.Create( expr,Null,Null )
					Else
						expr=New TSliceExpr.Create( expr,Null,ParseExpr() )
					EndIf
					Parse "]"
				Else
					Local from:TExpr=ParseExpr()
					If CParse( ".." )
						If _toke="]"
							expr=New TSliceExpr.Create( expr,from,Null )
						Else
							expr=New TSliceExpr.Create( expr,from,ParseExpr() )
						EndIf
						Parse "]"
					Else
						Local ind:TExpr[] = [from]
						Repeat
							If CParse("]") Then
								Exit
							End If

							Parse ","

							ind = ind + [ParseExpr()]
						Forever

						expr=New TIndexExpr.Create( expr,ind )
					EndIf
				EndIf
			Default
				Return expr
			End Select
		Forever

	End Method

	Method ParseUnaryExpr:TExpr()

		SkipEols

		Local op$=_toke
		Select op
		Case "+","-","~~","not"
			NextToke
			Local expr:TExpr=ParseUnaryExpr()
			Return New TUnaryExpr.Create( op,expr )
		End Select
		Return ParsePrimaryExpr( False )
	End Method

	Method ParsePowExpr:TExpr()
		Local expr:TExpr=ParseUnaryExpr()
		Repeat
			Local op$=_toke
			Select op
			Case "^"
				NextToke
				Local rhs:TExpr=ParseUnaryExpr()
				expr=New TBinaryMathExpr.Create( op,expr,rhs )
			Default
				Return expr
			End Select
		Forever
	End Method

	Method ParseMulDivExpr:TExpr()
		Local expr:TExpr=ParsePowExpr()
		Repeat
			Local op$=_toke
			Select op
			Case "*","/","mod","shl","shr", "sar"
				NextToke
				Local rhs:TExpr=ParsePowExpr()
				expr=New TBinaryMathExpr.Create( op,expr,rhs )
			Default
				Return expr
			End Select
		Forever
	End Method

	Method ParseAddSubExpr:TExpr()
		Local expr:TExpr=ParseMulDivExpr()
		Repeat
			Local op$=_toke
			Select op
			Case "+","-"
				NextToke
				Local rhs:TExpr=ParseMulDivExpr()
				expr=New TBinaryMathExpr.Create( op,expr,rhs )
			Default
				Return expr
			End Select
		Forever
	End Method

	Method ParseBitandExpr:TExpr()
		Local expr:TExpr=ParseAddSubExpr()
		Repeat
			Local op$=_toke
			Select op
			Case "&","~~"
				NextToke
				Local rhs:TExpr=ParseAddSubExpr()
				expr=New TBinaryMathExpr.Create( op,expr,rhs )
			Default
				Return expr
			End Select
		Forever
	End Method

	Method ParseBitorExpr:TExpr()
		Local expr:TExpr=ParseBitandExpr()
		Repeat
			Local op$=_toke
			Select op
			Case "|"
				NextToke
				Local rhs:TExpr=ParseBitandExpr()
				expr=New TBinaryMathExpr.Create( op,expr,rhs )
			Default
				Return expr
			End Select
		Forever
	End Method

	Method ParseCompareExpr:TExpr()
		Local expr:TExpr=ParseBitorExpr()
		Repeat
			Local op$=_toke
			Select op
			Case "=","<",">","<=","=<",">=","=>","<>"
				NextToke
				' <= or =>
				If (op=">" And (_toke="=")) Or (op="=" And (_toke=">"))
					op:+_toke
					NextToke
				' <> or <= or =<
				Else If (op="<" And _toke=">") Or (op="<" And _toke="=") Or (op="=" And _toke="<")
					op:+_toke
					NextToke
				EndIf
				Local rhs:TExpr=ParseBitorExpr()
				expr=New TBinaryCompareExpr.Create( op,expr,rhs )
			Default
				Return expr
			End Select
		Forever
	End Method

	Method ParseAndExpr:TExpr()
		Local expr:TExpr=ParseCompareExpr()
		Repeat
			Local op$=_toke
			If op="and"
				NextToke
				Local rhs:TExpr=ParseCompareExpr()
				expr=New TBinaryLogicExpr.Create( op,expr,rhs )
			Else
				Return expr
			EndIf
		Forever
	End Method

	Method ParseOrExpr:TExpr()
		Local expr:TExpr=ParseAndExpr()
		Repeat
			Local op$=_toke
			If op="or"
				NextToke
				Local rhs:TExpr=ParseAndExpr()
				expr=New TBinaryLogicExpr.Create( op,expr,rhs )
			Else
				Return expr
			EndIf
		Forever
	End Method

	Method ParseExpr:TExpr()
		Return ParseOrExpr()
	End Method

Rem
	unused atm
	Method ReadTillNextToken:string(amount:int=1)
		'copy current toker and move one token forward
		local tok:TToker = New TToker.Copy(_toker)
		local result:string = _toker._toke
		for local i:int = 0 until amount
			NextTokeToker(tok)
			result :+ " "+ tok._toke
		Next
		return _toker._toke+" "+tok._toke
	End Method
End Rem
	
	Method ParseIfStmt( term$, elseIfEndIfReadAheadCheck:Int = False )

		Local tok:TToker
		'rules:
		'- the command "end" cannot be used as condition
		'- "endif" or "end if" is not allowed in singleline-ifs

		'if current toke is "if", move on to the next toke
		CParse "if"

		'read in the expression/condition following after "if"
		Local expr:TExpr=ParseExpr()

		'if current toke is "then", move to next, else stay at this
		'position -> makes "then" usage voluntary
		CParse "then"

		'create empty blocks for then/else
		Local thenBlock:TBlockDecl=New TBlockDecl.Create( _block )
		Local elseBlock:TBlockDecl=New TBlockDecl.Create( _block )

		'define if the current if is a "singleline if"
		'"singleline ifs" are not allowed to contain "endif" "end if"
		Local singleLineIf:Int = True

		'to know if it is a multiline or singleline if we have to check
		'for certain situations
		Select _toke
			Case "~n"
				'if a  <- newline
				'  print "a"
				'endif
				singleLineIf = False
			Case "if"
				'another "if" means the outer one is a singleline if!
				singleLineIf = True
			Case "else"
				'if ReadTillNextToken().toLower() = "else if"
				'	print "IF: found if X then Y else if ..."
				'else
				'	print "IF: found if X then Y else ..."
				'endif

				'also read "else if"
				singleLineIf = True
			Case "elseif"
				singleLineIf = True
		End Select


		'set thenBlock as the active block
		PushBlock( thenBlock )

		'now check each toke until we reach our desired term
		'for singleline-if this is "~n", for multiline-if this is
		'"endif" or "end if"
		If singleLineIf
			term = "~n"
		Else
			term = "end" 'endif, end if
		EndIf

		'only read until reaching the limit - or no valid toke was returned
		While _toke <> term
			Local currentToke:String = _toke

			Select currentToke
				'file end before endif/end/elseif
				Case ""
                   Err("Expecting expression but encountered end-of-file")
				'"endif" / "end if"
				Case "endif", "end"
					NextToke()
				
					If singleLineIf Then
						'check for "end"-command ("if a=1 end")
						If currentToke = "end" And (currentToke + _toke) <> "endif" Then
							ParseEndStmt(False)
						'found "end if"
						Else
							Err "'End If' without matching 'If'"
							Exit
						EndIf
					EndIf
				
					'If currentToke = "endif" or (currentToke + _toke)="endif"
					'	'do something if "endif/end if" happens ?
					'Endif

					'finish this if-statement
					Exit

				'"else" and "elseif" / "else if"
				Case "else","elseif"
'					print "parsing "+currentToke

					If _block = elseBlock
						Err("If statement can only have one 'else' block.")
					EndIf

					'switch from thenBlock to elseBlock
					PopBlock()
					PushBlock(elseBlock)

					'move to next token, might contain "if" for "else if"
					'doing it this way avoids to parse "elseif if" as
					'else-statement
					NextToke()
					If currentToke = "elseif" Or (currentToke + _toke)="elseif"
						'create a new if-statement and exit current handling
						ParseIfStmt(term, True)
						Exit
					EndIf
					
				Default
					'parse the current and next tokens
					ParseStmt()

					currentToke = _toke

					'handle the end-function and "end if"
					Select currentToke
						Case "end"
							'check next toke too
							NextToke()

							'found end-function
							If currentToke = "end" And (currentToke + _toke)<>"endif"
'								print "   parsing end .... handling"
								ParseEndStmt(False)
							'found "end if"
							Else
								If CParse("if") Then
									If singleLineIf Then
										Err "'End If' without matching 'If'"
									End If
									
									Exit
								End If
								
								'NextToke()
							EndIf
					End Select
			End Select
		Wend
		
		'change block
		PopBlock()

		'create a if-then[-else]-statement
		Local stmt:TIfStmt=New TIfStmt.Create( expr,thenBlock,elseBlock )
		_block.AddStmt stmt
	End Method


	Method ParseWhileStmt(loopLabel:TLoopLabelDecl = Null)
		Parse "while"

		Local expr:TExpr=ParseExpr()
		Local block:TBlockDecl=New TBlockDecl.Create( _block )

		PushBlock block
		While Not CParse( "wend" ) And Not CParse( "endwhile" )
'			If CParse( "end" )
'				CParse "while"
'				Exit
'			EndIf
			ParseStmt

			' to handle "end" statement
			If _toke = "end" Then
				NextToke
				If _toke = "while" Then
					NextToke
					Exit
				Else
					ParseEndStmt(False)
				End If
			End If
		Wend
		PopBlock

		Local stmt:TWhileStmt=New TWhileStmt.Create( expr,block,loopLabel )

		_block.AddStmt stmt
	End Method

	Method ParseRepeatStmt(loopLabel:TLoopLabelDecl = Null)

		Parse "repeat"

		Local block:TBlockDecl=New TBlockDecl.Create( _block )

		PushBlock block
		While _toke<>"until" And _toke<>"forever"
			ParseStmt
		Wend
		PopBlock

		SetErr

		Local expr:TExpr
		If CParse( "until" )
			expr=ParseExpr()
		Else
			Parse "forever"
			expr=New TConstExpr.Create( New TBoolType,"" )
		EndIf

		Local stmt:TRepeatStmt=New TRepeatStmt.Create( block,expr,loopLabel )

		_block.AddStmt stmt
	End Method

	Method ParseForStmt(loopLabel:TLoopLabelDecl = Null)

		Parse "for"

		Local varid$,varty:TType,varlocal:Int
		Local varExpr:TExpr

		If CParse( "local" )
			varlocal=True
			varid=ParseIdent()
			'If Not CParse( ":=" )
				varty=ParseDeclType()
				If varty._flags & (TType.T_CHAR_PTR | TType.T_SHORT_PTR) Then
					DoErr "Illegal variable type"
				End If

				If _toke = "(" Then

					Local fdecl:TFuncDecl = ParseFuncDecl("", FUNC_PTR | DECL_ARG)

					If Not varty Then
						varty = New TFunctionPtrType
						TFunctionPtrType(varty).func = fdecl
					Else
						fdecl.retType = varty
						varty = New TFunctionPtrType
						TFunctionPtrType(varty).func = fdecl
					End If

					TFunctionPtrType(varty).func.ident = varid

					' function pointer array ?
					While IsArrayDef()
						varty = ParseArrayType(varty)
					Wend
				End If
				
				Parse( "=" )
			'EndIf
		Else
			varlocal=False
			
			varExpr=ParsePrimaryExpr( False )
			
			'varExpr = New TIdentExpr.Create( ParseIdent(),varExpr )

			'ParseConstNumberType()
			
'			varid=ParseIdent()

			'While Cparse(".")
				'NextToke
				
			'	varExpr = New TIdentExpr.Create( ParseIdent(),varExpr )
				
			'	ParseConstNumberType()
			'Wend
			' eat any type stuff
'			ParseConstNumberType()

			Parse "="
		EndIf

		If CParse( "eachin" )
			Local expr:TExpr=ParseExpr()
			Local block:TBlockDecl=New TBlockDecl.Create( _block )

			PushBlock block
			While Not CParse( "next" )
				'If CParse( "end" )
				'	CParse "for"
				'	Exit
				'EndIf
				ParseStmt
			Wend
			PopBlock

			Local stmt:TForEachinStmt=New TForEachinStmt.Create( varid,varty,varlocal,expr,block,loopLabel, varExpr )

			_block.AddStmt stmt

			Return
		EndIf

		Local from:TExpr=ParseExpr()

		Local op$
		If CParse( "to" )
			op="<="
		Else If CParse( "until" )
			op="<"
		Else
			Err "Expecting 'To' or 'Until'."
		EndIf

		Local term:TExpr=ParseExpr()

		Local stp:TExpr

		If CParse( "step" )
			stp=ParseExpr()
		Else
			stp=New TConstExpr.Create( New TIntType,"1" )
		EndIf

		Local init:TStmt,expr:TExpr,incr:TStmt

		If varlocal
			Local indexVar:TLocalDecl=New TLocalDecl.Create( varid,varty,New TCastExpr.Create( varty,from,1 ),0 )
			init=New TDeclStmt.Create( indexVar )
			expr=New TBinaryCompareExpr.Create( op,New TVarExpr.Create( indexVar ),New TCastExpr.Create( varty,term,1 ) )
			incr=New TAssignStmt.Create( "=",New TVarExpr.Create( indexVar ),New TBinaryMathExpr.Create( "+",New TVarExpr.Create( indexVar ),New TCastExpr.Create( varty,stp,1 ) ) )
		Else
			' varty is NULL here for the casts. We will back-populate it later.
'			init=New TAssignStmt.Create( "=",New TIdentExpr.Create( varid ),from )
'			expr=New TBinaryCompareExpr.Create( op,New TIdentExpr.Create( varid ),New TCastExpr.Create( varty,term,1 ) )
'			incr=New TAssignStmt.Create( "=",New TIdentExpr.Create( varid ),New TBinaryMathExpr.Create( "+",New TIdentExpr.Create( varid ),New TCastExpr.Create( varty,stp,1 ) ) )
			init=New TAssignStmt.Create( "=",varExpr,from )
			expr=New TBinaryCompareExpr.Create( op,varExpr,New TCastExpr.Create( varty,term,1 ) )
			incr=New TAssignStmt.Create( "=",varExpr,New TBinaryMathExpr.Create( "+",varExpr,New TCastExpr.Create( varty,stp,1 ) ) )
		EndIf

		Local block:TBlockDecl=New TBlockDecl.Create( _block )

		PushBlock block
		While Not CParse( "next" )
			'If CParse( "end" )
			'	CParse "for"
			'	Exit
			'EndIf
			ParseStmt
		Wend
		PopBlock

		NextToke

		Local stmt:TForStmt=New TForStmt.Create( init,expr,incr,block,loopLabel )

		_block.AddStmt stmt
	End Method

	Method ParseDefDataStmt(label:TLoopLabelDecl = Null)
		Parse "defdata"
		
		If AtEos() Then
			Err "Expecting expression but encountered " + DescribeToke(_toke)
		End If
		
		Local args:TExpr[]
		Local nargs:Int

		Repeat
			Local arg:TExpr
			If _toke And _toke<>"," arg=ParseExpr()
			If args.Length=nargs args=args + New TExpr[10]
			args[nargs]=arg
			nargs:+1
		Until Not CParse(",")
		args=args[..nargs]
		
		Local dataLabel:TDataLabelDecl
		If label Then
			dataLabel = New TDataLabelDecl.Create(label.ident, label.attrs)
		End If
		
		Local decl:TDefDataDecl = New TDefDataDecl.Create(args, dataLabel)
		
		_app.dataDefs.AddLast(decl)
		
	End Method

	Method ParseReadDataStmt()
		Parse "readdata"

		Local args:TExpr[]
		Local nargs:Int

		If Not AtEos() Then
			Repeat
				Local arg:TExpr
				If _toke And _toke<>"," arg=ParseExpr()
				If args.Length=nargs args=args + New TExpr[10]
				args[nargs]=arg
				nargs:+1
			Until Not CParse(",")
			args=args[..nargs]
		End If

		_block.AddStmt New TReadDataStmt.Create( args )
	End Method

	Method ParseRestoreDataStmt()
		Parse "restoredata"
		
		Local expr:TExpr = ParseExpr()

		_block.AddStmt New TRestoreDataStmt.Create( expr )
	End Method
	
	Method ParseReturnStmt()
		Parse "return"
		Local expr:TExpr
		If Not AtEos() expr=ParseExpr()
		_block.AddStmt New TReturnStmt.Create( expr )
	End Method

	Method ParseExitStmt()
		Parse "exit"
		Local expr:TExpr
		If Not AtEos() expr=ParseExpr()
		_block.AddStmt New TBreakStmt.Create(expr)
	End Method

	Method ParseContinueStmt()
		Parse "continue"
		Local expr:TExpr
		If Not AtEos() expr=ParseExpr()
		_block.AddStmt New TContinueStmt.Create(expr)
	End Method

	Method ParseTryStmt()
		Parse "try"

		Local block:TBlockDecl=New TBlockDecl.Create( _block )
		Local catches:TList=New TList

		PushBlock block
		While _toke<>"end" And _toke<>"endtry"
			If CParse( "catch" )
				Local id:String=ParseIdent()
				Local ty:TType
				If Not CParse(":") Then
					Parse "$"
					ty= TType.stringType
				Else
					ty=ParseType()
				End If
				Local init:TLocalDecl=New TLocalDecl.Create( id,ty,Null,0 )
				Local block:TBlockDecl=New TBlockDecl.Create( _block )
				catches.AddLast(New TCatchStmt.Create( init,block ))
				PopBlock
				PushBlock block
			Else
				ParseStmt

				If _toke = "end" Then
					NextToke
					If _toke = "try" Then
						' we are done with the try statement
						Exit
					Else
						ParseEndStmt(False)
					End If
				End If

			End If
		Wend

		PopBlock
		
		If Not CParse("endtry") Then
			' TODO : handle case of no catch - perhaps throw the exception again.
			'If Not catches.Length() Err "Try block must have at least one catch block"
			NextToke
			CParse "try"
		End If

		_block.AddStmt New TTryStmt.Create( block,TCatchStmt[](catches.ToArray()) )
	End Method

	Method ParseThrowStmt()
		Parse "throw"
		Local expr:TExpr = ParseExpr()
		_block.AddStmt New TThrowStmt.Create( expr )
	End Method

	Method ParseReleaseStmt()
		Parse "release"
		Local expr:TExpr = ParseExpr()
		_block.AddStmt New TReleaseStmt.Create( expr )
	End Method
	
	Method ParseAssertStmt()
		Parse "assert"
		Local expr:TExpr = ParseExpr()
		Local elseExpr:TExpr

		If _toke = "," Or _toke = "else" Then
			NextToke
			elseExpr = ParseExpr()
		End If

		_block.AddStmt New TAssertStmt.Create( expr, elseExpr )
	End Method

	Method ParseEndStmt(eatEnd:Int = True)
		If eatEnd Then
			Parse "end"
		End If

		_block.AddStmt New TEndStmt.Create( )
	End Method

	Method ParseSelectStmt()
		Parse "select"

		Local block:TBlockDecl=_block

		Local tmpVar:TLocalDecl=New TLocalDecl.Create( "",Null,ParseExpr(),,True )

		block.AddStmt New TDeclStmt.Create( tmpVar )

		While _toke<>"end" And _toke<>"default" And _toke<>"endselect"
			SetErr
			Select _toke
			Case "~n"
				NextToke
			Case "case"
				NextToke
				Local comp:TExpr
				Repeat
					Local expr:TExpr=New TVarExpr.Create( tmpVar )
					expr=New TBinaryCompareExpr.Create( "=",expr,ParseExpr() )
					If comp
						comp=New TBinaryLogicExpr.Create( "or",comp,expr )
					Else
						comp=expr
					EndIf
				Until Not CParse(",")

				Local thenBlock:TBlockDecl=New TBlockDecl.Create( _block )
				Local elseBlock:TBlockDecl=New TBlockDecl.Create( _block )

				Local ifstmt:TIfStmt=New TIfStmt.Create( comp,thenBlock,elseBlock )
				block.AddStmt ifstmt
				block=ifstmt.thenBlock

				PushBlock block
				Local fin:Int = False
				While _toke<>"case" And _toke<>"default" And _toke<>"end" And _toke<>"endselect"
					ParseStmt

					If _toke = "end" Then
						NextToke
						If _toke = "select" Then
							' we are done with the select statement, full exit
							fin = True
							Exit
						Else
							ParseEndStmt(False)
						End If
					End If
				Wend
				PopBlock

				block=elseBlock
				If fin Exit
			Default
				Err "Syntax error - expecting 'Case', 'Default' or 'End'."
			End Select
		Wend

		If _toke="default"
			NextToke
			PushBlock block
			While _toke<>"end" And _toke<>"endselect"
				SetErr
				Select _toke
				Case "case"
					Err "Case can not appear after default."
				Case "default"
					Err "Select statement can have only one default block."
				End Select
				ParseStmt

				If _toke = "end" Then
					NextToke
					If _toke = "select" Then
						Exit
					Else
						ParseEndStmt(False)
					End If
				End If
			Wend
			PopBlock
		EndIf

		SetErr

		If Not CParse("endselect") Then
			If Not CParse("select")
				Parse "end"
				Parse "select"
			End If
		End If
	End Method

	Method ParseExternBlock(mdecl:TModuleDecl, attrs:Int)

		NextToke

		If _tokeType=TOKE_STRINGLIT
			Local api:String = ParseStringLit().ToLower()
			If api = "win32" Then
				attrs:| DECL_API_WIN32
			End If
		End If


		attrs = attrs | DECL_EXTERN
		If CParse( "private" ) attrs=attrs|DECL_PRIVATE

		While _toke<>"endextern"
			If CParse( "end" )
				Parse "extern"
				Exit
			EndIf

			SetErr
			Select _toke
				Case "~n"
					NextToke
				Case "const","global"
					mdecl.InsertDecls ParseDecls( _toke,attrs )
				Case "struct"
					mdecl.InsertDecl ParseClassDecl( _toke,attrs | CLASS_STRUCT )
				Case "type"
					mdecl.InsertDecl ParseClassDecl( _toke,attrs )
				Case "function"
					mdecl.InsertDecl ParseFuncDecl( _toke,attrs )
				Case "interface"
					mdecl.InsertDecl ParseClassDecl( _toke,attrs | CLASS_INTERFACE )
				Default
					If _toke <> "end" And _toke <> "endextern" Then
						Err "Expecting expression but encountered '"+_toke+"'"
					End If
			End Select

		Wend
		
		If _toke="endextern" Then
			NextToke
		End If

	End Method

	Method ParseStmt()
		SetErr
		Select _toke
			Case ";","~n"
				NextToke
			Case "const","local","global"
				ParseDeclStmts
			' nested function - needs to get added to the "module"
			Case "function"
				_block.InsertDecl ParseFuncDecl( _toke,FUNC_NESTED)
			Case "return"
				ParseReturnStmt()
			Case "exit"
				ParseExitStmt()
			Case "continue"
				ParseContinueStmt()
			Case "if"
				ParseIfStmt( "" )
			Case "while"
				ParseWhileStmt()
			Case "repeat"
				ParseRepeatStmt()
			Case "for"
				ParseForStmt()
			Case "select"
				ParseSelectStmt()
			Case "assert"
				ParseAssertStmt()
			Case "try"
				ParseTryStmt()
			Case "throw"
				ParseThrowStmt()
			Case "end"
				ParseEndStmt()
			Case "extern"
				ParseExternBlock(_module, 0)
			Case "#"
				Local decl:TLoopLabelDecl = ParseLoopLabelDecl()
				NextToke
				While _toke
					SetErr
					Select _toke.ToLower()
						Case "~n"
							NextToke
						Case "while"
							ParseWhileStmt(decl)
							Exit
						Case "repeat"
							ParseRepeatStmt(decl)
							Exit
						Case "for"
							ParseForStmt(decl)
							Exit
						Case "defdata"
							ParseDefDataStmt(decl)
							Exit
						Default
							Err "Labels must appear before a loop or DefData statement"
					End Select
				Wend
			Case "release"
				ParseReleaseStmt()
			Case "defdata"
				ParseDefDataStmt()
			Case "readdata"
				ParseReadDataStmt()
			Case "restoredata"
				ParseRestoreDataStmt()
			Default
				If _toke.StartsWith("'!") Then
					If _tokeType = TOKE_NATIVE Then
						ParseNativeStmt()
					End If
				Else
					Local expr:TExpr=ParsePrimaryExpr( True )
	
					Select _toke.ToLower()
					'"=","*=","/=","+=","-=","&=","|=","~~=","Mod","Shl","Shr"
					Case "=",":*",":/",":+",":-",":&",":|",":~~","mod","shl","shr", ":shl", ":shr", "sar", ":sar", ":mod"

						' remap symbols...
						'For Local i:Int = 0 Until TToker._symbols.length
						'	Local sym$= TToker._symbols[i]
						'	If _toke.ToLower() = sym
						'		_toke = TToker._symbols_map[i]
						'		Exit
						'	EndIf
						'Next
	
	
						If TIdentExpr( expr ) Or TIndexExpr( expr )
							Local op$=_toke.ToLower()
							NextToke
						'	If Not op.EndsWith( "=" ) And Not op.StartsWith("=")
						'		Parse "="
						'		op:+"="
						'	EndIf
							_block.AddStmt New TAssignStmt.Create( op,expr,ParseExpr() )
						Else
							Err "Assignment operator '"+_toke+"' cannot be used this way."
						EndIf
						Return
					End Select
	
					If TIdentExpr( expr )
	
						expr=New TFuncCallExpr.Create( expr,ParseArgs( True ) )
	
					Else If TFuncCallExpr( expr) Or TInvokeSuperExpr( expr ) Or TNewObjectExpr( expr ) Or TNewExpr(expr)
					
					Else If TIndexExpr(expr)
						expr = New TFuncCallExpr.Create( expr, ParseArgs( True ) )
					Else
						Err "Expression cannot be used as a statement."
					EndIf
	
					_block.AddStmt New TExprStmt.Create( expr )
				End If
		End Select
	End Method

	Method ParseDecl:TDecl( toke$,attrs:Int )
		SetErr

		Local id$=ParseIdent()
		Local ty:TType
		Local init:TExpr

		If attrs & DECL_EXTERN
			ty=ParseDeclType()

'			If CParse("(") Then
			If _toke = "(" Then

				' function pointer?
				Local decl:TFuncDecl = ParseFuncDecl("", attrs | FUNC_PTR)

				If Not ty Then
					ty = New TFunctionPtrType
					TFunctionPtrType(ty).func = decl
				Else
					decl.retType = ty
					ty = New TFunctionPtrType
					TFunctionPtrType(ty).func = decl
				End If

				TFunctionPtrType(ty).func.ident = id

			Else If toke = "const" Then
				If CParse("=") Then
					init=ParseExpr()
				End If
			End If
		Else If CParse( ":=" )
			init=ParseExpr()
		Else
			ty=ParseDeclType()

			If CParse( "=" )
				init=ParseExpr()
			Else If CParse( "[" )
				Local ln:TExpr[]
				Repeat
					If CParse(",") Then
						ln = ln + [New TNullExpr]
						Continue
					End If
					If CParse("]") Exit
					ln = ln + [ParseExpr()]
					If CParse("]") Exit
					Parse(",")
				Forever
				'Parse "]"
				ty = ParseArrayType(ty)
				'While CParse( "[]" )
				'	ty=New TArrayType.Create(ty)
				'Wend
				init=New TNewArrayExpr.Create( ty,ln)
				ty=New TArrayType.Create( ty, ln.length )
			Else If _toke = "(" Then
	 			' function pointer?
				Local fdecl:TFuncDecl = ParseFuncDecl("", FUNC_PTR)
				If toke = "field" Then
					fdecl.attrs :| FUNC_METHOD
				End If

				If Not ty Then
					ty = New TFunctionPtrType
					TFunctionPtrType(ty).func = fdecl
				Else
					fdecl.retType = ty
					ty = New TFunctionPtrType
					TFunctionPtrType(ty).func = fdecl
				End If

				TFunctionPtrType(ty).func.ident = ""

				' an initialised array of function pointers?
				If Not IsArrayDef() And CParse( "[" )
					Local ln:TExpr[]
					Repeat
						If CParse(",") Then
							ln = ln + [New TNullExpr]
							Continue
						End If
						If CParse("]") Exit
						ln = ln + [ParseExpr()]
						If CParse("]") Exit
						Parse(",")
					Forever
					'Parse "]"
					ty = ParseArrayType(ty)
					'While CParse( "[]" )
					'	ty=New TArrayType.Create(ty)
					'Wend
					init=New TNewArrayExpr.Create( ty,ln)
					ty=New TArrayType.Create( ty, ln.length )
				Else
					While IsArrayDef()
						ty = ParseArrayType(ty)
					Wend

					' check for function pointer init
					If CParse("=") Then
						init=ParseExpr()
					Else
						init=New TConstExpr.Create( ty,"" )
					End If
				End If

			Else If toke<>"const"
				init=New TConstExpr.Create( ty,"" )
			Else
				Err "Constants must be initialized."
			EndIf
		EndIf

		Local decl:TValDecl

		Select toke
		Case "global" decl=New TGlobalDecl.Create( id,ty,init,attrs )
		Case "field"  decl=New TFieldDecl.Create( id,ty,init,attrs )
		Case "const"  decl=New TConstDecl.Create( id,ty,init,attrs )
		Case "local"  decl=New TLocalDecl.Create( id,ty,init,attrs )
		End Select

		If decl.IsExtern()
			Local cdets:TCastDets

			If CParse( "=" )
				Local munged:String = ParseStringLit()
				
				If munged.Find("(") > 0 Then
					cdets = ParseExternCast(munged, True)
					If cdets Then
						decl.munged = cdets.name
					End If
				Else
					decl.munged = munged
				End If
			Else
				decl.munged=decl.ident
			EndIf

				If TFunctionPtrType(ty) Then
					TFunctionPtrType(ty).func.munged = decl.munged
					
					If Not cdets Then
						cdets = TCastDets(_externCasts.ValueForKey(TFunctionPtrType(ty).func.munged))
					End If
					
					If cdets Then
						TFunctionPtrType(ty).func.castTo = cdets.retType
						If cdets.noGen Then
							TFunctionPtrType(ty).func.noCastGen = True
						End If
						For Local i:Int = 0 Until cdets.args.length
							If i < TFunctionPtrType(ty).func.argDecls.length Then
								TFunctionPtrType(ty).func.argDecls[i].castTo = cdets.args[i]
							End If
						Next
					End If
	
				End If

		EndIf

		' apply any function ptr metadata to decl
		If TFunctionPtrType(ty) Then
			If TFunctionPtrType(ty).func And TFunctionPtrType(ty).func.metadata Then
				decl.metadata = TFunctionPtrType(ty).func.metadata
			End If
		End If

		'meta data for variables
		Local meta:TMetaData = ParseMetaData()
		If meta Then
			decl.metadata = meta
		End If

		Return decl
	End Method

	Method ParseDecls:TList( toke$,attrs:Int )
		If toke Parse toke

		Local decls:TList=New TList'<Decl>
		Repeat
			Local decl:TDecl=ParseDecl( toke,attrs )
			decls.AddLast decl
			If Not CParse(",") Return decls
		Forever
	End Method

	Method ParseDeclStmts()
		Local toke$=_toke
		NextToke
		Repeat
			Local decl:TDecl=ParseDecl( toke,0 )
			_block.AddStmt New TDeclStmt.Create( decl )
			
			' reset the decl scope, adding decl to the block decl list.
			' this improves scope visibilty - for decls such as embedded functions
			If TConstDecl(decl) Or TGlobalDecl(decl) Then
				decl.scope = Null
				_block.InsertDecl(decl)
				If TGlobalDecl(decl) Then
					TGlobalDecl(decl).funcGlobal = True
				End If
			End If
			
		Until Not CParse(",")
	End Method
	
	Method ParseLoopLabelDecl:TLoopLabelDecl()
		NextToke
		Local id:String = ParseIdent()
		Return New TLoopLabelDecl.Create(id, 0)
	End Method

	'handle end-of-line "dot dot return"-line connector
	'-> skips EOL tokens
	Method HandleDotsLineConnector(eatToke:Int = False)

		Local tok:TToker = New TToker.Copy(_toker)

		Local t:String = tok.NextToke()

		Local count:Int = tok.SkipSpace()
		For Local i:Int = 0 Until count
			NextToke
		Next
		
		t = tok._toke

		If t = "~r" Then
			t = tok.NextToke()
			If t = "~n" Then
				NextToke
				NextToke
			Else
				NextToke
			End If
		Else
			If t = "~n" Then
				NextToke
			End If
		End If
		
		If eatToke And Not count Then
			NextToke
		End If
	End Method

	'should return a specific "metadata object" ?
	' metadata is in the form : {key key=value key="value"}
	Method ParseMetaData:TMetadata()
		If Not CParse( "{" ) Then
			Return Null
		End If

		Local meta:TMetadata = New TMetadata

		SkipEols

		Repeat
			
			If meta.metadataString Then
				meta.metadataString :+ " "
			End If
			
			Select _tokeType
				Case TOKE_INTLIT
					Err "Expecting '}' but encountered integer literal"
				Case TOKE_FLOATLIT
					Err "Expecting '}' but encountered floating point literal"
				Case TOKE_STRINGLIT
					Err "Expecting '}' but encountered string literal"
				Case TOKE_SYMBOL
					Err "Expecting '}' but encountered " + _toke
			End Select
			
			'append current token to metaDataString
			Local key:String = _toke
			meta.metadataString :+ key

			'read next token
			NextToke()

			Local value:String
			' got a value
			If CParse("=") Then
				
				If _tokeType = TOKE_IDENT Then
					Err "Meta data must be literal constant"
				End If
				
				value = _toke
				meta.metadataString :+ "=" + value

				'read next token
				NextToke()
			Else
				value = "1"
				meta.metadataString :+ "=1"	
			End If
			
			meta.InsertMeta(key.ToLower(), value)
			
			'reached end of meta data declaration
			If _toke="}" Then Exit
		Forever

		'continue to next token
		NextToke()

		'parse this into something
		Return meta
	End Method


	Method ParseFuncDecl:TFuncDecl( toke$,attrs:Int, returnType:TType = Null, parent:TScopeDecl = Null )
		SetErr

		If toke Parse toke

		Local id$
		Local ty:TType
		Local meth:Int = attrs & FUNC_METHOD
		Local meta:TMetadata
		Local noMangle:Int

		Local classDecl:TClassDecl = TClassDecl(parent)

		If Not returnType Then
			If attrs & FUNC_METHOD
				If _toke="new"
					If attrs & DECL_EXTERN
						Err "Extern classes cannot have constructors"
					EndIf
					id="New"
					NextToke
					attrs:|FUNC_CTOR
					attrs:&~FUNC_METHOD
				Else If _toke="operator" Then
					attrs:|FUNC_OPERATOR
					NextToke
					
					Local t:String = _toke.ToLower()
					NextToke
					
					Select t
						Case "*","/","+","-","&","|","~~"
							id = t
						Case ":*",":/",":+",":-",":&",":|",":~~"
							id = t
						Case "<",">"',"="',"<=",">=","=","<>"
							If CParse("=") Then
								t :+ "="
							Else If t = "<" And CParse(">") Then
								t :+ ">"
							End If
							id = t
						Case "="
							id = t
						Case "mod", "shl", "shr"
							id = t
						Case ":mod", ":shl", ":shr"
							id = t
						Default
							DoErr "Operator must be one of: * / + - & | ~~ :* :/ :+ :- :& :| :~~ < > <= >= = <> mod shl shr :mod :shl :shr"
					End Select
					ty=ParseDeclType()
				Else
					id=ParseIdent()
					ty=ParseDeclType()
					If ty._flags & (TType.T_CHAR_PTR | TType.T_SHORT_PTR) Then
						DoErr "Illegal function return type"
					End If
	
					' Delete() return type should always be Void
					If id.ToLower() = "delete" Then
						attrs:|FUNC_DTOR
						If TIntType(ty) Then
							ty = New TVoidType
						End If
					End If
				EndIf
			Else
				If Not (attrs & FUNC_PTR) Then
					id=ParseIdent()
					ty=ParseDeclType()
					' can only return "$z" and "$w" from an extern function.
					If ty._flags & (TType.T_CHAR_PTR | TType.T_SHORT_PTR) And Not (attrs & DECL_EXTERN) Then
						DoErr "Illegal function return type"
					End If
				End If
			EndIf
		End If
		
		Local args:TArgDecl[]

		Parse "("
		SkipEols
		If _toke<>")"
			Local nargs:Int
			Repeat

				Local argId$=ParseIdent()

				Local ty:TType=ParseDeclType()

				Local init:TExpr
				' function pointer ?
				If _toke = "(" Then

					Local fdecl:TFuncDecl = ParseFuncDecl("", FUNC_PTR | DECL_ARG)

					If Not ty Then
						ty = New TFunctionPtrType
						TFunctionPtrType(ty).func = fdecl
					Else
						fdecl.retType = ty
						ty = New TFunctionPtrType
						TFunctionPtrType(ty).func = fdecl
					End If

					TFunctionPtrType(ty).func.ident = argId

					' function pointer array ?
					While IsArrayDef()
						ty = ParseArrayType(ty)
					Wend
				End If
				
				' var argument?
				If CParse("var") Then
					ty = TType.MapToVarType(ty)
				Else If CParse( "=" )
					init=ParseExpr()
				End If
				
				Local arg:TArgDecl=New TArgDecl.Create( argId,ty,init )
				If args.Length=nargs args=args + New TArgDecl[10]
				args[nargs]=arg
				nargs:+1
				If _toke=")" Exit

				Parse ","
			Forever
			args=args[..nargs]
		EndIf
		Parse ")"
		
		If returnType Then
			Return New TFuncDecl.CreateF(Null,returnType,args,attrs)
		End If
		
		Local fdecl:TFuncDecl
		' wait.. so everything until now was a function pointer return type, and we still have to process the function declaration...
		If _toke = "(" Then
			Local retTy:TType = New TFunctionPtrType
			TFunctionPtrType(retTy).func = New TFuncDecl.CreateF("",ty,args,attrs )
			TFunctionPtrType(retTy).func.attrs :| FUNC_PTR
			fdecl = ParseFuncDecl("", attrs, retTy)
			ty = retTy
		End If

		If CParse( "nodebug" ) Then
			attrs :| DECL_NODEBUG
		End If
			
		If CParse( "final" )
			If Not classDecl Then
				Err "Final cannot be used with global functions"
			End If
			attrs:|DECL_FINAL
		Else If CParse( "abstract" )
			If Not classDecl Then
				Err "Abstract cannot be used with global functions"
			End If
			
			If classDecl And classDecl.attrs & DECL_FINAL Then
				Err "Abstract methods cannot appear in final types"
			End If
			
			attrs:|DECL_ABSTRACT
		End If
			
		If CParse( "nodebug" ) Then
			attrs :| DECL_NODEBUG
		End If


		'meta data for functions/methods
		meta = ParseMetaData()
		
		If meta And meta.HasMeta("nomangle") Then
			If attrs & FUNC_METHOD Then
				Err "Only functions can specify NoMangle"
			Else
				noMangle = True
			End If
		End If
				
		If _tokeType=TOKE_STRINGLIT
			' "win32", etc
			' TODO ? something with this??
			Local api:String = ParseStringLit().ToLower()
			If api = "win32" Then
				attrs :| DECL_API_WIN32
			End If
		EndIf
		
		If CParse( "nodebug" ) Then
			attrs :| DECL_NODEBUG
		End If

		Local funcDecl:TFuncDecl
		If attrs & FUNC_CTOR Then
			funcDecl=New TNewDecl.CreateF( id,ty,args,attrs )
		Else
			If fdecl Then
				funcDecl = fdecl
				funcDecl.ident = id
			Else
				funcDecl=New TFuncDecl.CreateF( id,ty,args,attrs )
			End If
			funcDecl.noMangle = noMangle
		End If
		If meta Then
			funcDecl.metadata = meta
		End If

		If funcDecl.IsExtern() Or (attrs & FUNC_PTR)
			funcDecl.munged=funcDecl.ident

			' a normal function pointer definition *probably* can't be defined with a munged name?
			' If there is an equals here, one can assume it is for an initialisation...
			'If (Not (attrs & FUNC_PTR)) Or (attrs & FUNC_PTR And Not (attrs & DECL_ARG)) Then
			Local cdets:TCastDets
			
			If Not (attrs & FUNC_PTR) Then
				If CParse( "=" )
					Local munged:String = ParseStringLit()
					
					If munged.Find("(") > 0 Then
						cdets = ParseExternCast(munged, True)
						If cdets Then
							funcDecl.munged = cdets.name
						End If
					Else
						funcDecl.munged = munged
					End If
				End If

				'Array $resize hack!
				'If funcDecl.munged="$resize"
				'	funcDecl.retTypeExpr=TType.emptyArrayType
				'EndIf
			EndIf

			If funcDecl.munged Then
				' look up extern cast list
				If Not cdets Then
					cdets = TCastDets(_externCasts.ValueForKey(funcDecl.munged))
				End If
				
				If cdets Then
					funcDecl.castTo = cdets.retType
					If cdets.noGen Then
						funcDecl.noCastGen = True
					End If
					For Local i:Int = 0 Until cdets.args.length
						If i < funcDecl.argDecls.length Then
							funcDecl.argDecls[i].castTo = cdets.args[i]
						End If
					Next
				End If
			End If

			Return funcDecl
		EndIf

		If funcDecl.IsAbstract() Return funcDecl

		'Ok, only first statement of a constructor can call super constructor - not pretty, should be in semant.
		If attrs & FUNC_CTOR
			SkipEols
			If CParse( "super" )
				Parse "."
				If _toke="new"
					Local id$="New"
					NextToke
					'funcDecl.superCtor=New TInvokeSuperExpr.Create( id,ParseArgs( True ) )
					'funcDecl.AddStmt New TExprStmt.Create( funcDecl.superCtor )
					funcDecl.AddStmt New TExprStmt.Create( New TNewExpr.Create(ParseArgs(True), True))
				Else
					Local id$=ParseIdent()
					funcDecl.AddStmt New TExprStmt.Create( New TInvokeSuperExpr.Create( id,ParseArgs( True ) ) )
				EndIf
			Else
					'Invoke super default ctor
					'funcDecl.superCtor=New InvokeSuperExpr( "new",[] )
					'funcDecl.AddStmt New TExprStmt( funcDecl.superCtor )
			EndIf
		EndIf

		PushBlock funcDecl
		While (Not meth And _toke.ToLower()<>"endfunction") Or (meth And _toke.ToLower()<>"endmethod")
			If CParse( "end" )
				If (Not meth And CParse("function")) Or (meth And CParse("method"))
					Exit
				End If

				' handle "end" statement
				ParseEndStmt(False)
			EndIf

			ParseStmt
		Wend
		PopBlock

		NextToke
		'If toke CParse toke

		Return funcDecl
	End Method

	Method ParseClassDecl:TClassDecl( toke$,attrs:Int )
		SetErr

		If toke Parse toke

		Local id$=ParseIdent()
		Local args:TStack = New TStack
		Local superTy:TIdentType
		Local imps:TIdentType[]
		Local meta:TMetadata

		'If (attrs & CLASS_INTERFACE) And (attrs & DECL_EXTERN)
		'	Err "Interfaces cannot be extern."
		'EndIf

		If CParse( "<" )

			If attrs & DECL_EXTERN
				Err "Extern classes cannot be generic."
			EndIf

			'If attrs & CLASS_INTERFACE
			'	Err "Interfaces cannot be generic."
			'EndIf

			'If attrs & CLASS_TEMPLATEARG
			'	Err "Class parameters cannot be generic."
			'EndIf

			Local nargs:Int
			Repeat
				'Local decl:TClassDecl=ParseClassDecl( "",CLASS_TEMPLATEARG )
				'If args.Length=nargs args=args + New TClassDecl[10]
				'args[nargs]=decl
				'nargs:+1
				args.Push ParseIdent()
			Until Not CParse(",")
			'args=args[..nargs]

			Parse ">"
		EndIf

		If CParse( "extends" )
			'If attrs & CLASS_TEMPLATEARG
			'	Err "Extends cannot be used with class parameters."
			'EndIf

'			If CParse( "null" )
'
				If attrs & CLASS_STRUCT
					Err "Structs cannot be extended"
				EndIf
'
'				If Not (attrs & DECL_EXTERN)
'					Err "Only extern objects can extend null."
'				EndIf
'
'				superTy=Null
'
'			Else
			If attrs & CLASS_INTERFACE And Not (attrs & DECL_EXTERN)

				Local nimps:Int
				Repeat
					If imps.Length=nimps imps=imps + New TIdentType[10]
					imps[nimps]=ParseIdentType()
					nimps:+1
				Until Not CParse(",")
				imps=imps[..nimps]
				superTy=New TIdentType.Create( "brl.classes.object" )
			Else
				superTy=ParseIdentType()
			EndIf
		Else
			If Not (attrs & DECL_EXTERN) Then
				superTy=New TIdentType.Create( "brl.classes.object" )
			End If
		EndIf

		If CParse( "implements" )

			If attrs & CLASS_STRUCT
				Err "Implements cannot be used with Structs"
			EndIf

			'If attrs & DECL_EXTERN
			'	Err "Implements cannot be used with external classes."
			'EndIf

			If attrs & CLASS_INTERFACE
				Err "Implements cannot be used with interfaces."
			EndIf

			'If attrs & CLASS_TEMPLATEARG
			'	Err "Implements cannot be used with class parameters."
			'EndIf

			Local nimps:Int
			Repeat
				If imps.Length=nimps imps=imps + New TIdentType[10]
				imps[nimps]=ParseIdentType()
				nimps:+1
			Until Not CParse(",")
			imps=imps[..nimps]
		EndIf

		Repeat
			If CParse( "final" )

				If attrs & CLASS_INTERFACE
					Err "Final cannot be used with interfaces."
				End If
				
				If attrs & CLASS_STRUCT
					Err "Final cannot be used with structs."
				End If
				
				If attrs & DECL_FINAL
					Err "Duplicate type attribute."
				End If

				If attrs & DECL_ABSTRACT
					Err "Classes cannot be both final and abstract."
				End If
				
				attrs:|DECL_FINAL

			Else If CParse( "abstract" )

				If attrs & CLASS_INTERFACE
					Err "Abstract cannot be used with interfaces."
				EndIf
				
				If attrs & CLASS_STRUCT
					Err "Abstract cannot be used with structs."
				EndIf
				
				If attrs & DECL_ABSTRACT
					Err "Duplicate type attribute."
				End If
				
				If attrs & DECL_FINAL
					Err "Types cannot be both final and abstract."
				End If

				attrs:|DECL_ABSTRACT
			Else
				Exit
			EndIf
		Forever

		'check for metadata
		meta = ParseMetaData()

		Local classDecl:TClassDecl=New TClassDecl.Create( id,String[](args.ToArray()),superTy,imps,attrs )
		
		If meta Then
			If attrs & CLASS_STRUCT
				Err "Structs cannot store metadata."
			EndIf

			classDecl.metadata = meta
		End If

		If classDecl.IsExtern()
			classDecl.munged=classDecl.ident
			If CParse( "=" ) classDecl.munged=ParseStringLit()
		EndIf

		'If classDecl.IsTemplateArg() Return classDecl

		Local decl_attrs:Int=(attrs & DECL_EXTERN) | (attrs & DECL_NODEBUG) | (attrs & DECL_API_WIN32)

		Repeat
			Local method_attrs:Int=decl_attrs|FUNC_METHOD | (attrs & DECL_NODEBUG)
			If attrs & CLASS_INTERFACE method_attrs:|DECL_ABSTRACT
		
			SkipEols
			Select _toke
			Case "end"
				NextToke
				Exit
			Case "endtype"
				If attrs & CLASS_INTERFACE Then
					Err "Syntax error - expecting End Interface, not 'EndType'"
				End If
				If attrs & CLASS_STRUCT Then
					Err "Syntax error - expecting End Struct, not 'EndType'"
				End If
				toke = Null
				NextToke
				Exit
			Case "endstruct"
				If attrs & CLASS_INTERFACE Then
					Err "Syntax error - expecting End Interface, not 'EndStruct'"
				End If
				If Not (attrs & CLASS_STRUCT) Then
					Err "Syntax error - expecting End Type, not 'EndStruct'"
				End If
				toke = Null
				NextToke
				Exit
			Case "endinterface"
				If Not (attrs & CLASS_INTERFACE) And Not (attrs & CLASS_STRUCT) Then
					Err "Syntax error - expecting End Type, not 'EndInterface'"
				End If
				If Not (attrs & CLASS_INTERFACE) And (attrs & CLASS_STRUCT) Then
					Err "Syntax error - expecting End Struct, not 'EndInterface'"
				End If
				toke = Null
				NextToke
				Exit
			Case "private"
				If attrs & CLASS_INTERFACE Then
					Err "Private cannot be used with interfaces."
				End If
				NextToke
				decl_attrs=decl_attrs | DECL_PRIVATE
				decl_attrs:& ~DECL_PROTECTED
			Case "protected"
				If attrs & CLASS_INTERFACE Then
					Err "Protected cannot be used with interfaces."
				End If
				NextToke
				decl_attrs=decl_attrs | DECL_PROTECTED
				decl_attrs:& ~DECL_PRIVATE
			Case "public"
				NextToke
				decl_attrs:& ~DECL_PRIVATE
				decl_attrs:& ~DECL_PROTECTED
			Case "const","global","field"
				If attrs & DECL_EXTERN Then
					If (attrs & CLASS_INTERFACE) Then
						Err "Extern Interfaces can only contain methods."
					End If
					If Not (attrs & CLASS_STRUCT) Then
						Err "Extern Types can only contain methods."
					End If
				End If
				If (attrs & CLASS_INTERFACE) And _toke<>"const"
					Err "Interfaces can only contain constants and methods."
				EndIf
				If (attrs & CLASS_STRUCT) And _toke<>"field"
					Err "Structs can only contain fields."
				EndIf
				classDecl.InsertDecls ParseDecls( _toke,decl_attrs )
			Case "method"
				If (attrs & CLASS_STRUCT) And (attrs & DECL_EXTERN) Then
					Err "Structs can only contain fields."
				EndIf
				Local decl:TFuncDecl=ParseFuncDecl( _toke,method_attrs,,classDecl )
				If decl.IsCtor() decl.retTypeExpr=New TObjectType.Create( classDecl )
				classDecl.InsertDecl decl
			Case "function"
				If (attrs & CLASS_INTERFACE)
					Err "Interfaces can only contain constants and methods."
				EndIf
				If attrs & CLASS_STRUCT Then
					If (attrs & DECL_EXTERN) Then
						Err "Structs can only contain fields."
					Else
						Err "Structs can only contain fields and methods."
					End If
				EndIf
				If attrs & DECL_EXTERN Then
					Err "Extern Types can only contain methods."
				End If
				Local decl:TFuncDecl=ParseFuncDecl( _toke,decl_attrs,,classDecl )
				classDecl.InsertDecl decl
			Default
				Err "Syntax error - expecting class member declaration, not '" + _toke + "'"
			End Select
		Forever

		If toke Parse toke

		Return classDecl
	End Method
	
	Method ParseNativeStmt()
		If Not _toke.StartsWith("'!") Then
			Err "Syntax error - expecting !'"
		End If
		Local raw:String = _toke[2..]
		_block.AddStmt New TNativeStmt.Create( raw )
		NextToke
	End Method

	Method ParseModuleDecl:String( toke$,attrs:Int )
		NextToke

		' namespace . module
		Return ParseModPath().ToLower()
	End Method

	Method ParseModPath$()
		Local path$=ParseIdent()
		While CParse( "." )
			path:+"."+ParseIdent()
		Wend
		Return path
	End Method

	Method ExtractModIdent$( modpath$ )
		Local i:Int=modpath.FindLast( "." )
		If i<>-1 Return modpath[i+1..]
		Return modpath
	End Method

	Method ImportFile( filepath$ )

		If filepath.Endswith(".bmx") Then
			filepath = ActualPath(filepath)
			Local origPath:String = RealPath(filepath)
			Local path:String = OutputFilePath(origPath, FileMung(), "i")

			If FileType( path )<>FILETYPE_FILE
				Err "File '"+ path +"' not found."
			EndIf

			If _module.imported.Contains( path ) Return

			Local modpath:String
			If opt_buildtype = BUILDTYPE_MODULE Then

				Local dir:String = ExtractDir(origPath).ToLower()
				dir = dir[dir.findLast("/") + 1..]
				If dir.EndsWith(".mod") Then
					dir = ""
				Else
					dir :+ "_"
				End If
				Local file:String = StripDir(origPath).ToLower()

				modpath = opt_modulename + "_" + dir + StripExt(file)
			Else
				modpath = StripExt(filepath)
			End If

			'sanitize the path, remove non-allowed chars
			modpath = TStringHelper.Sanitize(modpath.ToLower())

			' try to import interface
			Local par:TIParser = New TIParser
			If par.ParseModuleImport(_module, modpath, origPath, path, , , filepath, True) Return
		Else If filepath.startswith("-") Then
			If Not _app.fileimports.Contains(filepath) Then
				_app.fileimports.AddLast filepath
			End If
		Else
			If filepath.EndsWith(".h") Or filepath.EndsWith(".hpp") Or filepath.EndsWith(".hxx") Then
				If filepath.Find("*") = -1 Then
					_app.headers.AddLast filepath
				End If
			Else
				Local path:String = ActualPath(RealPath(filepath))
				If FileType( path )<>FILETYPE_FILE
					Err "File '"+ path +"' not found."
				End If
			End If
		End If

	End Method

	Method ImportAllModules(attrs:Int)

		' get all brl and pub modules
		Local mods:TList = EnumModules("brl")
		mods = EnumModules("pub", mods)

		For Local m:String = EachIn mods
			ImportModule(m, attrs)
		Next

	End Method
	
	Method ImportModule( modpath$,attrs:Int )
		SetErr
		
		modpath = modpath.ToLower()
		Local basepath:String = ModulePath(modpath.ToLower())

		If _module.imported.Contains( basepath ) Return

		' try to import interface
		Local par:TIParser = New TIParser

		If par.ParseModuleImport(_module, modpath, basepath, , , attrs) Return

'DebugStop

		'Local mdecl:TDecl=_app.imported.ValueForKey( basepath )

		'If Not mdecl
		'	mdecl=ParseModule( filepath,_app )
		'EndIf

		'_module.imported.Insert mdecl.filepath,mdecl

		'If Not (attrs & DECL_PRIVATE) _module.pubImported.Insert mdecl.filepath,mdecl

		'_module.InsertDecl New AliasDecl( mdecl.ident,mdecl,attrs )
'End Rem
	End Method

	Method ValidateModIdent( id$ )
		If id.Length
			If IsAlpha( id[0] ) Or id[0]="_"[0]
				Local err:Int
				For Local i:Int=1 Until id.Length
					If IsAlpha( id[i] ) Or IsDigit( id[i] ) Or id[i]="_"[0] Continue
					err=1
					Exit
				Next
				If Not err Return
			EndIf
		EndIf
		Err "Invalid module identifier '"+id+"'."
	End Method

	Method MungAppDecl(app:TAppDecl)
		If opt_buildtype = BUILDTYPE_MODULE And opt_ismain Then
			app.munged = MungModuleName(opt_modulename)
		Else If opt_buildtype = BUILDTYPE_MODULE Then
			Local dir:String = ExtractDir(opt_filepath).ToLower()
			dir = dir[dir.findLast("/") + 1..]
			If dir.EndsWith(".mod") Then
				dir = ""
			Else
				dir :+ "_"
			End If
			app.munged = "_bb_" + opt_modulename + "_" + dir + StripExt(StripDir(opt_filepath).ToLower())
		Else
			' main application file?
			If opt_apptype Then
				app.munged = "_bb_main"
			Else
				Local dir:String = ExtractDir(opt_filepath).ToLower()
				dir = dir[dir.findLast("/") + 1..]
				If dir.EndsWith(".mod") Then
					dir = dir.Replace(".mod", "")
				End If
				Local file:String = StripDir(opt_filepath).ToLower()
				app.munged = "_bb_" + dir + "_" + StripExt(file)
			End If
		End If

		'sanitize, remove non-allowed chars
		app.munged = TStringHelper.Sanitize(app.munged)
	End Method

	' load external cast defs
	Method LoadExternCasts(path:String)

		For Local externs:Int = 0 Until 3
		
			Local ePath:String
		
			' we will iterate through all possibilities as there may be different sets
			' of explicit casts/no gen funcs for each.
			Select externs
				Case 0
					' eg. file.win32.x86.x
					ePath = StripExt(path) + "." + opt_platform + "." + opt_arch + ".x"
				Case 1
					' eg. file.win32.x
					ePath = StripExt(path) + "." + opt_platform + ".x"
				Case 2
					' eg. file.x
					ePath = StripExt(path) + ".x"
			End Select


			If FileType(ePath) = FILETYPE_FILE Then
			
				Print "Warning: .x cast definition files are deprecated. You should now place the details in the extern function's alias string. (" + path + ")"

				ParseExternCast(LoadText( ePath ), False, ePath)

			End If
			
		Next

	End Method

	Method ParseExternCast:TCastDets(txt:String, single:Int = False, path:String = "")
		Local toker:TToker = New TToker.Create(path, txt)
		toker.NextToke

		Local dets:TCastDets
			
		While True

			SkipEolsToker(toker)

			If toker._tokeType = TOKE_EOF Exit

			dets = New TCastDets

			Local rt$=toker._toke

			If CParseToker(toker, "const") Then
				rt :+ " " + toker._toke
			End If

			If CParseToker(toker, "unsigned") Then
				rt :+ " " + toker._toke
			End If

			NextTokeToker(toker)
			
			If CParseToker(toker,"*") Then
				rt:+ "*"

				If CParseToker(toker,"*") Then
					rt:+ "*"
				End If
			End If


			If CParseToker(toker, "__stdcall") Then
				dets.api = "__stdcall"
			End If

			' fname
			Local fn$=toker._toke
			NextTokeToker(toker)

			dets.name = fn
			dets.retType = rt

			' add to global map (may be referenced by function ptr defs)
			_externCasts.Insert(fn, dets)

			' args
			ParseToker(toker, "(")

			If CParseToker(toker, ")") Then

				' don't generate header extern
				If CParseToker(toker, "!") Then
					dets.noGen = True
				End If

				Continue
			End If

			Local i:Int = 0
			Repeat
				Local at$=toker._toke

				If CParseToker(toker, "const") Then
					at :+ " " + toker._toke
				End If

				If CParseToker(toker, "unsigned") Then
					at :+ " " + toker._toke
				End If

				If CParseToker(toker, "struct") Then
					at :+ " " + toker._toke
				End If

				NextTokeToker(toker)
				If CParseToker(toker, "*") Then
					at:+ "*"

					If CParseToker(toker, "const") Then
						at :+ " const"
					End If

					If CParseToker(toker, "*") Then
						at:+ "*"
					End If
				End If

				' function pointer
				If CParseToker(toker, "(") Then

					ParseToker(toker, "*")
					ParseToker(toker, ")")
					at :+ "(*)"

					ParseToker(toker, "(")
					at :+ "("

					While Not CParseToker(toker, ")")
						NextTokeToker(toker)
						at :+ toker._toke
					Wend

					at :+ ")"
				End If


				dets.args :+ [at]

				If toker._toke=")" Exit
				ParseToker(toker, ",")

				i:+ 1
			Forever

			NextTokeToker(toker)

			' don't generate header extern
			If CParseToker(toker, "!") Then
				dets.noGen = True
			End If
			
			If single Then
				Exit
			End If
		Wend
		
		Return dets
	End Method

	Method ParseCurrentFile:Int(path:String, attrs:Int)

		LoadExternCasts(path)

		While _toke
			SetErr
			Select _toke.toLower()
			Case "~n"
				NextToke
			Case "public"
				NextToke
				attrs=attrs & ~DECL_PRIVATE
			Case "private"
				NextToke
				attrs=attrs | DECL_PRIVATE
			Case "extern"

				ParseExternBlock(_module, attrs)

			Case "const"
				_module.InsertDecls ParseDecls( _toke,attrs )
			Case "global"
				Local list:TList = ParseDecls( _toke,attrs )
				_module.InsertDecls list
				For Local gdecl:TGlobalDecl = EachIn list
					gdecl.attrs :| DECL_INITONLY
					_block.AddStmt New TDeclStmt.Create( gdecl )
				Next
			Case "struct"
				_module.InsertDecl ParseClassDecl( _toke,attrs | CLASS_STRUCT )
			Case "type"
				_module.InsertDecl ParseClassDecl( _toke,attrs )
			Case "interface"
				_module.InsertDecl ParseClassDecl( _toke,attrs|CLASS_INTERFACE|DECL_ABSTRACT )
			Case "function"
				_module.InsertDecl ParseFuncDecl( _toke,attrs )
			Case "incbin"
				NextToke
				Local s:String = ParseStringLit()
				_app.mapStringConsts(s)
				Local ib:TIncBin = New TIncbin.Create(s, path)
				If Not ib Then
					DoErr "Incbin file '"+ s +"' not found."
				End If
				_app.incbins.AddLast(ib)
			Case "include"
				'include command is NOT just a pattern to replace with
				'content. BlitzMax parses each included file before the
				'content gets appended to the source (right before
				'semanting or analyzing content)
				NextToke
				Local includeFile:String = ParseStringLit()

				'convert the URI of the to include file as it might be
				'a relative one
				includeFile = RealPath(includeFile)

				'instead of merging the data of multiple parsers, the
				'same parser is used for all included files - but each
				'of them uses an individual toker

				If FileType( includeFile )<>FILETYPE_FILE
					DoErr "File '"+ includeFile +"' not found."
				EndIf

				'instead of "LoadText" "PreProcess" is used to include
				'handling of conditionals and comments
				Try
					Local includeSource:String = PreProcess(includeFile)
					Local includeToker:TToker = New TToker.Create(includeFile, includeSource)

					'backup old vars
					Local oldToker:TToker = Self._toker

					'assign temporary vars
					Self._toker = includeToker

					'parse the include file
					parseCurrentFile(includeFile, attrs)

					'restore backup vars
					Self._toker = oldToker
				Catch e:TStreamException
					DoErr "Failed to include file '" + includeFile + "' : '" + e.ToString() + "'"
				End Try

				'move on to next toke (after include "xyz.bmx")
				NextToke

			Default
				ParseStmt
				'Err "Syntax error - expecting declaration."
			End Select
		Wend

		Return attrs
	End Method


	Method ParseMain()

		SkipEols

		Local mattrs:Int
		'If CParse( "strict" ) mattrs:|MODULE_STRICT
		'If CParse( "superstrict" ) mattrs:|MODULE_SUPERSTRICT

		Local path$=_toker.Path()
		Local ident$=StripAll( path )
		Local munged$	'="bb_"+ident+"_"

		If opt_buildtype = BUILDTYPE_MODULE And opt_ismain
			ValidateModIdent ident
		Else If opt_buildtype = BUILDTYPE_MODULE Then
			Local dir:String = ExtractDir(opt_filepath).ToLower()
			dir = dir[dir.findLast("/") + 1..]
			If dir.EndsWith(".mod") Then
				dir = ""
			Else
				dir :+ "_"
			End If

			munged = opt_modulename + "_" + dir + ident

			'sanitize, remove non-allowed chars
			munged = TStringHelper.Sanitize(munged.ToLower())
		End If

		If opt_ismain Then 'And opt_modulename <> "brl.blitz" Then
			ident = opt_modulename
		End If
		
		If opt_buildtype = BUILDTYPE_APP Then
			ident = "m_" + ident
		End If

		_module=New TModuleDecl.Create( ident,munged,path,mattrs )

		_module.AddImport path,_module

		_app.InsertModule _module

		' mung the app decl
		MungAppDecl(_app)


		If opt_buildtype = BUILDTYPE_MODULE And opt_modulename = "brl.blitz" Then
			' import Object and String definitions
			Local par:TIParser = New TIParser
			par.ParseModuleImport(_module, "brl.classes", modulepath("brl.blitz"), modulepath("brl.blitz") + "/blitz_classes.i")

			' set up built-in keywords
			par = New TIParser
			par.ParseModuleImport(_module, "brl.blitzkeywords", "", "", MakeKeywords())
		End If

		' don't import ourself
		If opt_modulename <> "brl.blitz" Then
			Local par:TIParser = New TIParser
			par.ParseModuleImport(_module, "brl.blitz", modulepath("brl.blitz"), , , MODULE_ACTUALMOD)
		End If

		Local mainFunc:TFuncDecl = New TFuncDecl.CreateF("__LocalMain", New TIntType,Null,0)

		'_app.InsertDecl mainFunc
		_module.insertDecl(mainFunc)
		'Local mainBlock:TBlockDecl = New TBlockDecl.Create( _block )


		' import all brl and pub modules if we haven't specified one
		If opt_buildtype <> BUILDTYPE_MODULE And Not opt_framework Then
			ImportAllModules MODULE_ACTUALMOD
		Else
			If opt_framework Then
				Local par:TIParser = New TIParser
				par.ParseModuleImport(_module, opt_framework, modulepath(opt_framework), , , MODULE_ACTUALMOD)
			End If
		End If


		Local attrs:Int

		'Parse header - imports etc.
		While _toke
			SetErr
			Select _toke.ToLower()
			Case "~n"
				NextToke
			Case "public"
				NextToke
				attrs=attrs & ~DECL_PRIVATE
			Case "private"
				NextToke
				attrs=attrs | DECL_PRIVATE
			Case "import"
				NextToke
				If _tokeType=TOKE_STRINGLIT
' TODO
					'ImportFile ReplaceEnvTags( ParseStringLit() )
					ImportFile ParseStringLit()
				Else
					ImportModule ParseModPath(),attrs | MODULE_ACTUALMOD
				EndIf
			Case "framework"
				NextToke
				ImportModule ParseModPath(),attrs
			Case "alias"
				NextToke
				Repeat
					Local ident$=ParseIdent()
					Parse "="

					Local decl:Object
					Local scope:TScopeDecl=_module

					_env=_module	'naughty! Shouldn't be doing GetDecl in parser...

					Repeat
						Local id$=ParseIdent()
						decl=scope.FindDecl( id )
						If Not decl Err "Identifier '"+id+"' not found."
						If Not CParse( "." ) Exit
						scope=TScopeDecl( decl )
						If Not scope Or TFuncDecl( scope ) Err "Invalid scope '"+id+"'."
					Forever

					_env=Null	'/naughty

					_module.InsertDecl New TAliasDecl.Create( ident,decl,attrs )

				Until Not CParse(",")
			Case "module"
				Local m:String = ParseModuleDecl(_toke, attrs)

				If m.ToLower() <> opt_modulename Then
					Err "Module does not match commandline module"
				End If

				'sanitize, remove non-allowed chars
				_module.munged = TStringHelper.Sanitize(m)
			Case "nodebug"
				mainFunc.attrs :| DECL_NODEBUG
				attrs :| DECL_NODEBUG
				NextToke
			Case "strict"
				If _module.attrs & (MODULE_STRICT | MODULE_SUPERSTRICT) Then
					Err "Strict or SuperStrict already specified"
				End If

				_module.attrs :| MODULE_STRICT
				nextToke
			Case "superstrict"
				If _module.attrs & (MODULE_STRICT | MODULE_SUPERSTRICT) Then
					Err "Strict or SuperStrict already specified"
				End If

				_module.attrs :| MODULE_SUPERSTRICT
				opt_issuperstrict = True
				nextToke
			Case "moduleinfo"
				NextToke
				Local info:String = ParseStringLit()
				_module.modInfo.AddLast(info)
			Default
				Exit
			End Select
		Wend

		' app code
		PushBlock(mainFunc)

		'Parse main app
		attrs = ParseCurrentFile(path, attrs)

		PopBlock
	End Method

	Method ParseModule()

	End Method


	Method Create:TParser( toker:TToker,app:TAppDecl )
		_toke="~n"
		_toker=toker
		_app=app
		SetErr
		NextToke
		Return Self
	End Method
End Type

Function Eval$( toker:TToker,_type:TType )
	Local src$
	While toker.Toke() And toker.Toke()<>"'" And toker.Toke()<>"~n" And toker.Toke()<>"~r"
		src:+toker.Toke()
		toker.NextToke()
	Wend

	Local t:String=EvalS( src,_type )

	Return t
End Function

Function PreProcessNextToke$(toker:TToker)

	Repeat
		toker.NextToke()
	Until toker.tokeType()<>TOKE_SPACE Or toker.Toke().Endswith("~n")

	Return toker._toke
End Function

Function PreProcess$( path$ )

	Local ifnest:Int,con:Int=1,line:Int,source:TStringList=New TStringList

	Local toker:TToker=New TToker.Create( path,LoadText( path ), True )

	PreProcessNextToke(toker)

	Repeat

		If line
			source.AddLast "~n"
			While toker.Toke() And Not toker.Toke().Endswith("~n") And toker.TokeType()<>TOKE_LINECOMMENT
				PreProcessNextToke(toker)
			Wend 

			If Not toker.Toke() Exit

			PreProcessNextToke(toker)
		EndIf
		
		line :+ 1

		' catch up with any skipped lines
		While line < toker._line - 1
			line:+1
			source.AddLast "~n"
		Wend

		If toker.TokeType()=TOKE_SPACE And Not toker.Toke().Endswith("~n") PreProcessNextToke(toker)

		If toker.Toke()<>"?"
			If con
				Local textline$
				While toker.Toke() And toker.Toke()<>"~n" And toker.TokeType()<>TOKE_LINECOMMENT
					Local toke$=toker.Toke()
					textline:+toke
					toker.NextToke()
				Wend
				If textline Then
					source.AddLast textline
				EndIf

			EndIf
			Continue
		EndIf

		Local stm$= PreProcessNextToke(toker).ToLower()
		'toker.NextToke()

		Local isNot:Int = False

		If stm = "not" Then
			If toker.TokeType()=TOKE_SPACE PreProcessNextToke(toker)
			stm = toker.Toke().ToLower()
			isNot = True
		End If

		'If stm="end" Or stm="else"
		'	If toker.TokeType()=TOKE_SPACE toker.NextToke()
		'	If toker.Toke().ToLower()="if"
		'		toker.NextToke()
		'		stm:+"if"
		'	EndIf
		'EndIf
Rem
Debug	True if program is being compiled in debug mode.
Threaded	True if program is being compiled in threaded mode.
Win32	True if program is being compiled for the Windows operating system.
MacOS	True if program is being compiled for the MacOS operating system.
Linux	True if program is being compiled for the Linux operating system.
X86	True if program is being compiled for the Intel CPU.
PPC	True if program is being compiled for the PowerPC CPU.
MacOSX86	True if program is being compiled for an Intel Mac.
MacOSPPC	True if program is being compiled for a PowerPC Mac.
BigEndian	True if program is being compiled for a big endian CPU.
LittleEndian
End Rem
		Select stm
		Case "~r", "~n"
			'ifnest = 0
			con = 1

		Default

			' test for EOF
			If Not toker.Toke() Exit

			con = 0
			Try
				If Eval( toker,New TIntType ) = "1" con = 1
			Catch error:String
				con = 0
			End Try

Rem
		Case "macos", "macosx86", "x86", "littleendian", "bigendian"
			con = 1
		'	If con=ifnest
		'		If Eval( toker,TType.intType ) con:+1
		'	EndIf
		'
			ifnest = 1

'		Case "rem"
'
'			ifnest:+1
		Case "threaded", "win32", "linux", "ppc", "win32x86", "linuxx86", "macosppc"

			If isNot Then
				con = 1
			Else
				con = 0
			End If

			ifnest = 1

		Case "else","elseif"

			If Not ifnest Err "#Else without #If"

			If con=ifnest
				con=-con
			Else If con=ifnest-1
				If stm="elseif"
					If Eval( toker,TType.intType ) con:+1
				Else
					con:+1
				EndIf
			EndIf

		Case "end","endif"

			If Not ifnest Err "#End without #If"

			ifnest:-1
			If con<0 con=-con
			If ifnest<con con=ifnest

'		Case "print"

'			If con=ifnest
' TODO
				'Print ReplaceEnvTags( Eval( toker,TType.stringType ) )
'			EndIf

'		Case "error"

'			If con=ifnest
' TODO
				'Err ReplaceEnvTags( Eval( toker,TType.stringType ) )
'			EndIf

		Default
			Err "Unrecognized preprocessor directive '"+stm+"'."
End Rem
		End Select
	Forever

	Return source.Join( "" )
End Function

Function ParseModule:TModuleDecl( path$,app:TAppDecl )

	'Local source$=PreProcess( path )
	Local source:String = LoadText(path)

	Local toker:TToker=New TToker.Create( path,source )

	Local parser:TParser=New TParser.Create( toker,app )

	parser.ParseMain

	Return parser._module
End Function

'***** PUBLIC API ******

Function ParseApp:TAppDecl( path$ )

	Local app:TAppDecl=New TAppDecl

	_appInstance = app

	Local source$=PreProcess( path )
	'Local source:String = LoadString(path)

	Local toker:TToker=New TToker.Create( path,source )

	Local parser:TParser=New TParser.Create( toker,app )
	parser.ParseMain

	Return app
End Function

Function MungModuleName:String(ident:Object)
	Local mung:String
	If String(ident) Then
		Local id:String = String(ident)
		mung = "__bb_" + id + "_" + id[id.Find(".") + 1..]
	Else
		Local mdecl:TModuleDecl = TModuleDecl(ident)
		If mdecl Then
			Local id:String = mdecl.ident
			Local dir:String = ExtractDir(mdecl.filepath).ToLower()
			dir = dir[dir.findLast("/") + 1..]
			If dir.EndsWith(".mod") Then
				dir = ""
			Else
				dir :+ "_"
			End If
			mung = "__bb_" + id + "_" + dir + id[id.Find(".") + 1..]
		End If
	End If

	'return sanitized, remove non-allowed chars
	Return TStringHelper.Sanitize(mung)
End Function

Function EvalS$( source$,ty:TType )

	Local env:TScopeDecl=New TScopeDecl

Rem
Debug	True if program is being compiled in debug mode.
Threaded	True if program is being compiled in threaded mode.
Win32	True if program is being compiled for the Windows operating system.
MacOS	True if program is being compiled for the MacOS operating system.
Linux	True if program is being compiled for the Linux operating system.
X86	True if program is being compiled for the Intel CPU.
PPC	True if program is being compiled for the PowerPC CPU.
MacOSX86	True if program is being compiled for an Intel Mac.
MacOSPPC	True if program is being compiled for a PowerPC Mac.
BigEndian	True if program is being compiled for a big endian CPU.
LittleEndian
End Rem

	' debug/release
	env.InsertDecl New TConstDecl.Create( "debug",New TIntType,New TConstExpr.Create( New TIntType,opt_debug ),0 )
	'env.InsertDecl New TConstDecl.Create( "release",TType.intType,New TConstExpr.Create( TType.intType,opt_release ),0 )

	' threaded
	env.InsertDecl New TConstDecl.Create( "threaded",New TIntType,New TConstExpr.Create( New TIntType,opt_threaded ),0 )

	' macos
	env.InsertDecl New TConstDecl.Create( "macos",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="macos" Or opt_platform="osx" Or opt_platform="ios"),0 )
	env.InsertDecl New TConstDecl.Create( "macosx86",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="macos" Or opt_platform="osx" Or opt_platform="ios") And opt_arch="x86"),0 )
	env.InsertDecl New TConstDecl.Create( "macosppc",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="macos" Or opt_platform="osx") And opt_arch="ppc"),0 )
	env.InsertDecl New TConstDecl.Create( "macosx64",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="macos" Or opt_platform="osx" Or opt_platform="ios") And opt_arch="x64"),0 )

	' osx
	env.InsertDecl New TConstDecl.Create( "osx",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="macos" Or opt_platform="osx" ),0 )
	env.InsertDecl New TConstDecl.Create( "osxx86",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="macos" Or opt_platform="osx")  And opt_arch="x86"),0 )
	env.InsertDecl New TConstDecl.Create( "osxppc",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="macos" Or opt_platform="osx") And opt_arch="ppc"),0 )
	env.InsertDecl New TConstDecl.Create( "osxx64",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="macos" Or opt_platform="osx") And opt_arch="x64"),0 )

	' ios
	env.InsertDecl New TConstDecl.Create( "ios",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="ios" ),0 )
	env.InsertDecl New TConstDecl.Create( "iosx86",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="ios" And opt_arch="x86"),0 )
	env.InsertDecl New TConstDecl.Create( "iosx64",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="ios" And opt_arch="x64"),0 )
	env.InsertDecl New TConstDecl.Create( "iosarmv7",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="ios" And opt_arch="armv7"),0 )
	env.InsertDecl New TConstDecl.Create( "iosarm64",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="ios" And opt_arch="arm64"),0 )

	' windows
	env.InsertDecl New TConstDecl.Create( "win32",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="win32" ),0 )
	env.InsertDecl New TConstDecl.Create( "win32x86",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="win32" And opt_arch="x86"),0 )
	env.InsertDecl New TConstDecl.Create( "win32x64",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="win64" And opt_arch="x64") Or (opt_platform="win32" And opt_arch="x64")),0 )
	env.InsertDecl New TConstDecl.Create( "win64",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="win64" And opt_arch="x64") Or (opt_platform="win32" And opt_arch="x64")),0 )

	' linux
	env.InsertDecl New TConstDecl.Create( "linux",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="linux" Or opt_platform="android" Or opt_platform="raspberrypi")),0 )
	env.InsertDecl New TConstDecl.Create( "linuxx86",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="linux" Or opt_platform="android") And opt_arch="x86"),0 )
	env.InsertDecl New TConstDecl.Create( "linuxx64",New TIntType,New TConstExpr.Create( New TIntType,(opt_platform="linux" Or opt_platform="android") And opt_arch="x64"),0 )
	env.InsertDecl New TConstDecl.Create( "linuxarm",New TIntType,New TConstExpr.Create( New TIntType, ((opt_platform="android" Or opt_platform="linux") And (opt_arch="arm" Or opt_arch="armeabi" Or opt_arch="armeabiv7a" Or opt_arch="arm64v8a")) Or (opt_platform="raspberrypi" And opt_arch="arm")),0 )

	' android
	env.InsertDecl New TConstDecl.Create( "android",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" ),0 )
	env.InsertDecl New TConstDecl.Create( "androidx86",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" And opt_arch="x86"),0 )
	env.InsertDecl New TConstDecl.Create( "androidx64",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" And opt_arch="x64"),0 )
	env.InsertDecl New TConstDecl.Create( "androidarm",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" And (opt_arch="arm" Or opt_arch="armeabi" Or opt_arch="armeabiv7a" Or opt_arch="arm64v8a") ),0 )
	env.InsertDecl New TConstDecl.Create( "androidarmeabi",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" And opt_arch="armeabi"),0 )
	env.InsertDecl New TConstDecl.Create( "androidarmeabiv7a",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" And opt_arch="armeabiv7a"),0 )
	env.InsertDecl New TConstDecl.Create( "androidarm64v8a",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="android" And opt_arch="arm64v8a"),0 )

	' raspberrypi - ARM only
	env.InsertDecl New TConstDecl.Create( "raspberrypi",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="raspberrypi" And opt_arch="arm"),0 )
	env.InsertDecl New TConstDecl.Create( "raspberrypiARM",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="raspberrypi" And opt_arch="arm"),0 )

	' emscripten
	env.InsertDecl New TConstDecl.Create( "emscripten",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="emscripten" ),0 )
	env.InsertDecl New TConstDecl.Create( "emscriptenjs",New TIntType,New TConstExpr.Create( New TIntType,opt_platform="emscripten" And opt_arch="js"),0 )

	' arch
	env.InsertDecl New TConstDecl.Create( "ppc",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="ppc" ),0 )
	env.InsertDecl New TConstDecl.Create( "x86",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="x86" ),0 )
	env.InsertDecl New TConstDecl.Create( "x64",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="x64" ),0 )
	env.InsertDecl New TConstDecl.Create( "arm",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="arm" Or opt_arch="armeabi" Or opt_arch="armeabiv7a" Or opt_arch="arm64v8a" ),0 )
	env.InsertDecl New TConstDecl.Create( "armeabi",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="armeabi" ),0 )
	env.InsertDecl New TConstDecl.Create( "armeabiv7a",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="armeabiv7a" ),0 )
	env.InsertDecl New TConstDecl.Create( "arm64v8a",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="arm64v8a" ),0 )
	env.InsertDecl New TConstDecl.Create( "js",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="js" ),0 )
	env.InsertDecl New TConstDecl.Create( "armv7",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="armv7" ),0 )
	env.InsertDecl New TConstDecl.Create( "arm64",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="arm64" ),0 )

	env.InsertDecl New TConstDecl.Create( "ptr32",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="x86" Or opt_arch="ppc" Or opt_arch="armv7" Or opt_arch="arm" Or opt_arch="armeabi" Or opt_arch="armeabiv7a" ),0 )
	env.InsertDecl New TConstDecl.Create( "ptr64",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="x64" Or opt_arch="arm64" Or opt_arch="arm64v8a" ),0 )

	' endian
	env.InsertDecl New TConstDecl.Create( "bigendian",New TIntType,New TConstExpr.Create( New TIntType,opt_arch="ppc" ),0 )
	env.InsertDecl New TConstDecl.Create( "littleendian",New TIntType,New TConstExpr.Create( New TIntType,opt_arch<>"ppc" ),0 )

	' opengles target platform
	env.InsertDecl New TConstDecl.Create( "opengles",New TIntType,New TConstExpr.Create( New TIntType, opt_platform="android" Or opt_platform="raspberrypi" Or opt_platform="emscripten" Or opt_platform="ios" Or (opt_platform="linux" And opt_arch="arm") ),0 )

	' musl - linux only
	env.InsertDecl New TConstDecl.Create( "musl",New TIntType,New TConstExpr.Create( New TIntType,(opt_musl And (opt_platform="linux" Or opt_platform="android" Or opt_platform="raspberrypi"))),0 )
	
	' new compiler
	env.InsertDecl New TConstDecl.Create( "bmxng",New TIntType,New TConstExpr.Create( New TIntType, True ),0 )

'	env.InsertDecl New TConstDecl.Create( "LANG",TType.stringType,New TConstExpr.Create( TType.stringType,ENV_LANG ),0 )
'	env.InsertDecl New TConstDecl.Create( "TARGET",TType.stringType,New TConstExpr.Create( TType.stringType,ENV_TARGET ),0 )
'	env.InsertDecl New TConstDecl.Create( "CONFIG",TType.stringType,New TConstExpr.Create( TType.stringType,ENV_CONFIG ),0 )

	PushEnv env

	Local toker:TToker=New TToker.Create( "",source )

	Local parser:TParser=New TParser.Create( toker,Null )

	Local expr:TExpr=parser.ParseExpr()

	expr=expr.Semant()

	If ty expr=expr.Cast( ty )

	Local val$=expr.Eval()

	PopEnv

	Return val
End Function

Type TCastDets

	Field name:String
	Field retType:String
	Field noGen:Int
	Field args:String[0]
	Field api:String
	
End Type

bcc
===

Monkey-originated bcc parser for BlitzMax
Generates BlitzMax (mostly) compatible C-source which has the added advantage of being more portable than the original bcc-generated processor-specific assembler.


Testing
-------

Automated tests can be performed using our custom [SimpleCodeTester](https://github.com/GWRon/SimpleCodeTester) testing tool.
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'

Type TStmt
	Field errInfo$
	' whether this statement was generated by the compiler or not
	Field generated:Int
	
	Method New()
		errInfo=_errInfo
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl ) Abstract
	
	Method Semant()
		PushErr errInfo
		OnSemant
		PopErr
	End Method

	Method Copy:TStmt( scope:TScopeDecl )
		Local t:TStmt=OnCopy( scope )
		t.errInfo=errInfo
		Return t
	End Method
	
	Method OnSemant() Abstract

	Method Trans$() Abstract

End Type

Type TDeclStmt Extends TStmt
	Field decl:TDecl
	
	Method Create:TDeclStmt( decl:TDecl, generated:Int = False )
		Self.decl=decl
		Self.generated = generated
		Return Self
	End Method
	
	Method CreateWithId:TDeclStmt( id$,ty:TType,init:TExpr )
		Self.decl=New TLocalDecl.Create( id,ty,init,0 )	
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TDeclStmt.Create( decl.Copy(), generated )
	End Method
	
	Method OnSemant()
		decl.Semant
		' if scope is already set, don't try to add it to the current scope.
		If Not decl.scope Then
			_env.InsertDecl decl
		End If
	End Method
	
	Method Trans$()
		Return _trans.TransDeclStmt( Self )
	End Method
End Type

Type TAssignStmt Extends TStmt
	Field op$
	Field lhs:TExpr
	Field rhs:TExpr
	
	Method Create:TAssignStmt( op$,lhs:TExpr,rhs:TExpr, generated:Int = False )
		Self.op=op
		Self.lhs=lhs
		Self.rhs=rhs
		Self.generated = generated
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TAssignStmt.Create( op,lhs.Copy(),rhs.Copy(), generated )
	End Method
	
	Method OnSemant()
		If TIdentExpr(rhs) Then
			TIdentExpr(rhs).isRhs = True
		End If
		rhs=rhs.Semant()
		lhs=lhs.SemantSet( op,rhs )
		If TInvokeExpr( lhs ) Or TInvokeMemberExpr( lhs )
			rhs=Null
		Else
			If IsPointerType(lhs.exprType, 0, TType.T_POINTER | TType.T_VARPTR) And TNumericType(rhs.exprType) Then
				' with pointer assignment we don't cast the numeric to a pointer
				
			Else If IsPointerType(lhs.exprType, 0, TType.T_VAR) And TNumericType(rhs.exprType) Then
				' for var, we cast to the non-var type
				Local ty:TType = lhs.exprType.Copy()
				ty._flags :~ TType.T_VAR
				rhs=rhs.Cast( ty )
			Else
				Local splitOp:Int = True
				Select op
					Case "="
					
						rhs=rhs.Cast( lhs.exprType )
						splitOp = False
						
					Case ":*",":/",":+",":-"
					
						If TNumericType( lhs.exprType ) And lhs.exprType.EqualsType( rhs.exprType ) Then
							splitOp = False
						End If
						
						If TObjectType(lhs.exprType) Then
							Local args:TExpr[] = [rhs]
							Try
								Local decl:TFuncDecl = TFuncDecl(TObjectType(lhs.exprType).classDecl.FindFuncDecl(op, args,,,,True,SCOPE_CLASS_HEIRARCHY))
								If decl Then
									lhs = New TInvokeMemberExpr.Create( lhs, decl, args ).Semant()
									rhs = Null
									Return
								End If
							Catch error:String
								Err "Operator " + op + " cannot be used with Objects."
							End Try
						End If
					
					Case ":&",":|",":^",":shl",":shr",":mod"
					
						If (TIntType( lhs.exprType ) And lhs.exprType.EqualsType( rhs.exprType ))  Or TObjectType(lhs.exprType) Then
							splitOp = False
						End If

						If TObjectType(lhs.exprType) Then
							Local args:TExpr[] = [rhs]
							Try
								Local decl:TFuncDecl = TFuncDecl(TObjectType(lhs.exprType).classDecl.FindFuncDecl(op, args,,,,,SCOPE_CLASS_HEIRARCHY))
								If decl Then
									lhs = New TInvokeMemberExpr.Create( lhs, decl, args ).Semant()
									rhs = Null
									Return
								End If
							Catch error:String
								Err "Operator " + op + " cannot be used with Objects."
							End Try
						End If
				End Select
				
				If splitOp Then
					rhs = New TBinaryMathExpr.Create(op[1..], lhs, rhs).Semant().Cast(lhs.exprType)
					op = "="
				End If
				
			End If
		EndIf
	End Method
	
	Method Trans$()
		_errInfo=errInfo
		Return _trans.TransAssignStmt( Self )
	End Method
End Type

Type TExprStmt Extends TStmt
	Field expr:TExpr
	
	Method Create:TExprStmt( expr:TExpr )
		Self.expr=expr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TExprStmt.Create( expr.Copy() )
	End Method
		
	Method OnSemant()
		expr=expr.Semant()
		If Not expr InternalErr
	End Method

	Method Trans$()
		Return _trans.TransExprStmt( Self )
	End Method
End Type

Type TReturnStmt Extends TStmt
	Field expr:TExpr
	Field fRetType:TType

	Method Create:TReturnStmt( expr:TExpr )
		Self.expr=expr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		If expr Return New TReturnStmt.Create( expr.Copy() )
		Return New TReturnStmt.Create( Null )
	End Method
	
	Method OnSemant()
		Local fdecl:TFuncDecl=_env.FuncScope()
		If expr
			If TIdentExpr(expr) Then
				TIdentExpr(expr).isRhs = True
			End If
			If fdecl.IsCtor() Err "Constructors may not return a value."
			If TVoidType( fdecl.retType ) Then
				Local errorText:String = "Function can not return a value."
				If Not _env.ModuleScope().IsSuperStrict() Then
					errorText :+ " You may have Strict type overriding SuperStrict type."
				End If
				Err errorText
			End If
			fRetType = fdecl.retType
			expr=expr.SemantAndCast( fdecl.retType )
		Else If fdecl.IsCtor()
			expr=New TSelfExpr.Semant()
		Else If Not TVoidType( fdecl.retType )
			If _env.ModuleScope().IsSuperStrict() Err "Function must return a value"
			expr=New TConstExpr.Create( fdecl.retType,"" ).Semant()
		EndIf
	End Method
	
	Method Trans$()
		Return _trans.TransReturnStmt( Self )
	End Method
End Type

Type TTryStmt Extends TStmt

	Field block:TBlockDecl
	Field catches:TCatchStmt[]
	
	Method Create:TTryStmt( block:TBlockDecl,catches:TCatchStmt[] )
		Self.block=block
		Self.catches=catches
		Return Self
	End Method
	
	Method OnCopy:TStmt( scope:TScopeDecl )
		Local tcatches:TCatchStmt[] = Self.catches[..]
		For Local i:Int=0 Until tcatches.Length
			tcatches[i]=TCatchStmt( tcatches[i].Copy( scope ) )
		Next
		Return New TTryStmt.Create( block.CopyBlock( scope ),tcatches )
	End Method
	
	Method OnSemant()
		block.Semant
		Local hasObject:Int = False
		For Local i:Int = 0 Until catches.Length
			catches[i].Semant
			If hasObject Then
				PushErr catches[i].errInfo
				Err "Catch variable class extends earlier catch variable class"
			End If
			If TObjectType(catches[i].init.ty) And TObjectType(catches[i].init.ty).classdecl.ident = "Object" Then
				hasObject = True
				Continue
			End If
			For Local j:Int = 0 Until i
				If catches[i].init.ty.ExtendsType( catches[j].init.ty )
					PushErr catches[i].errInfo
					Err "Catch variable class extends earlier catch variable class"
				EndIf
			Next
		Next
	End Method
	
	Method Trans$()
		Return _trans.TransTryStmt( Self )
	End Method
	
End Type

Type TCatchStmt Extends TStmt

	Field init:TLocalDecl
	Field block:TBlockDecl
	
	Method Create:TCatchStmt( init:TLocalDecl,block:TBlockDecl )
		Self.init=init
		Self.block=block
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TCatchStmt.Create( TLocalDecl( init.Copy() ),block.CopyBlock( scope ) )
	End Method
	
	Method OnSemant()
		init.Semant
		If Not TObjectType( init.ty )  And Not TStringType(init.ty) Err "Variable type must extend Throwable"
		'If Not init.Type.GetClass().IsThrowable() Err "Variable type must extend Throwable"
		block.InsertDecl init
		block.Semant
	End Method
	
	Method Trans$()
	End Method

End Type

Type TThrowStmt Extends TStmt
	Field expr:TExpr

	Method Create:TThrowStmt( expr:TExpr )
		Self.expr=expr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TThrowStmt.Create( expr.Copy() )
	End Method
	
	Method OnSemant()
		expr=expr.Semant()
		If Not TObjectType( expr.exprType ) And Not TStringType(expr.exprType) Err "Expression Type must extend Throwable"
		'If Not expr.exprType.GetClass().IsThrowable() Err "Expression type must extend Throwable"
	End Method
	
	Method Trans$()
	' TODO
		Return _trans.TransThrowStmt( Self )
	End Method
End Type

Type TBreakStmt Extends TStmt

	Field loop:TLoopStmt
	Field label:TExpr

	Method Create:TBreakStmt( label:TExpr )
		Self.label=label
		Return Self
	End Method

	Method OnSemant()
		If Not _loopnest Err "Exit statement must appear inside a loop."
		If label Then
			label = label.Semant()
		End If
		If opt_debug And Not loop Then
			loop = TLoopStmt(_env.FindLoop())
			If Not loop Err "Cannot find loop for Exit."
		End If
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TBreakStmt.Create(label.Copy())
	End Method
	
	Method Trans$()
		Return _trans.TransBreakStmt( Self )
	End Method
	
End Type

Type TContinueStmt Extends TStmt

	Field loop:TLoopStmt
	Field label:TExpr
	
	Method Create:TContinueStmt( label:TExpr, generated:Int = False )
		Self.label=label
		Self.generated = generated
		Return Self
	End Method

	Method OnSemant()
		If Not _loopnest Err "Continue statement must appear inside a loop."
		If label Then
			label = label.Semant()
		End If
		If opt_debug And Not loop Then
			loop = TLoopStmt(_env.FindLoop())
			If Not loop Err "Cannot find loop for Continue."
		End If
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		If label Then
			Return New TContinueStmt.Create(label.Copy(), generated)
		Else
			Return New TContinueStmt.Create(Null, generated)
		End If
	End Method
	
	Method Trans$()
		Return _trans.TransContinueStmt( Self )
	End Method
	
End Type

Type TIfStmt Extends TStmt
	Field expr:TExpr
	Field thenBlock:TBlockDecl
	Field elseBlock:TBlockDecl
	
	Method Create:TIfStmt( expr:TExpr,thenBlock:TBlockDecl,elseBlock:TBlockDecl, generated:Int = False )
		Self.expr=expr
		Self.thenBlock=thenBlock
		Self.elseBlock=elseBlock
		Self.generated = generated
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TIfStmt.Create( expr.Copy(),thenBlock.CopyBlock( scope ),elseBlock.CopyBlock( scope ), generated )
	End Method
	
	Method OnSemant()
		expr=expr.SemantAndCast( New TBoolType,CAST_EXPLICIT )
		thenBlock.Semant
		elseBlock.Semant
	End Method
	
	Method Trans$()
		Return _trans.TransIfStmt( Self )
	End Method
End Type

Type TLoopStmt Extends TStmt

	Field loopLabel:TLoopLabelDecl
	Field block:TBlockDecl

End Type

Type TWhileStmt Extends TLoopStmt
	Field expr:TExpr
	
	Method Create:TWhileStmt( expr:TExpr,block:TBlockDecl,loopLabel:TLoopLabelDecl, generated:Int = False )
		Self.expr=expr
		Self.block=block
		Self.loopLabel = loopLabel
'		If loopLabel Then
			block.extra = Self
'		End If
		Self.generated = generated
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TWhileStmt.Create( expr.Copy(),block.CopyBlock( scope ),TLoopLabelDecl(loopLabel.Copy()), generated )
	End Method
	
	Method OnSemant()
		expr=expr.SemantAndCast( New TBoolType,CAST_EXPLICIT )
		_loopnest:+1
		block.Semant
		_loopnest:-1
	End Method
	
	Method Trans$()
		Return _trans.TransWhileStmt( Self )
	End Method
End Type

Type TRepeatStmt Extends TLoopStmt
	Field expr:TExpr
	
	Method Create:TRepeatStmt( block:TBlockDecl,expr:TExpr,loopLabel:TLoopLabelDecl )
		Self.block=block
		Self.expr=expr
		Self.loopLabel=loopLabel
'		If loopLabel Then
			block.extra = Self
'		End If
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TRepeatStmt.Create( block.CopyBlock( scope ),expr.Copy(),TLoopLabelDecl(loopLabel.Copy()) )
	End Method
	
	Method OnSemant()
		_loopnest:+1
		block.Semant
		_loopnest:-1
		expr=expr.SemantAndCast( New TBoolType,CAST_EXPLICIT )
	End Method
	
	Method Trans$()
		Return _trans.TransRepeatStmt( Self )
	End Method
End Type

Type TForStmt Extends TLoopStmt
	Field init:TStmt	'assignment or local decl...
	Field expr:TExpr
	Field incr:TStmt	'assignment...
	
	Method Create:TForStmt( init:TStmt,expr:TExpr,incr:TStmt,block:TBlockDecl,loopLabel:TLoopLabelDecl )
		Self.init=init
		Self.expr=expr
		Self.incr=incr
		Self.block=block
		Self.loopLabel=loopLabel
'		If loopLabel Then
			block.extra = Self
'		End If
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TForStmt.Create( init.Copy( scope ),expr.Copy(),incr.Copy( scope ),block.CopyBlock( scope ),TLoopLabelDecl(loopLabel.Copy()) )
	End Method
	
	Method OnSemant()

		PushEnv block

		Local updateCastTypes:Int
		If TAssignStmt(init) And TIdentExpr(TAssignStmt(init).lhs) Then
			updateCastTypes = True
		End If
		init.Semant

		PopEnv

		If updateCastTypes Then
			' ty in the casts are currently Null - we didn't know at the time of creating the statement, what the variable type was.
			' Now we do, so we'll fill in the gaps.
			TCastExpr(TBinaryCompareExpr(expr).rhs).ty = TAssignStmt(init).lhs.exprType.Copy()
			TCastExpr(TBinaryMathExpr(TAssignStmt(incr).rhs).rhs).ty = TAssignStmt(init).lhs.exprType.Copy()
		End If

		expr=expr.Semant()

		' for anything other than a const value, use a new local variable
		If Not TConstExpr(TBinaryCompareExpr(expr).rhs) Then
			Local tmp:TLocalDecl=New TLocalDecl.Create( "", TBinaryCompareExpr(expr).rhs.exprType,TBinaryCompareExpr(expr).rhs,, True )
			tmp.Semant()
			Local v:TVarExpr = New TVarExpr.Create( tmp )
			TBinaryCompareExpr(expr).rhs = New TStmtExpr.Create( New TDeclStmt.Create( tmp ), v ).Semant()
		End If
		
		_loopnest:+1
		block.Semant
		_loopnest:-1

		incr.Semant

		'dodgy as hell! Reverse comparison for backward loops!
		Local assop:TAssignStmt=TAssignStmt( incr )
		Local addop:TBinaryExpr=TBinaryExpr( assop.rhs )
		Local stpval$=addop.rhs.Eval()
		If stpval.StartsWith( "-" )
			Local bexpr:TBinaryExpr=TBinaryExpr( expr )
			Select bexpr.op
			Case "<" bexpr.op=">"
			Case "<=" bexpr.op=">="
			End Select
		EndIf
		
	End Method
	
	Method Trans$()
		Return _trans.TransForStmt( Self )
	End Method
End Type

Type TAssertStmt Extends TStmt
	Field expr:TExpr
	Field elseExpr:TExpr
	
	Method Create:TAssertStmt( expr:TExpr, elseExpr:TExpr )
		Self.expr=expr
		Self.elseExpr=elseExpr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		If elseExpr Then
			Return New TAssertStmt.Create( expr.Copy(),elseExpr.Copy() )
		Else
			Return New TAssertStmt.Create( expr.Copy(), Null )
		End If
	End Method
	
	Method OnSemant()
		expr=expr.SemantAndCast( New TBoolType,CAST_EXPLICIT )
		If elseExpr Then
			elseExpr = elseExpr.SemantAndCast(New TStringType,CAST_EXPLICIT)
		Else
			elseExpr = New TConstExpr.Create(New TStringType, "Assert failed")
		End If
	End Method
	
	Method Trans$()
		Return _trans.TransAssertStmt( Self )
	End Method
End Type

Type TEndStmt Extends TStmt
	
	Method Create:TEndStmt( )
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TEndStmt.Create( )
	End Method
	
	Method OnSemant()
	End Method
	
	Method Trans$()
		Return _trans.TransEndStmt( Self )
	End Method
End Type

Type TReleaseStmt Extends TStmt
	Field expr:TExpr

	Method Create:TReleaseStmt( expr:TExpr )
		Self.expr=expr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TReleaseStmt.Create( expr.Copy() )
	End Method
	
	Method OnSemant()
		expr=expr.Semant()
		If Not TVarExpr( expr ) And Not TMemberVarExpr( expr) And Not TIndexExpr( expr ) err "Expression must be a variable"
		If Not TNumericType(expr.exprType) Err "Subexpression for release must be an integer variable"
	End Method
	
	Method Trans$()
		Return _trans.TransReleaseStmt( Self )
	End Method
End Type

Type TReadDataStmt Extends TStmt
	Field args:TExpr[]

	Method Create:TReadDataStmt( args:TExpr[] )
		Self.args=args
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TReadDataStmt.Create( TExpr.CopyArgs(args) )
	End Method

	Method OnSemant()
		If args Then
			For Local i:Int = 0 Until args.length
				args[i]=args[i].Semant()
				
				Local arg:TExpr = args[i]
				
				If Not TVarExpr(arg) And Not TMemberVarExpr(arg) And Not TIndexExpr(arg) And Not (TStmtExpr(arg) And TIndexExpr(TStmtExpr(arg).expr)) Then
					Err "Expression must be a variable"
				End If
			Next
		End If
	End Method

	Method Trans$()
		Return _trans.TransReadDataStmt( Self )
	End Method
	
End Type

Type TRestoreDataStmt Extends TStmt
	Field expr:TExpr

	Method Create:TRestoreDataStmt( expr:TExpr )
		Self.expr=expr
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TRestoreDataStmt.Create( expr.Copy() )
	End Method

	Method OnSemant()
		If Not TIdentExpr(expr) Then
			' todo : better (more specific) error?
			Err "Expecting identifier"
		Else
			Local label:String = TIdentExpr(expr).ident
			TIdentExpr(expr).ident = "#" + TIdentExpr(expr).ident
			expr=expr.Semant()
			
			If Not expr Then
				Err "Label '" + label + "' not found"
			End If
		End If
	End Method

	Method Trans$()
		Return _trans.TransRestoreDataStmt( Self )
	End Method
	
End Type

Type TNativeStmt Extends TStmt
	Field raw:String
	
	Method Create:TNativeStmt( raw:String )
		Self.raw = raw
		Return Self
	End Method

	Method OnCopy:TStmt( scope:TScopeDecl )
		Return New TNativeStmt.Create( raw )
	End Method
		
	Method OnSemant()
	End Method

	Method Trans$()
		Return _trans.TransNativeStmt( Self )
	End Method
End Type
' Copyright (c) 2016 Bruce A Henderson
' 
' Permission is hereby granted, free of charge, to any person obtaining a copy
' of this software and associated documentation files (the "Software"), to deal
' in the Software without restriction, including without limitation the rights
' to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
' copies of the Software, and to permit persons to whom the Software is
' furnished to do so, subject to the following conditions:
' 
' The above copyright notice and this permission notice shall be included in
' all copies or substantial portions of the Software.
' 
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
' IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
' FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
' AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
' LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
' OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
' THE SOFTWARE.
' 
SuperStrict

Import "stringbuffer_glue.c"
?Not bmxng
Import "stringbuffer_uni_conv.c"
?

Extern
	Function bmx_stringbuffer_new:Byte Ptr(initial:Int)
	Function bmx_stringbuffer_free(buffer:Byte Ptr)

	Function bmx_stringbuffer_count:Int(buffer:Byte Ptr)
	Function bmx_stringbuffer_capacity:Int(buffer:Byte Ptr)
	Function bmx_stringbuffer_setlength(buffer:Byte Ptr, length:Int)
	Function bmx_stringbuffer_tostring:String(buffer:Byte Ptr)
	Function bmx_stringbuffer_append_string(buffer:Byte Ptr, value:String)
	Function bmx_stringbuffer_remove(buffer:Byte Ptr, startIndex:Int, endIndex:Int)
	Function bmx_stringbuffer_insert(buffer:Byte Ptr, offset:Int, value:String)
	Function bmx_stringbuffer_reverse(buffer:Byte Ptr)
	Function bmx_stringbuffer_substring:String(buffer:Byte Ptr, beginIndex:Int, endIndex:Int)
	Function bmx_stringbuffer_append_stringbuffer(buffer:Byte Ptr, buffer2:Byte Ptr)
	Function bmx_stringbuffer_startswith:Int(buffer:Byte Ptr, subString:String)
	Function bmx_stringbuffer_endswith:Int(buffer:Byte Ptr, subString:String)
	Function bmx_stringbuffer_find:Int(buffer:Byte Ptr, subString:String, startIndex:Int)
	Function bmx_stringbuffer_findlast:Int(buffer:Byte Ptr, subString:String, startIndex:Int)
	Function bmx_stringbuffer_tolower(buffer:Byte Ptr)
	Function bmx_stringbuffer_toupper(buffer:Byte Ptr)
	Function bmx_stringbuffer_trim(buffer:Byte Ptr)
	Function bmx_stringbuffer_replace(buffer:Byte Ptr, subString:String, withString:String)
	Function bmx_stringbuffer_join(buffer:Byte Ptr, bits:String[], newBuffer:Byte Ptr)
	Function bmx_stringbuffer_split:Byte Ptr(buffer:Byte Ptr, separator:String)
	Function bmx_stringbuffer_setcharat(buffer:Byte Ptr, index:Int, char:Int)
	Function bmx_stringbuffer_charat:Int(buffer:Byte Ptr, index:Int)
	Function bmx_stringbuffer_removecharat(buffer:Byte Ptr, index:Int)
	Function bmx_stringbuffer_append_cstring(buffer:Byte Ptr, chars:Byte Ptr)
	Function bmx_stringbuffer_append_utf8string(buffer:Byte Ptr, chars:Byte Ptr)

	Function bmx_stringbuffer_splitbuffer_length:Int(splitPtr:Byte Ptr)
	Function bmx_stringbuffer_splitbuffer_text:String(splitPtr:Byte Ptr, index:Int)
	Function bmx_stringbuffer_splitbuffer_free(splitPtr:Byte Ptr)
	Function bmx_stringbuffer_splitbuffer_toarray:String[](splitPtr:Byte Ptr)

End Extern

' Copyright (c) 2016 Bruce A Henderson
' 
' Permission is hereby granted, free of charge, to any person obtaining a copy
' of this software and associated documentation files (the "Software"), to deal
' in the Software without restriction, including without limitation the rights
' to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
' copies of the Software, and to permit persons to whom the Software is
' furnished to do so, subject to the following conditions:
' 
' The above copyright notice and this permission notice shall be included in
' all copies or substantial portions of the Software.
' 
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
' IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
' FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
' AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
' LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
' OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
' THE SOFTWARE.
' 
SuperStrict

Rem
bbdoc: A string buffer.
End Rem	
'Module BaH.StringBuffer

'ModuleInfo "Version: 1.03"
'ModuleInfo "License: MIT"
'ModuleInfo "Copyright: 2016 Bruce A Henderson"

'ModuleInfo "History: 1.03"
'ModuleInfo "History: Added overloaded constructor for providing instance specific initial capacity."
'ModuleInfo "History: 1.02"
'ModuleInfo "History: Added AppendCString() and AppendUTF8String() methods."
'ModuleInfo "History: 1.01"
'ModuleInfo "History: Added CharAt(), SetCharAt() and RemoveCharAt() methods."
'ModuleInfo "History: 1.00 Initial Release"


Import "stringbuffer_common.bmx"

Rem
bbdoc: A modifiable String.
about: A string buffer provides functionality to efficiently insert, replace, remove, append and reverse.
It is an order of magnitude faster to append Strings to a TStringBuffer than it is to append Strings to Strings.
End Rem	
Type TStringBuffer

	' the char buffer
	Field buffer:Byte Ptr
	
	Global initialCapacity:Int = 16
	
	Method New()
		buffer = bmx_stringbuffer_new(initialCapacity)
	End Method
?bmxng
	Method New(initialCapacity:Int)
		buffer = bmx_stringbuffer_new(initialCapacity)
	End Method
?
	Rem
	bbdoc: Constructs a string buffer initialized to the contents of the specified string.
	End Rem	
	Function Create:TStringBuffer(Text:String)
?Not bmxng
		Local this:TStringBuffer = New TStringBuffer
?bmxng
		Local this:TStringBuffer
		If text.length > initialCapacity Then
			this = New TStringBuffer(text.length)
		Else
			this = New TStringBuffer
		End If
?
		Return this.Append(Text)
	End Function

	Rem
	bbdoc: Returns the length of the string the string buffer would create.
	End Rem	
	Method Length:Int()
		Return bmx_stringbuffer_count(buffer)
	End Method
	
	Rem
	bbdoc: Returns the total number of characters that the string buffer can accommodate before needing to grow.
	End Rem	
	Method Capacity:Int()
		Return bmx_stringbuffer_capacity(buffer)
	End Method
	
	Rem
	bbdoc: Sets the length of the string buffer.
	about: If the length is less than the current length, the current text will be truncated. Otherwise,
	the capacity will be increased as necessary, although the actual length of text will remain the same.
	End Rem	
	Method SetLength(length:Int)
		bmx_stringbuffer_setlength(buffer, length)
	End Method
	
	Rem
	bbdoc: Appends the text onto the string buffer.
	End Rem	
	Method Append:TStringBuffer(value:String)
		bmx_stringbuffer_append_string(buffer, value)
		Return Self
	End Method

	Rem
	bbdoc: Appends an object onto the string buffer.
	about: This generally calls the object's ToString() method.
	TStringBuffer objects are simply mem-copied.
	End Rem
	Method AppendObject:TStringBuffer(obj:Object)
		If TStringBuffer(obj) Then
			bmx_stringbuffer_append_stringbuffer(buffer, TStringBuffer(obj).buffer)
		Else
			bmx_stringbuffer_append_string(buffer, obj.ToString())
		End If
		Return Self
	End Method
	
	Rem
	bbdoc: Appends a null-terminated C string onto the string buffer.
	End Rem
	Method AppendCString:TStringBuffer(chars:Byte Ptr)
		bmx_stringbuffer_append_cstring(buffer, chars)
		Return Self
	End Method
	
	Rem
	bbdoc: Appends a null-terminated UTF-8 string onto the string buffer.
	End Rem
	Method AppendUTF8String:TStringBuffer(chars:Byte Ptr)
		bmx_stringbuffer_append_utf8string(buffer, chars)
		Return Self
	End Method
	
	Rem
	bbdoc: Finds first occurance of a sub string.
	returns: -1 if @subString not found.
	End Rem
	Method Find:Int(subString:String, startIndex:Int = 0)
		Return bmx_stringbuffer_find(buffer, subString, startIndex)
	End Method
	
	Rem
	bbdoc: Finds last occurance of a sub string.
	returns: -1 if @subString not found.
	End Rem
	Method FindLast:Int(subString:String, startIndex:Int = 0)
		Return bmx_stringbuffer_findlast(buffer, subString, startIndex)
	End Method
	
	Rem
	bbdoc: Removes leading and trailing non-printable characters from the string buffer.
	End Rem
	Method Trim:TStringBuffer()
		bmx_stringbuffer_trim(buffer)
		Return Self
	End Method
	
	Rem
	bbdoc: Replaces all occurances of @subString with @withString.
	End Rem
	Method Replace:TStringBuffer(subString:String, withString:String)
		bmx_stringbuffer_replace(buffer, subString, withString)
		Return Self
	End Method
	
	Rem
	bbdoc: Returns true if string starts with @subString.
	End Rem
	Method StartsWith:Int(subString:String)
		Return bmx_stringbuffer_startswith(buffer, subString)
	End Method
	
	Rem
	bbdoc: Returns true if string ends with @subString.
	End Rem
	Method EndsWith:Int(subString:String)
		Return bmx_stringbuffer_endswith(buffer, subString)
	End Method
	
	Rem
	bbdoc: Returns the char value in the buffer at the specified index.
	about: The first char value is at index 0, the next at index 1, and so on, as in array indexing.
	@index must be greater than or equal to 0, and less than the length of the buffer.
	End Rem
	Method CharAt:Int(index:Int)
		Return bmx_stringbuffer_charat(buffer, index)
	End Method
	
	Rem
	bbdoc: Returns true if string contains @subString.
	End Rem
	Method Contains:Int(subString:String)
		Return Find(subString) >= 0
	End Method
	
	Rem
	bbdoc: Joins @bits together by inserting this string buffer between each bit.
	returns: A new TStringBuffer object.
	End Rem
	Method Join:TStringBuffer(bits:String[])
		Local buf:TStringBuffer = New TStringBuffer
		bmx_stringbuffer_join(buffer, bits, buf.buffer)
		Return buf
	End Method

	Rem
	bbdoc: Converts all of the characters in the buffer to lower case.
	End Rem	
	Method ToLower:TStringBuffer()
		bmx_stringbuffer_tolower(buffer)
		Return Self
	End Method
	
	Rem
	bbdoc: Converts all of the characters in the buffer to upper case.
	End Rem	
	Method ToUpper:TStringBuffer()
		bmx_stringbuffer_toupper(buffer)
		Return Self
	End Method

	Rem
	bbdoc: Removes a range of characters from the string buffer.
	about: @startIndex is the first character to remove. @endIndex is the index after the last character to remove.
	End Rem
	Method Remove:TStringBuffer(startIndex:Int, endIndex:Int)
		bmx_stringbuffer_remove(buffer, startIndex, endIndex)
		Return Self
	End Method

	Rem
	bbdoc: Removes the character at the specified position in the buffer.
	about: The buffer is shortened by one character.
	End Rem
	Method RemoveCharAt:TStringBuffer(index:Int)
		bmx_stringbuffer_removecharat(buffer, index)
		Return Self
	End Method
	
	Rem
	bbdoc: Inserts text into the string buffer at the specified offset.
	End Rem
	Method Insert:TStringBuffer(offset:Int, value:String)
		bmx_stringbuffer_insert(buffer, offset, value)
		Return Self
	End Method
	
	Rem
	bbdoc: Reverses the characters of the string buffer.
	End Rem
	Method Reverse:TStringBuffer()
		bmx_stringbuffer_reverse(buffer)
		Return Self
	End Method
	
	Rem
	bbdoc: The character at the specified index is set to @char.
	about: @index must be greater than or equal to 0, and less than the length of the buffer.
	End Rem
	Method SetCharAt(index:Int, char:Int)
		bmx_stringbuffer_setcharat(buffer, index, char)
	End Method
	
	Rem
	bbdoc: Returns a substring of the string buffer given the specified indexes.
	about: @beginIndex is the first character of the substring.
	@endIndex is the index after the last character of the substring. If @endIndex is zero,
	will return everything from @beginIndex until the end of the string buffer.
	End Rem
	Method Substring:String(beginIndex:Int, endIndex:Int = 0)
		Return bmx_stringbuffer_substring(buffer, beginIndex, endIndex)
	End Method
	
	Rem
	bbdoc: 
	End Rem
	Method Split:TSplitBuffer(separator:String)
		Local buf:TSplitBuffer = New TSplitBuffer
		buf.buffer = Self
		buf.splitPtr = bmx_stringbuffer_split(buffer, separator)
		Return buf
	End Method
	
	Rem
	bbdoc: Converts the string buffer to a String.
	End Rem	
	Method ToString:String()
		Return bmx_stringbuffer_tostring(buffer)
	End Method

	Method Delete()
		If buffer Then
			bmx_stringbuffer_free(buffer)
			buffer = Null
		End If
	End Method

End Type

Rem
bbdoc: An array of split text from a TStringBuffer.
about: Note that the TSplitBuffer is only valid while its parent TStringBuffer is unchanged.
Once you modify the TStringBuffer you should call Split() again.
End Rem
Type TSplitBuffer
	Field buffer:TStringBuffer
	Field splitPtr:Byte Ptr
	
	Rem
	bbdoc: The number of split elements.
	End Rem
	Method Length:Int()
		Return bmx_stringbuffer_splitbuffer_length(splitPtr)
	End Method
	
	Rem
	bbdoc: Returns the text for the given index in the split buffer.
	End Rem
	Method Text:String(index:Int)
		Return bmx_stringbuffer_splitbuffer_text(splitPtr, index)
	End Method
	
	Rem
	bbdoc: Creates a new string array of all the split elements.
	End Rem
	Method ToArray:String[]()
		Return bmx_stringbuffer_splitbuffer_toarray(splitPtr)
	End Method

	Method ObjectEnumerator:TSplitBufferEnum()
		Local enum:TSplitBufferEnum = New TSplitBufferEnum
		enum.buffer = Self
		enum.length = Length()
		Return enum
	End Method

	Method Delete()
		If splitPtr Then
			buffer = Null
			bmx_stringbuffer_splitbuffer_free(splitPtr)
			splitPtr = Null
		End If
	End Method
	
End Type

Type TSplitBufferEnum

	Field index:Int
	Field length:Int
	Field buffer:TSplitBuffer

	Method HasNext:Int()
		Return index < length
	End Method

	Method NextObject:Object()
		Local s:String = buffer.Text(index)
		index :+ 1
		Return s
	End Method

End Type
/*
  Copyright (c) 2016 Bruce A Henderson
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/ 

#include "brl.mod/blitz.mod/blitz.h"
#ifndef BMX_NG
extern unsigned short maxToLowerData[];
extern unsigned short maxToUpperData[];
#define bbToLowerData maxToLowerData
#define bbToUpperData maxToUpperData
#else
#include "brl.mod/blitz.mod/blitz_unicode.h"
#endif

struct MaxStringBuffer {
	BBChar * buffer;
	int count;
	int capacity;
};

struct MaxSplitBuffer {
	struct MaxStringBuffer * buffer;
	int count;
	int * startIndex;
	int * endIndex;
};

void bmx_stringbuffer_free(struct MaxStringBuffer * buf) {
	free(buf->buffer);
	free(buf);
}

struct MaxStringBuffer * bmx_stringbuffer_new(int initial) {
	struct MaxStringBuffer * buf = malloc(sizeof(struct MaxStringBuffer));
	
	buf->count = 0;
	buf->capacity = initial;
	buf->buffer = malloc(initial * sizeof(BBChar));
	
	return buf;
}

/* make more capacity if requested size greater */
void bmx_stringbuffer_resize(struct MaxStringBuffer * buf, int size) {
	if (buf->capacity < size) {
		
		if (buf->capacity * 2  > size) {
			size = buf->capacity * 2;
		}
		short * newBuffer = malloc(size * sizeof(BBChar));
		
		/* copy text to new buffer */
		memcpy(newBuffer, buf->buffer, buf->count * sizeof(BBChar));
		
		/* free old buffer */
		free(buf->buffer);
		
		buf->buffer = newBuffer;
		buf->capacity = size;
	}
}

int bmx_stringbuffer_count(struct MaxStringBuffer * buf) {
	return buf->count;
}

int bmx_stringbuffer_capacity(struct MaxStringBuffer * buf) {
	return buf->capacity;
}


void bmx_stringbuffer_setlength(struct MaxStringBuffer * buf, int length) {
	bmx_stringbuffer_resize(buf, length);
	if (length < buf->count) {
		buf->count = length;
	}
}

BBString * bmx_stringbuffer_tostring(struct MaxStringBuffer * buf) {
	if (!buf->count) {
		return &bbEmptyString;
	} else {
		return bbStringFromShorts(buf->buffer, buf->count);
	}
}

void bmx_stringbuffer_append_string(struct MaxStringBuffer * buf, BBString * value) {
	if (value != &bbEmptyString) {
		bmx_stringbuffer_resize(buf, buf->count + value->length);
		BBChar * p = buf->buffer + buf->count;
		memcpy(p, value->buf, value->length * sizeof(BBChar));
		
		buf->count += value->length;
	}	
}

void bmx_stringbuffer_remove(struct MaxStringBuffer * buf, int start, int end) {
	if (start < 0 || start > buf->count || start > end) {
		return;
	}
	
	/* trim end if it is too big */
	if (end > buf->count) {
		end = buf->count;
	}
	
	/* still something to remove ? */
	if (buf->count - end != 0) {
		memcpy(buf->buffer + start, buf->buffer + end, (buf->count - end) * sizeof(BBChar));
	}
	
	buf->count -= end - start;
}

void bmx_stringbuffer_insert(struct MaxStringBuffer * buf, int offset, BBString * value) {
	if (value != &bbEmptyString) {
		if (offset < 0 || offset > buf->count) {
			return;
		}
		
		int length = value->length;
		bmx_stringbuffer_resize(buf, buf->count + length);

		/* make some space for the insertion */
		/* using memmove because data overlaps */
		memmove(buf->buffer + offset + length, buf->buffer + offset, (buf->count - offset) * sizeof(BBChar));
		
		/* insert the string */
		memcpy(buf->buffer + offset, value->buf, length * sizeof(BBChar));
		
		buf->count += length;
	}
}

void bmx_stringbuffer_reverse(struct MaxStringBuffer * buf) {
	int i = buf->count >> 1;
	int n = buf->count - i;
	while (--i >= 0) {
		BBChar c = buf->buffer[i];
		buf->buffer[i] = buf->buffer[n];
		buf->buffer[n] = c;
		n++;
	}
}

BBString * bmx_stringbuffer_substring(struct MaxStringBuffer * buf, int beginIndex, int endIndex) {
	if (!endIndex) {
		endIndex = buf->count;
	}
	
	if (beginIndex < 0 || endIndex > buf->count || endIndex < beginIndex) {
		return &bbEmptyString;
	}
	
	return bbStringFromShorts(buf->buffer + beginIndex, endIndex - beginIndex);
}

void bmx_stringbuffer_append_stringbuffer(struct MaxStringBuffer * buf, struct MaxStringBuffer * other) {
	if (other->count > 0) {
		bmx_stringbuffer_resize(buf, buf->count + other->count);
	
		memcpy(buf->buffer + buf->count, other->buffer, other->count * sizeof(BBChar));
	
		buf->count += other->count;
	}
}

int bmx_stringbuffer_matches(struct MaxStringBuffer * buf, int offset, BBString * subString) {
	int length = subString->length;
	int index = 0;
	while (--length >= 0) {
		if (buf->buffer[offset++] != subString->buf[index++]) {
			return 0;
		}
	}
	return 1;
}

int bmx_stringbuffer_startswith(struct MaxStringBuffer * buf, BBString * subString) {
	if (subString->length <= buf->count) {
		return bmx_stringbuffer_matches(buf, 0, subString);
	}
	return 0;
}

int bmx_stringbuffer_endswith(struct MaxStringBuffer * buf, BBString * subString) {
	if (subString->length <= buf->count) {
		return bmx_stringbuffer_matches(buf, buf->count - subString->length, subString);
	}
}

int bmx_stringbuffer_find(struct MaxStringBuffer * buf, BBString * subString, int startIndex) {
	if (startIndex < 0) {
		startIndex = 0;
	}
	
	int limit = buf->count - subString->length;
	while (startIndex <= limit) {
		if (bmx_stringbuffer_matches(buf, startIndex, subString)) {
			return startIndex;
		}
		startIndex++;
	}
	return -1;
}

int bmx_stringbuffer_findlast(struct MaxStringBuffer * buf, BBString * subString, int startIndex) {
	if (startIndex < 0) {
		startIndex = 0;
	}
	
	startIndex = buf->count - startIndex;

	if (startIndex + subString->length > buf->count) {
		startIndex = buf->count - subString->length;
	}
	
	while (startIndex >= 0) {
		if (bmx_stringbuffer_matches(buf, startIndex, subString)) {
			return startIndex;
		}
		startIndex--;
	}
	return -1;
}

void bmx_stringbuffer_tolower(struct MaxStringBuffer * buf) {
	int i;
	for (i = 0; i < buf->count; i++ ) {
		int c = buf->buffer[i];
		if (c < 192) {
			c = ( c >= 'A' && c <= 'Z') ? (c|32) : c;
		} else {
			int lo = 0, hi = 3828 / 4 - 1;
			while (lo <= hi) {
				int mid = (lo+hi)/2;
				if (c < bbToLowerData[mid*2]) {
					hi = mid-1;
				} else if (c > bbToLowerData[mid*2]) {
					lo = mid + 1;
				} else {
					c = bbToLowerData[mid*2+1];
					break;
				}
			}
		}
		buf->buffer[i]=c;
	}
}

void bmx_stringbuffer_toupper(struct MaxStringBuffer * buf) {
	int i;
	for (i = 0; i < buf->count; i++) {
		int c = buf->buffer[i];
		if (c < 181) {
			c = (c >= 'a' && c <= 'z') ? (c&~32) : c;
		} else {
			int lo = 0, hi = 3860/4-1;
			while (lo<=hi) {
				int mid=(lo+hi)/2;
				if (c < bbToUpperData[mid*2]) {
					hi = mid - 1;
				} else if (c > bbToUpperData[mid*2]) {
					lo = mid + 1;
				} else {
					c = bbToUpperData[mid*2+1];
					break;
				}
			}
		}
		buf->buffer[i]=c;
	}
}

void bmx_stringbuffer_trim(struct MaxStringBuffer * buf) {
	int start = 0;
	int end = buf->count;
	while (start < end && buf->buffer[start] <= ' ') {
		++start;
	}
	if (start == end ) {
		buf->count = 0;
		return;
	}
	while (buf->buffer[end - 1] <= ' ') {
		--end;
	}
	if (end - start == buf->count) {
		return;
	}

	memmove(buf->buffer, buf->buffer + start, (end - start) * sizeof(BBChar));
	buf->count = end - start;	
}

void bmx_stringbuffer_replace(struct MaxStringBuffer * buf, BBString * subString, BBString *  withString) {
	if (!subString->length) {
		return;
	}
	
	struct MaxStringBuffer * newbuf = bmx_stringbuffer_new(16);
	
	int j, n;
	int i = 0;
	int p = 0;
	
	while( (j = bmx_stringbuffer_find(buf, subString, i)) != -1) {
		n = j - i;
		if (n) {
			bmx_stringbuffer_resize(newbuf, newbuf->count + n);
			memcpy(newbuf->buffer + p, buf->buffer + i, n * sizeof(BBChar));
			newbuf->count += n;
			p += n;
		}
		n = withString->length;
		bmx_stringbuffer_resize(newbuf, newbuf->count + n);
		memcpy(newbuf->buffer + p, withString->buf, n * sizeof(BBChar));
		newbuf->count += n;
		p += n;
		i = j + subString->length;
	}

	n = buf->count - i;
	if (n) {
		bmx_stringbuffer_resize(newbuf, newbuf->count + n);
		memcpy(newbuf->buffer + p, buf->buffer + i, n*sizeof(BBChar));
		newbuf->count += n;
	}

	bmx_stringbuffer_setlength(buf, 0);
	bmx_stringbuffer_append_stringbuffer(buf, newbuf);
	bmx_stringbuffer_free(newbuf);
}

void bmx_stringbuffer_join(struct MaxStringBuffer * buf, BBArray * bits, struct MaxStringBuffer * newbuf) {
	if(bits == &bbEmptyArray) {
		return;
	}

	int i;
	int n_bits = bits->scales[0];
	BBString **p = (BBString**)BBARRAYDATA( bits,1 );
	for(i = 0; i < n_bits; ++i) {
		if (i) {
			bmx_stringbuffer_append_stringbuffer(newbuf, buf);
		}
		BBString *bit = *p++;
		bmx_stringbuffer_append_string(newbuf, bit);
	}
}

struct MaxSplitBuffer * bmx_stringbuffer_split(struct MaxStringBuffer * buf, BBString * separator) {
	struct MaxSplitBuffer * splitBuffer = malloc(sizeof(struct MaxSplitBuffer));
	splitBuffer->buffer = buf;
	
	int count = 1;
	int i = 0;
	int offset = 0;
	if (separator->length > 0) {
	
		/* get a count of fields */
		while ((offset = bmx_stringbuffer_find(buf, separator, i)) != -1 ) {
			++count;
			i = offset + separator->length;
		}

		splitBuffer->count = count;
		splitBuffer->startIndex = malloc(count * sizeof(int));
		splitBuffer->endIndex = malloc(count * sizeof(int));

		i = 0;
		
		int * bufferStartIndex = splitBuffer->startIndex;
		int * bufferEndIndex = splitBuffer->endIndex;
		
		while( count-- ){
			offset = bmx_stringbuffer_find(buf, separator, i);
			if (offset == -1) {
				offset = buf->count;
			}
			
			*bufferStartIndex++ = i;
			*bufferEndIndex++ = offset;

			i = offset + separator->length;
		}

	} else {
		// TODO - properly handle Null separator
		
		splitBuffer->count = count;
		splitBuffer->startIndex = malloc(count * sizeof(int));
		splitBuffer->endIndex = malloc(count * sizeof(int));
		
		*splitBuffer->startIndex = 0;
		*splitBuffer->endIndex = buf->count;

	}
	
	return splitBuffer;
}

void bmx_stringbuffer_setcharat(struct MaxStringBuffer * buf, int index, int ch) {
	if (index < 0 || index > buf->count) {
		return;
	}

	buf->buffer[index] = ch;
}

int bmx_stringbuffer_charat(struct MaxStringBuffer * buf, int index) {
	if (index < 0 || index > buf->count) {
		return 0;
	}

	return buf->buffer[index];
}

void bmx_stringbuffer_removecharat(struct MaxStringBuffer * buf, int index) {
	if (index < 0 || index >= buf->count) {
		return;
	}

	if (index < buf->count - 1) {
		memcpy(buf->buffer + index, buf->buffer + index + 1, (buf->count - index - 1) * sizeof(BBChar));
	}
	
	buf->count--;

}

void bmx_stringbuffer_append_cstring(struct MaxStringBuffer * buf, const char * chars) {
	int length = strlen(chars);
	if (length > 0) {
		int count = length;
		
		bmx_stringbuffer_resize(buf, buf->count + length);
		
		char * p = chars;
		BBChar * b = buf->buffer + buf->count;
		while (length--) {
			*b++ = *p++;
		}
		
		buf->count += count;
	}
}

void bmx_stringbuffer_append_utf8string(struct MaxStringBuffer * buf, const char * chars) {
	int length = strlen(chars);
	if (length > 0) {
		int count = 0;
		
		bmx_stringbuffer_resize(buf, buf->count + length);
		
		int c;
		char * p = chars;
		BBChar * b = buf->buffer + buf->count;
		
		while( c=*p++ & 0xff ){
			if( c<0x80 ){
				*b++=c;
			}else{
				int d=*p++ & 0x3f;
				if( c<0xe0 ){
					*b++=((c&31)<<6) | d;
				}else{
					int e=*p++ & 0x3f;
					if( c<0xf0 ){
						*b++=((c&15)<<12) | (d<<6) | e;
					}else{
						int f=*p++ & 0x3f;
						int v=((c&7)<<18) | (d<<12) | (e<<6) | f;
						if( v & 0xffff0000 ) bbExThrowCString( "Unicode character out of UCS-2 range" );
						*b++=v;
					}
				}
			}
			count++;
		}

		buf->count += count;
	}
}

/* ----------------------------------------------------- */

int bmx_stringbuffer_splitbuffer_length(struct MaxSplitBuffer * buf) {
	return buf->count;
}

BBString * bmx_stringbuffer_splitbuffer_text(struct MaxSplitBuffer * buf, int index) {
	if (index < 0 || index >= buf->count) {
		return &bbEmptyString;
	}

	return bmx_stringbuffer_substring(buf->buffer, buf->startIndex[index], buf->endIndex[index]);
}

void bmx_stringbuffer_splitbuffer_free(struct MaxSplitBuffer * buf) {
	free(buf->startIndex);
	free(buf->endIndex);
	free(buf);
}

BBArray * bmx_stringbuffer_splitbuffer_toarray(struct MaxSplitBuffer * buf) {
	int i, n;
	BBString **p,*bit;
	BBArray *bits;

	n = buf->count;
	
	bits = bbArrayNew1D("$", n);
	p = (BBString**)BBARRAYDATA(bits, 1);

	i = 0;
	while (n--) {
		bit = bmx_stringbuffer_substring(buf->buffer, buf->startIndex[i], buf->endIndex[i]);
		BBINCREFS( bit );
		*p++ = bit;
		i++;
	}
	return bits;
}

unsigned short maxToLowerData[]={
//	65,97,66,98,67,99,68,100,69,101,70,102,71,103,72,104,
//	73,105,74,106,75,107,76,108,77,109,78,110,79,111,80,112,
//	81,113,82,114,83,115,84,116,85,117,86,118,87,119,88,120,
//	89,121,90,122,
	192,224,193,225,194,226,195,227,196,228,197,229,
	198,230,199,231,200,232,201,233,202,234,203,235,204,236,205,237,
	206,238,207,239,208,240,209,241,210,242,211,243,212,244,213,245,
	214,246,216,248,217,249,218,250,219,251,220,252,221,253,222,254,
	256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,
	272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,
	288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,
	304,105,306,307,308,309,310,311,313,314,315,316,317,318,319,320,
	321,322,323,324,325,326,327,328,330,331,332,333,334,335,336,337,
	338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,
	354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,
	370,371,372,373,374,375,376,255,377,378,379,380,381,382,385,595,
	386,387,388,389,390,596,391,392,393,598,394,599,395,396,398,477,
	399,601,400,603,401,402,403,608,404,611,406,617,407,616,408,409,
	412,623,413,626,415,629,416,417,418,419,420,421,422,640,423,424,
	425,643,428,429,430,648,431,432,433,650,434,651,435,436,437,438,
	439,658,440,441,444,445,452,454,453,454,455,457,456,457,458,460,
	459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,
	475,476,478,479,480,481,482,483,484,485,486,487,488,489,490,491,
	492,493,494,495,497,499,498,499,500,501,502,405,503,447,504,505,
	506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,
	522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,
	538,539,540,541,542,543,544,414,546,547,548,549,550,551,552,553,
	554,555,556,557,558,559,560,561,562,563,570,11365,571,572,573,410,
	574,11366,577,578,579,384,580,649,581,652,582,583,584,585,586,587,
	588,589,590,591,880,881,882,883,886,887,902,940,904,941,905,942,
	906,943,908,972,910,973,911,974,913,945,914,946,915,947,916,948,
	917,949,918,950,919,951,920,952,921,953,922,954,923,955,924,956,
	925,957,926,958,927,959,928,960,929,961,931,963,932,964,933,965,
	934,966,935,967,936,968,937,969,938,970,939,971,975,983,984,985,
	986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,
	1002,1003,1004,1005,1006,1007,1012,952,1015,1016,1017,1010,1018,1019,1021,891,
	1022,892,1023,893,1024,1104,1025,1105,1026,1106,1027,1107,1028,1108,1029,1109,
	1030,1110,1031,1111,1032,1112,1033,1113,1034,1114,1035,1115,1036,1116,1037,1117,
	1038,1118,1039,1119,1040,1072,1041,1073,1042,1074,1043,1075,1044,1076,1045,1077,
	1046,1078,1047,1079,1048,1080,1049,1081,1050,1082,1051,1083,1052,1084,1053,1085,
	1054,1086,1055,1087,1056,1088,1057,1089,1058,1090,1059,1091,1060,1092,1061,1093,
	1062,1094,1063,1095,1064,1096,1065,1097,1066,1098,1067,1099,1068,1100,1069,1101,
	1070,1102,1071,1103,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,
	1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,
	1148,1149,1150,1151,1152,1153,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,
	1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,
	1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,
	1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1231,1217,1218,
	1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1232,1233,1234,1235,
	1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,
	1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,
	1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,
	1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,
	1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,
	1329,1377,1330,1378,1331,1379,1332,1380,1333,1381,1334,1382,1335,1383,1336,1384,
	1337,1385,1338,1386,1339,1387,1340,1388,1341,1389,1342,1390,1343,1391,1344,1392,
	1345,1393,1346,1394,1347,1395,1348,1396,1349,1397,1350,1398,1351,1399,1352,1400,
	1353,1401,1354,1402,1355,1403,1356,1404,1357,1405,1358,1406,1359,1407,1360,1408,
	1361,1409,1362,1410,1363,1411,1364,1412,1365,1413,1366,1414,4256,11520,4257,11521,
	4258,11522,4259,11523,4260,11524,4261,11525,4262,11526,4263,11527,4264,11528,4265,11529,
	4266,11530,4267,11531,4268,11532,4269,11533,4270,11534,4271,11535,4272,11536,4273,11537,
	4274,11538,4275,11539,4276,11540,4277,11541,4278,11542,4279,11543,4280,11544,4281,11545,
	4282,11546,4283,11547,4284,11548,4285,11549,4286,11550,4287,11551,4288,11552,4289,11553,
	4290,11554,4291,11555,4292,11556,4293,11557,7680,7681,7682,7683,7684,7685,7686,7687,
	7688,7689,7690,7691,7692,7693,7694,7695,7696,7697,7698,7699,7700,7701,7702,7703,
	7704,7705,7706,7707,7708,7709,7710,7711,7712,7713,7714,7715,7716,7717,7718,7719,
	7720,7721,7722,7723,7724,7725,7726,7727,7728,7729,7730,7731,7732,7733,7734,7735,
	7736,7737,7738,7739,7740,7741,7742,7743,7744,7745,7746,7747,7748,7749,7750,7751,
	7752,7753,7754,7755,7756,7757,7758,7759,7760,7761,7762,7763,7764,7765,7766,7767,
	7768,7769,7770,7771,7772,7773,7774,7775,7776,7777,7778,7779,7780,7781,7782,7783,
	7784,7785,7786,7787,7788,7789,7790,7791,7792,7793,7794,7795,7796,7797,7798,7799,
	7800,7801,7802,7803,7804,7805,7806,7807,7808,7809,7810,7811,7812,7813,7814,7815,
	7816,7817,7818,7819,7820,7821,7822,7823,7824,7825,7826,7827,7828,7829,7838,223,
	7840,7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,
	7856,7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,
	7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,
	7888,7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,
	7904,7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,
	7920,7921,7922,7923,7924,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,
	7944,7936,7945,7937,7946,7938,7947,7939,7948,7940,7949,7941,7950,7942,7951,7943,
	7960,7952,7961,7953,7962,7954,7963,7955,7964,7956,7965,7957,7976,7968,7977,7969,
	7978,7970,7979,7971,7980,7972,7981,7973,7982,7974,7983,7975,7992,7984,7993,7985,
	7994,7986,7995,7987,7996,7988,7997,7989,7998,7990,7999,7991,8008,8000,8009,8001,
	8010,8002,8011,8003,8012,8004,8013,8005,8025,8017,8027,8019,8029,8021,8031,8023,
	8040,8032,8041,8033,8042,8034,8043,8035,8044,8036,8045,8037,8046,8038,8047,8039,
	8072,8064,8073,8065,8074,8066,8075,8067,8076,8068,8077,8069,8078,8070,8079,8071,
	8088,8080,8089,8081,8090,8082,8091,8083,8092,8084,8093,8085,8094,8086,8095,8087,
	8104,8096,8105,8097,8106,8098,8107,8099,8108,8100,8109,8101,8110,8102,8111,8103,
	8120,8112,8121,8113,8122,8048,8123,8049,8124,8115,8136,8050,8137,8051,8138,8052,
	8139,8053,8140,8131,8152,8144,8153,8145,8154,8054,8155,8055,8168,8160,8169,8161,
	8170,8058,8171,8059,8172,8165,8184,8056,8185,8057,8186,8060,8187,8061,8188,8179,
	8486,969,8490,107,8491,229,8498,8526,8544,8560,8545,8561,8546,8562,8547,8563,
	8548,8564,8549,8565,8550,8566,8551,8567,8552,8568,8553,8569,8554,8570,8555,8571,
	8556,8572,8557,8573,8558,8574,8559,8575,8579,8580,9398,9424,9399,9425,9400,9426,
	9401,9427,9402,9428,9403,9429,9404,9430,9405,9431,9406,9432,9407,9433,9408,9434,
	9409,9435,9410,9436,9411,9437,9412,9438,9413,9439,9414,9440,9415,9441,9416,9442,
	9417,9443,9418,9444,9419,9445,9420,9446,9421,9447,9422,9448,9423,9449,11264,11312,
	11265,11313,11266,11314,11267,11315,11268,11316,11269,11317,11270,11318,11271,11319,11272,11320,
	11273,11321,11274,11322,11275,11323,11276,11324,11277,11325,11278,11326,11279,11327,11280,11328,
	11281,11329,11282,11330,11283,11331,11284,11332,11285,11333,11286,11334,11287,11335,11288,11336,
	11289,11337,11290,11338,11291,11339,11292,11340,11293,11341,11294,11342,11295,11343,11296,11344,
	11297,11345,11298,11346,11299,11347,11300,11348,11301,11349,11302,11350,11303,11351,11304,11352,
	11305,11353,11306,11354,11307,11355,11308,11356,11309,11357,11310,11358,11360,11361,11362,619,
	11363,7549,11364,637,11367,11368,11369,11370,11371,11372,11373,593,11374,625,11375,592,
	11378,11379,11381,11382,11392,11393,11394,11395,11396,11397,11398,11399,11400,11401,11402,11403,
	11404,11405,11406,11407,11408,11409,11410,11411,11412,11413,11414,11415,11416,11417,11418,11419,
	11420,11421,11422,11423,11424,11425,11426,11427,11428,11429,11430,11431,11432,11433,11434,11435,
	11436,11437,11438,11439,11440,11441,11442,11443,11444,11445,11446,11447,11448,11449,11450,11451,
	11452,11453,11454,11455,11456,11457,11458,11459,11460,11461,11462,11463,11464,11465,11466,11467,
	11468,11469,11470,11471,11472,11473,11474,11475,11476,11477,11478,11479,11480,11481,11482,11483,
	11484,11485,11486,11487,11488,11489,11490,11491,42560,42561,42562,42563,42564,42565,42566,42567,
	42568,42569,42570,42571,42572,42573,42574,42575,42576,42577,42578,42579,42580,42581,42582,42583,
	42584,42585,42586,42587,42588,42589,42590,42591,42594,42595,42596,42597,42598,42599,42600,42601,
	42602,42603,42604,42605,42624,42625,42626,42627,42628,42629,42630,42631,42632,42633,42634,42635,
	42636,42637,42638,42639,42640,42641,42642,42643,42644,42645,42646,42647,42786,42787,42788,42789,
	42790,42791,42792,42793,42794,42795,42796,42797,42798,42799,42802,42803,42804,42805,42806,42807,
	42808,42809,42810,42811,42812,42813,42814,42815,42816,42817,42818,42819,42820,42821,42822,42823,
	42824,42825,42826,42827,42828,42829,42830,42831,42832,42833,42834,42835,42836,42837,42838,42839,
	42840,42841,42842,42843,42844,42845,42846,42847,42848,42849,42850,42851,42852,42853,42854,42855,
	42856,42857,42858,42859,42860,42861,42862,42863,42873,42874,42875,42876,42877,7545,42878,42879,
	42880,42881,42882,42883,42884,42885,42886,42887,42891,42892,65313,65345,65314,65346,65315,65347,
	65316,65348,65317,65349,65318,65350,65319,65351,65320,65352,65321,65353,65322,65354,65323,65355,
	65324,65356,65325,65357,65326,65358,65327,65359,65328,65360,65329,65361,65330,65362,65331,65363,
	65332,65364,65333,65365,65334,65366,65335,65367,65336,65368,65337,65369,65338,65370 };

unsigned short maxToUpperData[]={
//	97,65,98,66,99,67,100,68,101,69,102,70,103,71,104,72,
//	105,73,106,74,107,75,108,76,109,77,110,78,111,79,112,80,
//	113,81,114,82,115,83,116,84,117,85,118,86,119,87,120,88,
//	121,89,122,90,
	181,924,224,192,225,193,226,194,227,195,228,196,
	229,197,230,198,231,199,232,200,233,201,234,202,235,203,236,204,
	237,205,238,206,239,207,240,208,241,209,242,210,243,211,244,212,
	245,213,246,214,248,216,249,217,250,218,251,219,252,220,253,221,
	254,222,255,376,257,256,259,258,261,260,263,262,265,264,267,266,
	269,268,271,270,273,272,275,274,277,276,279,278,281,280,283,282,
	285,284,287,286,289,288,291,290,293,292,295,294,297,296,299,298,
	301,300,303,302,305,73,307,306,309,308,311,310,314,313,316,315,
	318,317,320,319,322,321,324,323,326,325,328,327,331,330,333,332,
	335,334,337,336,339,338,341,340,343,342,345,344,347,346,349,348,
	351,350,353,352,355,354,357,356,359,358,361,360,363,362,365,364,
	367,366,369,368,371,370,373,372,375,374,378,377,380,379,382,381,
	383,83,384,579,387,386,389,388,392,391,396,395,402,401,405,502,
	409,408,410,573,414,544,417,416,419,418,421,420,424,423,429,428,
	432,431,436,435,438,437,441,440,445,444,447,503,452,453,454,453,
	455,456,457,456,458,459,460,459,462,461,464,463,466,465,468,467,
	470,469,472,471,474,473,476,475,477,398,479,478,481,480,483,482,
	485,484,487,486,489,488,491,490,493,492,495,494,497,498,499,498,
	501,500,505,504,507,506,509,508,511,510,513,512,515,514,517,516,
	519,518,521,520,523,522,525,524,527,526,529,528,531,530,533,532,
	535,534,537,536,539,538,541,540,543,542,547,546,549,548,551,550,
	553,552,555,554,557,556,559,558,561,560,563,562,572,571,578,577,
	583,582,585,584,587,586,589,588,591,590,592,11375,593,11373,595,385,
	596,390,598,393,599,394,601,399,603,400,608,403,611,404,616,407,
	617,406,619,11362,623,412,625,11374,626,413,629,415,637,11364,640,422,
	643,425,648,430,649,580,650,433,651,434,652,581,658,439,837,921,
	881,880,883,882,887,886,891,1021,892,1022,893,1023,940,902,941,904,
	942,905,943,906,945,913,946,914,947,915,948,916,949,917,950,918,
	951,919,952,920,953,921,954,922,955,923,956,924,957,925,958,926,
	959,927,960,928,961,929,962,931,963,931,964,932,965,933,966,934,
	967,935,968,936,969,937,970,938,971,939,972,908,973,910,974,911,
	976,914,977,920,981,934,982,928,983,975,985,984,987,986,989,988,
	991,990,993,992,995,994,997,996,999,998,1001,1000,1003,1002,1005,1004,
	1007,1006,1008,922,1009,929,1010,1017,1013,917,1016,1015,1019,1018,1072,1040,
	1073,1041,1074,1042,1075,1043,1076,1044,1077,1045,1078,1046,1079,1047,1080,1048,
	1081,1049,1082,1050,1083,1051,1084,1052,1085,1053,1086,1054,1087,1055,1088,1056,
	1089,1057,1090,1058,1091,1059,1092,1060,1093,1061,1094,1062,1095,1063,1096,1064,
	1097,1065,1098,1066,1099,1067,1100,1068,1101,1069,1102,1070,1103,1071,1104,1024,
	1105,1025,1106,1026,1107,1027,1108,1028,1109,1029,1110,1030,1111,1031,1112,1032,
	1113,1033,1114,1034,1115,1035,1116,1036,1117,1037,1118,1038,1119,1039,1121,1120,
	1123,1122,1125,1124,1127,1126,1129,1128,1131,1130,1133,1132,1135,1134,1137,1136,
	1139,1138,1141,1140,1143,1142,1145,1144,1147,1146,1149,1148,1151,1150,1153,1152,
	1163,1162,1165,1164,1167,1166,1169,1168,1171,1170,1173,1172,1175,1174,1177,1176,
	1179,1178,1181,1180,1183,1182,1185,1184,1187,1186,1189,1188,1191,1190,1193,1192,
	1195,1194,1197,1196,1199,1198,1201,1200,1203,1202,1205,1204,1207,1206,1209,1208,
	1211,1210,1213,1212,1215,1214,1218,1217,1220,1219,1222,1221,1224,1223,1226,1225,
	1228,1227,1230,1229,1231,1216,1233,1232,1235,1234,1237,1236,1239,1238,1241,1240,
	1243,1242,1245,1244,1247,1246,1249,1248,1251,1250,1253,1252,1255,1254,1257,1256,
	1259,1258,1261,1260,1263,1262,1265,1264,1267,1266,1269,1268,1271,1270,1273,1272,
	1275,1274,1277,1276,1279,1278,1281,1280,1283,1282,1285,1284,1287,1286,1289,1288,
	1291,1290,1293,1292,1295,1294,1297,1296,1299,1298,1301,1300,1303,1302,1305,1304,
	1307,1306,1309,1308,1311,1310,1313,1312,1315,1314,1377,1329,1378,1330,1379,1331,
	1380,1332,1381,1333,1382,1334,1383,1335,1384,1336,1385,1337,1386,1338,1387,1339,
	1388,1340,1389,1341,1390,1342,1391,1343,1392,1344,1393,1345,1394,1346,1395,1347,
	1396,1348,1397,1349,1398,1350,1399,1351,1400,1352,1401,1353,1402,1354,1403,1355,
	1404,1356,1405,1357,1406,1358,1407,1359,1408,1360,1409,1361,1410,1362,1411,1363,
	1412,1364,1413,1365,1414,1366,7545,42877,7549,11363,7681,7680,7683,7682,7685,7684,
	7687,7686,7689,7688,7691,7690,7693,7692,7695,7694,7697,7696,7699,7698,7701,7700,
	7703,7702,7705,7704,7707,7706,7709,7708,7711,7710,7713,7712,7715,7714,7717,7716,
	7719,7718,7721,7720,7723,7722,7725,7724,7727,7726,7729,7728,7731,7730,7733,7732,
	7735,7734,7737,7736,7739,7738,7741,7740,7743,7742,7745,7744,7747,7746,7749,7748,
	7751,7750,7753,7752,7755,7754,7757,7756,7759,7758,7761,7760,7763,7762,7765,7764,
	7767,7766,7769,7768,7771,7770,7773,7772,7775,7774,7777,7776,7779,7778,7781,7780,
	7783,7782,7785,7784,7787,7786,7789,7788,7791,7790,7793,7792,7795,7794,7797,7796,
	7799,7798,7801,7800,7803,7802,7805,7804,7807,7806,7809,7808,7811,7810,7813,7812,
	7815,7814,7817,7816,7819,7818,7821,7820,7823,7822,7825,7824,7827,7826,7829,7828,
	7835,7776,7841,7840,7843,7842,7845,7844,7847,7846,7849,7848,7851,7850,7853,7852,
	7855,7854,7857,7856,7859,7858,7861,7860,7863,7862,7865,7864,7867,7866,7869,7868,
	7871,7870,7873,7872,7875,7874,7877,7876,7879,7878,7881,7880,7883,7882,7885,7884,
	7887,7886,7889,7888,7891,7890,7893,7892,7895,7894,7897,7896,7899,7898,7901,7900,
	7903,7902,7905,7904,7907,7906,7909,7908,7911,7910,7913,7912,7915,7914,7917,7916,
	7919,7918,7921,7920,7923,7922,7925,7924,7927,7926,7929,7928,7931,7930,7933,7932,
	7935,7934,7936,7944,7937,7945,7938,7946,7939,7947,7940,7948,7941,7949,7942,7950,
	7943,7951,7952,7960,7953,7961,7954,7962,7955,7963,7956,7964,7957,7965,7968,7976,
	7969,7977,7970,7978,7971,7979,7972,7980,7973,7981,7974,7982,7975,7983,7984,7992,
	7985,7993,7986,7994,7987,7995,7988,7996,7989,7997,7990,7998,7991,7999,8000,8008,
	8001,8009,8002,8010,8003,8011,8004,8012,8005,8013,8017,8025,8019,8027,8021,8029,
	8023,8031,8032,8040,8033,8041,8034,8042,8035,8043,8036,8044,8037,8045,8038,8046,
	8039,8047,8048,8122,8049,8123,8050,8136,8051,8137,8052,8138,8053,8139,8054,8154,
	8055,8155,8056,8184,8057,8185,8058,8170,8059,8171,8060,8186,8061,8187,8064,8072,
	8065,8073,8066,8074,8067,8075,8068,8076,8069,8077,8070,8078,8071,8079,8080,8088,
	8081,8089,8082,8090,8083,8091,8084,8092,8085,8093,8086,8094,8087,8095,8096,8104,
	8097,8105,8098,8106,8099,8107,8100,8108,8101,8109,8102,8110,8103,8111,8112,8120,
	8113,8121,8115,8124,8126,921,8131,8140,8144,8152,8145,8153,8160,8168,8161,8169,
	8165,8172,8179,8188,8526,8498,8560,8544,8561,8545,8562,8546,8563,8547,8564,8548,
	8565,8549,8566,8550,8567,8551,8568,8552,8569,8553,8570,8554,8571,8555,8572,8556,
	8573,8557,8574,8558,8575,8559,8580,8579,9424,9398,9425,9399,9426,9400,9427,9401,
	9428,9402,9429,9403,9430,9404,9431,9405,9432,9406,9433,9407,9434,9408,9435,9409,
	9436,9410,9437,9411,9438,9412,9439,9413,9440,9414,9441,9415,9442,9416,9443,9417,
	9444,9418,9445,9419,9446,9420,9447,9421,9448,9422,9449,9423,11312,11264,11313,11265,
	11314,11266,11315,11267,11316,11268,11317,11269,11318,11270,11319,11271,11320,11272,11321,11273,
	11322,11274,11323,11275,11324,11276,11325,11277,11326,11278,11327,11279,11328,11280,11329,11281,
	11330,11282,11331,11283,11332,11284,11333,11285,11334,11286,11335,11287,11336,11288,11337,11289,
	11338,11290,11339,11291,11340,11292,11341,11293,11342,11294,11343,11295,11344,11296,11345,11297,
	11346,11298,11347,11299,11348,11300,11349,11301,11350,11302,11351,11303,11352,11304,11353,11305,
	11354,11306,11355,11307,11356,11308,11357,11309,11358,11310,11361,11360,11365,570,11366,574,
	11368,11367,11370,11369,11372,11371,11379,11378,11382,11381,11393,11392,11395,11394,11397,11396,
	11399,11398,11401,11400,11403,11402,11405,11404,11407,11406,11409,11408,11411,11410,11413,11412,
	11415,11414,11417,11416,11419,11418,11421,11420,11423,11422,11425,11424,11427,11426,11429,11428,
	11431,11430,11433,11432,11435,11434,11437,11436,11439,11438,11441,11440,11443,11442,11445,11444,
	11447,11446,11449,11448,11451,11450,11453,11452,11455,11454,11457,11456,11459,11458,11461,11460,
	11463,11462,11465,11464,11467,11466,11469,11468,11471,11470,11473,11472,11475,11474,11477,11476,
	11479,11478,11481,11480,11483,11482,11485,11484,11487,11486,11489,11488,11491,11490,11520,4256,
	11521,4257,11522,4258,11523,4259,11524,4260,11525,4261,11526,4262,11527,4263,11528,4264,
	11529,4265,11530,4266,11531,4267,11532,4268,11533,4269,11534,4270,11535,4271,11536,4272,
	11537,4273,11538,4274,11539,4275,11540,4276,11541,4277,11542,4278,11543,4279,11544,4280,
	11545,4281,11546,4282,11547,4283,11548,4284,11549,4285,11550,4286,11551,4287,11552,4288,
	11553,4289,11554,4290,11555,4291,11556,4292,11557,4293,42561,42560,42563,42562,42565,42564,
	42567,42566,42569,42568,42571,42570,42573,42572,42575,42574,42577,42576,42579,42578,42581,42580,
	42583,42582,42585,42584,42587,42586,42589,42588,42591,42590,42595,42594,42597,42596,42599,42598,
	42601,42600,42603,42602,42605,42604,42625,42624,42627,42626,42629,42628,42631,42630,42633,42632,
	42635,42634,42637,42636,42639,42638,42641,42640,42643,42642,42645,42644,42647,42646,42787,42786,
	42789,42788,42791,42790,42793,42792,42795,42794,42797,42796,42799,42798,42803,42802,42805,42804,
	42807,42806,42809,42808,42811,42810,42813,42812,42815,42814,42817,42816,42819,42818,42821,42820,
	42823,42822,42825,42824,42827,42826,42829,42828,42831,42830,42833,42832,42835,42834,42837,42836,
	42839,42838,42841,42840,42843,42842,42845,42844,42847,42846,42849,42848,42851,42850,42853,42852,
	42855,42854,42857,42856,42859,42858,42861,42860,42863,42862,42874,42873,42876,42875,42879,42878,
	42881,42880,42883,42882,42885,42884,42887,42886,42892,42891,65345,65313,65346,65314,65347,65315,
	65348,65316,65349,65317,65350,65318,65351,65319,65352,65320,65353,65321,65354,65322,65355,65323,
	65356,65324,65357,65325,65358,65326,65359,65327,65360,65328,65361,65329,65362,65330,65363,65331,
	65364,65332,65365,65333,65366,65334,65367,65335,65368,65336,65369,65337,65370,65338 };


#TODO

## Access Modifiers
Allowing use of Private/Public for Type members.

##Documentation
Need some user-friendly documentation for installing and configuration.
Details for each platform, notes on cross-compilation, etc.
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import "config.bmx"
Import "type.bmx"

'toke_type
Const TOKE_EOF:Int=0
Const TOKE_SPACE:Int=1
Const TOKE_IDENT:Int=2
Const TOKE_KEYWORD:Int=3
Const TOKE_INTLIT:Int=4
Const TOKE_FLOATLIT:Int=5
Const TOKE_STRINGLIT:Int=6
Const TOKE_STRINGLITEX:Int=7
Const TOKE_SYMBOL:Int=8
Const TOKE_LINECOMMENT:Int=9
Const TOKE_LONGLIT:Int=10
Const TOKE_NATIVE:Int=11

'***** Tokenizer *****
Type TToker

	Const __keywords$="strict,superstrict,public,private,protected,short,int,float,double,long,string,object,ptr,var,varptr," + ..
		"mod,continue,exit,include,import,module,extern,framework,new,self,super,eachin,true,false," + ..
		"null,not,extends,abstract,select,case,default,const,local,global,field,method,function,type," + ..
		"and,or,shl,shr,sar,end,if,then,else,elseif,endif,while,wend,repeat,until,forever,for,to,step," + ..
		"next,return,alias,rem,endrem,throw,assert,try,catch,nodebug,incbin,endselect,endmethod," + ..
		"endfunction,endtype,endextern,endtry,endwhile,pi,release,defdata,readdata,restoredata,interface," + ..
		"endinterface,implements,size_t,uint,ulong,struct,endstruct,operator"
	Global _keywords:TMap

	Field _path$
	Field _line:Int
	Field _lines:String[]
	Field _source$
	Field _toke$
	Field _tokeLower$
	Field _tokeType:Int
	Field _tokePos:Int
	
	Field _lookingForEndRem:Int
	Field _preprocess:Int
	
	Method Create:TToker( path$,source$, preprocess:Int = False )
		_path=path
		_line=1
		_source=source
		_toke=""
		_tokeType=TOKE_EOF
		_tokePos=0
		_lines = source.split("~n")
		_preprocess = preprocess
		If Not _keywords Then
			initKeywords()
		End If
		Return Self
	End Method
	
	Method initKeywords()
		_keywords = New TMap
		For Local k:String = EachIn __keywords.Split(",")
			_keywords.Insert(k, "")
		Next
	End Method
	
	Method rollback(pos:Int, toketype:Int = -1)
		_tokePos = pos
		If toketype >= 0
			_tokeType = toketype
		End If
	End Method
	
	Method Copy:TToker( toker:TToker )
		_path=toker._path
		_line=toker._line
		_source=toker._source
		_toke=toker._toke
		_tokeLower=toker._tokeLower
		_tokeType=toker._tokeType
		_tokePos=toker._tokePos
		_lines=toker._lines
		_lookingForEndRem=toker._lookingForEndRem
		_preprocess=toker._preprocess
		Return Self
	End Method
	
	Method Path$()
		Return _path
	End Method
	
	Method Line:Int()
		Return _line
	End Method
	
	Method NextToke$()

		If _tokePos=_source.Length
			_toke=""
			_tokeType=TOKE_EOF
			Return _toke
		EndIf
				
		Local char:Int=_source[_tokePos]
		Local str$=Chr( char )
		
		Local start:Int=_tokePos
		_tokePos:+1
		_toke=""

		If str="~n"
			_line:+1
			_tokeType=TOKE_SYMBOL
		Else If IsSpace( char )
			While _tokePos<_source.Length And IsSpace( TCHR() ) And TSTR()<>"~n"
				_tokePos:+1
			Wend
			_tokeType=TOKE_SPACE
		Else If str="_" Or IsAlpha( char )
			_tokeType=TOKE_IDENT
			While _tokePos<_source.Length
				Local char:Int=_source[_tokePos]
				If char<>Asc("_") And Not IsAlpha( char ) And Not IsDigit( char ) Exit
				_tokePos:+1
			Wend
			_toke=_source[start.._tokePos]
			_tokeLower = _toke.ToLower()
			If _keywords.Contains( _tokeLower )
				_tokeType=TOKE_KEYWORD

				If Not _lookingForEndRem And _tokeLower = "rem" Then
					_lookingForEndRem = True
					ParseRemStmt()
				End If
			EndIf
		Else If IsDigit( char ) Or (str="." And IsDigit( TCHR() ))

			_tokeType=TOKE_INTLIT
			If str="." _tokeType=TOKE_FLOATLIT
			While IsDigit( TCHR() )
				_tokePos:+1
			Wend
			If _tokeType=TOKE_INTLIT And TSTR()="." And IsDigit( TCHR(1) )
				_tokeType=TOKE_FLOATLIT
				_tokePos:+2
				While IsDigit( TCHR() )
					_tokePos:+1
				Wend
			EndIf
			Local _tstr:String = TSTR()
			If _tstr="e" Or _tstr="E" Then
				_tokeType=TOKE_FLOATLIT
				_tokePos:+1
				_tstr = TSTR()
				If _tstr="+" Or _tstr="-" _tokePos:+1
				While IsDigit( TCHR() )
					_tokePos:+1
				Wend
			EndIf
			If _tokeType=TOKE_INTLIT And _tokePos-start > 10 ' BaH Long
				_tokeType=TOKE_LONGLIT
			EndIf
		Else If str="%" And IsBinDigit( TCHR() )
			_tokeType=TOKE_INTLIT
			_tokePos:+1
			While IsBinDigit( TCHR() )
				_tokePos:+1
			Wend
		Else If str="$" And IsHexDigit( TCHR() )
			_tokeType=TOKE_INTLIT
			_tokePos:+1
			While IsHexDigit( TCHR() )
				_tokePos:+1
			Wend
		Else If str="~q"
			_tokeType=TOKE_STRINGLIT
			Local _tstr:String = TSTR()
			While _tstr And _tstr<>"~q"
				' Strings can't cross line boundries
				If _tstr="~n" Then
					_tokePos:-1
					Exit
				End If
				_tokePos:+1
				_tstr = TSTR()
			Wend
			If _tokePos<_source.Length _tokePos:+1 Else _tokeType=TOKE_STRINGLITEX
		Else If str="'"
			Local _tstr:String = TSTR()
			If _tstr="!" Then
		
				_tokeType=TOKE_NATIVE
				
				While _tstr 
					If _tstr="~n" Then
						_tokePos:-1
						Exit
					End If
					_tokePos:+1
					_tstr = TSTR()
				Wend
		
			Else
				_tokeType=TOKE_LINECOMMENT
				
				SkipToEOL()
	
				' completely ignore line comments
				If TSTR()="~n" Then
					start = _tokePos
					If _tokePos<_source.Length
						_tokePos:+1
					End If
					_line:+1
					_tokeType=TOKE_SYMBOL
				End If
			End If
		Else If str="." And TSTR()="." Then
			Local pos:Int = _tokePos
			Local isValidTilEOL:Int = True
			_tokePos:+1
			
			Local _tstr:String = TSTR()
			While _tstr And _tstr<>"~n"
				If Not IsSpace(TCHR()) Then
					isValidTilEOL = False
				End If
				_tokePos:+1
				_tstr = TSTR()
			Wend
			
			If Not isValidTilEOL Or _preprocess Then
				_tokePos = pos + 1
				_tokeType=TOKE_SYMBOL
			Else
				start = _tokePos
				_toke = " "
				_tokePos:+1
				_line:+1
				_tokeType=TOKE_SPACE
			End If
		Else

			_tokeType=TOKE_SYMBOL
			For Local i:Int = 0 Until _symbols.length

				Local sym$=_symbols[i]
				If char<>sym[0] Continue

				'do not try to read beyond source length
				If TCHR(sym.length) <= 0 Then Continue

				If _source[_tokePos-1.._tokePos+sym.length-1].ToLower()=sym
					
					' if symbol has alpha, test for trailing alphanumeric char - in which case this is not a symbol
					If IsAlpha(sym[sym.length-1]) Then
						' not at the end of the file?
						If _source.Length >= _tokePos+sym.length Then
							If IsAlpha(TCHR(sym.length-1)) Or IsDigit(TCHR(sym.length-1)) Then
								Exit
							End If
						End If
					End If
					
					_tokePos:+sym.length-1
					
					Exit
				EndIf
			Next
		EndIf

		If Not _toke _toke=_source[start.._tokePos]

		Return _toke
	End Method
	
	Method Toke$()
		Return _toke
	End Method
	
	Method TokeType:Int()
		Return _tokeType
	End Method
	
	Method SkipSpace:Int()
		Local count:Int
		While _tokeType=TOKE_SPACE
			NextToke
			count :+ 1
		Wend
		Return count
	End Method

	Method ParseRemStmt()

		NextToke()

		While _toke
			SkipEols()

			 	Local line:String = _lines[_line - 1].Trim().toLower()
				If line.startswith("endrem") Then
					Exit
				End If

				If CParse( "end" )
					CParse "rem"
					Exit
				End If

				If line.startswith("end rem") Then
					Exit
				End If

				SkipToEOL()
				
			NextToke

		Wend
		
		SkipToEOL()

		NextToke

		_lookingForEndRem = False
	End Method

	Method CParse:Int( toke$ )
		If _tokeLower<>toke
			Return False
		EndIf
		NextToke
		Return True
	End Method

	Method SkipEols()
		While CParse( "~n" ) Or CParse(";")
		Wend
	End Method
	
	Method SkipToEOL()
		While TSTR() And TSTR()<>"~n"
			_tokePos:+1
		Wend
	End Method

'Private

	Method TCHR:Int( i:Int=0 )
		If _lastIndex <> _tokePos+i Then
			_lastIndex = _tokePos+i
			If _lastIndex < _source.Length Then
				_lastTCHR = _source[_lastIndex]
				_lastTSTR = Chr( _lastTCHR )
			Else
				_lastTCHR = 0
				_lastTSTR = ""
			End If
		End If
		Return _lastTCHR
	End Method
	
	Field _lastIndex:Int = -1
	Field _lastTCHR:Int
	
	Method TSTR$( i:Int=0 )
		If _lastIndex <> _tokePos+i Then
			_lastIndex = _tokePos+i
			If _lastIndex < _source.Length Then
				_lastTCHR = _source[_lastIndex]
				_lastTSTR = Chr( _lastTCHR )
			Else
				_lastTCHR = 0
				_lastTSTR = ""
			End If
		End If
		Return _lastTSTR
	End Method
	
	Field _lastTSTR:String
	
End Type
/* Copyright (c) 2014-2016 Bruce A Henderson

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

     1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.

     2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.

     3. This notice may not be removed or altered from any source
     distribution.
*/

char * transChars[65535] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z",0,0,0,0,0,0,"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z",0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"A","A","A","A","A","A","AE","C","E","E","E","E","I","I","I","I","D","N","O","O","O","O","O",0,"O","U","U","U","U","Y","TH","ss","a","a","a","a","a","a","ae","c","e","e","e","e","i","i","i","i","d","n","o","o","o","o","o",0,"o","u","u","u","u","y","th","y","A","a",
"A","a","A","a","C","c","C","c","C","c","C","c","D","d","D","d","E","e","E","e","E","e","E","e","E","e","G","g","G","g","G","g","G","g","H","h","H","h","I","i","I","i","I","i","I","i","I","i","IJ","ij","J","j","K","k","q","L","l","L","l","L","l","L","l","L","l","N","n","N","n","N","n",0,"N","n","O","o","O","o","O","o","OE","oe","R","r","R","r","R","r","S","s","S","s","S","s","S","s","T","t","T","t","T","t","U","u","U","u","U","u","U","u","U","u","U","u","W","w","Y","y","Y","Z","z","Z","z","Z","z","s","b","B","B",
"b",0,0,0,"C","c","D","D","D","d",0,0,0,"E","F","f","G",0,"hv","I","I","K","k","l",0,0,"N","n",0,"O","o","OI","oi","P","p",0,0,0,0,0,"t","T","t","T","U","u",0,"V","Y","y","Z","z",0,0,0,0,0,0,0,0,0,0,0,0,0,"DZ","Dz","dz","LJ","Lj","lj","NJ","Nj","nj","A","a","I","i","O","o","U","u","U","u","U","u","U","u","U","u",0,"A","a","A","a","AE","ae","G","g","G","g","K","k","O","o","O","o",0,0,"j","DZ","Dz","dz","G","g",0,0,"N","n","A","a","AE","ae","O","o","A","a","A","a",
"E","e","E","e","I","i","I","i","O","o","O","o","R","r","R","r","U","u","U","u","S","s","T","t",0,0,"H","h",0,"d",0,0,"Z","z","A","a","E","e","O","o","O","o","O","o","O","o","Y","y","l","n","t","j","db","qp","A","C","c","L","T","s","z",0,0,"B","U",0,"E","e","J","j",0,0,"R","r","Y","y",0,0,0,"b",0,"c","d","d",0,0,0,"e",0,0,0,"j","g","g","G",0,0,0,"h","h","i",0,"I","l","l","l",0,0,0,"m","n","n","N",0,"OE",0,0,0,0,0,"r","r","r",0,"R",0,"s",0,0,
0,0,0,"t","u",0,"v",0,0,0,"Y","z","z",0,0,0,0,0,0,0,"B",0,"G","H","j",0,"L","q",0,0,"dz",0,"dz","ts",0,0,0,"ls","lz",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"i",0,0,0,0,0,0,0,0,0,0,0,"A",
0,"E","E","I",0,"O",0,"Y","O","i","A","B","G","D","E","Z","E","TH","I","K","L","M","N","X","O","P","R",0,"S","T","Y","PH","CH","PS","O","I","Y","a","e","e","i","y","a","b","g","d","e","z","e","th","i","k","l","m","n","x","o","p","r","s","s","t","y","ph","ch","ps","o","i","y","o","y","o",0,"b","th","Y","Y","Y","ph","p",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"k","r","s","j","TH","e",0,"S","s","S","S","s",0,0,0,0,"E","E","D","G","E","Z","I","I",
"J","L","N","C","K","I","U","D","A","B","V","G","D","E","Z","Z","I","J","K","L","M","N","O","P","R","S","T","U","F","H","C","C","S","S",0,"Y",0,"E","U","A","a","b","v","g","d","e","z","z","i","j","k","l","m","n","o","p","r","s","t","u","f","h","c","c","s","s",0,"y",0,"e","u","a","e","e","d","g","e","z","i","i","j","l","n","c","k","i","u","d",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,"G","g","G","g","G","g",0,0,"Z","z",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"Z","z",0,0,0,0,0,0,0,0,0,0,0,0,0,"A","a","A","a","AE","ae","E","e",0,0,0,0,"Z","z","Z","z",0,0,"I","i","I","i","O","o",0,0,0,0,"E","e","U","u","U","u","U","u","C","c",0,0,"Y","y",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"A","B","G","D","E","Z","E",0,0,"Z","I","L","X","C","K","H","J","G","C","M","Y","N","S","O",0,"P","J","R","S","V","T","R",0,"W",0,0,"O","F",0,0,0,0,0,0,0,0,0,0,"a","b","g","d","e","z","e",0,0,"z","i","l","x","c","k","h","j","g","c","m","y","n","s","o",0,"p","j","r","s","v","t","r",0,"w",0,0,"o","f","ev",0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"e","e","a","o","i","e","e","a","a","o",0,"u",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"b","g","d","h","w","z","h","t","y","k","k","l","m","m","n","n","s",0,"p","p","z","z","q","r","s","t",0,0,0,0,0,"ww","wy","yy",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"a","a","w","a","y","a","b","t","t","th","j","h","kh","d","dh","r","z","s","sh","s","d","t","z",0,"gh",0,0,0,0,0,0,"f","q","k","l","m","n","h","w","y","y",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"p",0,0,0,0,0,0,0,"ch",0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,"zh",0,0,0,0,0,0,0,0,0,0,0,"v",0,0,0,0,"k",0,0,0,"ng",0,"g",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"v","y",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,"b","g","g","d","dr","h","w","z","h","t","t","y","yh","k","l","m","n","s","s",0,"p","p","s","q","r","sh","t",0,0,0,"a","a","a","o","o","a","e","e","e","e","i","i","u","u","u","o",0,0,"i",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"h","s","n","r","b","l","k",0,"v","m","f","d","t","l","g",
"n","s","d","z","t","y","p","j","c","tt","h","kh","dh",0,"s","s","d","t",0,0,"g","q",0,"a","a","i","i","u","u","e","e","o","o","",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","m","h","","a","a","i","i","u","u","r","l","e","e","e","ai","o",
"o","o","au","ka","kha","ga","gha","na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na","na","pa","pha","ba","bha","ma","ya","ra","ra","la","la","la","va","sa","sa","sa","ha",0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,"","",0,0,0,"qa","kha","ga","za","ra","rha","fa","ya","r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","m","h",0,"a","a","i","i","u","u","r","l",0,0,"e","ai",0,0,
"o","au","ka","kha","ga","gha","na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra",0,"la",0,0,0,"sa","sa","sa","ha",0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"","t",0,0,0,0,0,0,0,0,"",0,0,0,0,"ra","rha",0,"ya","r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9","ra","ra","","","","","","","","","",0,0,0,0,0,0,"m","m",0,0,"a","a","i","i","u","u",0,0,0,0,"e","ai",0,0,"o",
"au","ka","kha","ga","gha","na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra",0,"la","la",0,"va","sa",0,"sa","ha",0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,0,0,0,"kha","ga","za","ra",0,"fa",0,0,0,0,0,0,0,"0","1","2","3","4","5","6","7","8","9","","","","","",0,0,0,0,0,0,0,0,0,0,0,0,"m","m","h",0,"a","a","i","i","u","u","r","l","e",0,"e","ai","o",0,"o","au",
"ka","kha","ga","gha","na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra",0,"la","la",0,"va","sa","sa","sa","ha",0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","m","h",0,"a","a","i","i","u","u","r","l",0,0,"e","ai",0,0,"o","au","ka",
"kha","ga","gha","na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra",0,"la","la",0,"va","sa","sa","sa","ha",0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,"","",0,0,0,0,"ra","rha",0,"ya","r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9","","wa",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","h",0,"a","a","i","i","u","u",0,0,0,"e","e","ai",0,"o","o","au","ka",0,
0,0,"na","ca",0,"ja",0,"na","ta",0,0,0,"na","ta",0,0,0,"na","na","pa",0,0,0,"ma","ya","ra","ra","la","la","la","va","sa","sa","sa","ha",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,"0","1","2","3","4","5","6","7","8","9","10","100","1000",0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","m","h",0,"a","a","i","i","u","u","r","l",0,"e","e","ai",0,"o","o","au","ka","kha","ga",
"gha","na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra","ra","la","la",0,"va","sa","sa","sa","ha",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,"","",0,0,0,0,0,0,0,0,0,"r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","h",0,"a","a","i","i","u","u","r","l",0,"e","e","ai",0,"o","o","au","ka","kha","ga","gha",
"na","ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra","ra","la","la",0,"va","sa","sa","sa","ha",0,0,"",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,"","",0,0,0,0,0,0,0,"la",0,"r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"m","h",0,"a","a","i","i","u","u","r","l",0,"e","e","ai",0,"o","o","au","ka","kha","ga","gha","na",
"ca","cha","ja","jha","na","ta","tha","da","dha","na","ta","tha","da","dha","na",0,"pa","pha","ba","bha","ma","ya","ra","ra","la","la","la","va","sa","sa","sa","ha",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,0,"",0,0,0,0,0,0,0,0,"r","l",0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"k","kh","kh","kh",0,"kh","ng","c","ch","ch","s","ch","y","d","t","th","th",0,"n","d","t","th","th","th","n","b","p",
"ph","f","ph","f","ph","m","y","r","v","l","l","w","s",0,"s","h","l","x","h",0,"a","a","a","a","i","i","u","u","u","u",0,0,0,0,0,0,"e","ae","o","i","i","i",0,0,0,0,0,0,0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"a","b","g","d","e","v","z","t","i",0,"l","m","n","o",0,"zh","r","s",0,"u","p","k","gh",0,"sh","ch","ts","dz",0,0,"kh","j","h",0,0,"ui","q",0,0,0,0,0,0,0,0,0,0,0,"g","kk","n","d","tt","l","m","b","pp","s","ss","","j","jj","ch","k","t","p","h",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"a","ae","ya","yae","eo","e","yeo","ye","o","wa","wae","oe","yo","u","wo","we","wi","yu","eu","ui","i",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,"g","kk","gs","n","nj","nh","d","l","lg","lm","lb","ls","lt","lp","lh","m","b","bs","s","ss","ng","j","ch","k","t","p","h",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"A","AE",0,"B","C","D","D","E",0,0,"J","K","L","M",0,"O",0,0,0,0,0,0,0,0,"P",0,0,"T","U",0,0,0,"V","W","Z",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"ue","b","d","f","m","n","p","r","r","s","t","z",0,0,0,"th","I",0,"p","U",0,"b","d","f","g","k","l","m","n","p","r","s",0,"v","x","z","a",0,"d","e","e",0,0,"i",0,0,"u",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"A","a","B","b","B","b","B","b","C","c","D","d","D","d","D","d","D","d","D","d","E","e","E","e","E","e","E","e","E","e","F","f","G","g","H","h","H","h","H","h","H","h","H","h","I","i","I","i","K","k","K","k","K","k","L","l","L","l","L","l",
"L","l","M","m","M","m","M","m","N","n","N","n","N","n","N","n","O","o","O","o","O","o","O","o","P","p","P","p","R","r","R","r","R","r","R","r","S","s","S","s","S","s","S","s","S","s","T","t","T","t","T","t","T","t","U","u","U","u","U","u","U","u","U","u","V","v","V","v","W","w","W","w","W","w","W","w","W","w","X","x","X","x","Y","y","Z","z","Z","z","Z","z","h","t","w","y","a","s","s","s","SS",0,"A","a","A","a","A","a","A","a","A","a","A","a","A","a","A","a","A","a","A","a","A","a","A","a","E","e","E","e","E",
"e","E","e","E","e","E","e","E","e","E","e","I","i","I","i","O","o","O","o","O","o","O","o","O","o","O","o","O","o","O","o","O","o","O","o","O","o","O","o","U","u","U","u","U","u","U","u","U","u","U","u","U","u","Y","y","Y","y","Y","y","Y","y","LL","ll","V","v","Y","y","a","ha","a","ha","a","ha","a","ha","A","HA","A","HA","A","HA","A","HA","e","he","e","he","e","he",0,0,"E","HE","E","HE","E","HE",0,0,"e","he","e","he","e","he","e","he","E","HE","E","HE","E","HE","E","HE","i","hi","i","hi","i","hi","i","hi","I","HI","I","HI","I","HI",
"I","HI","o","ho","o","ho","o","ho",0,0,"O","HO","O","HO","O","HO",0,0,"y","hy","y","hy","y","hy","y","hy",0,"HY",0,"HY",0,"HY",0,"HY","o","ho","o","ho","o","ho","o","ho","O","HO","O","HO","O","HO","O","HO","a","a","e","e","e","e","i","i","o","o","y","y","o","o",0,0,"ai","hai","ai","hai","ai","hai","ai","hai","AI","HAI","AI","HAI","AI","HAI","AI","HAI","ei","hei","ei","hei","ei","hei","ei","hei","EI","HEI","EI","HEI","EI","HEI","EI","HEI","oi","hoi","oi","hoi","oi","hoi","oi","hoi","OI","HOI","OI","HOI","OI","HOI","OI","HOI","a","a","ai","ai","ai",0,"a","ai","A","A","A","A","AI",0,"i",
0,0,0,"ei","ei","ei",0,"e","ei","E","E","E","E","EI",0,0,0,"i","i","i","i",0,0,"i","i","I","I","I","I",0,0,0,0,"y","y","y","y","r","rh","y","y","Y","Y","Y","Y","RH",0,0,0,0,0,"oi","oi","oi",0,"o","oi","O","O","O","O","OI",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"CE",0,"Cr",0,0,0,0,"Pts",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"Rs","TL",0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"C",0,0,0,0,0,0,0,"g","H","x","H","h",0,"I","I","L","l",0,"N","No",0,0,"P","Q","R","R","R","Rx",0,0,"TEL",0,0,"Z",0,"O",0,"Z",0,"K","A","B","C",0,"e","E","F",0,"M","o",0,0,0,0,"i",0,"FAX",0,0,0,0,0,0,
0,0,0,"D","d","e","i","j",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","L","C","D","M","i","ii","iii","iv","v","vi","vii","viii","ix","x","xi","xii","l","c","d","m",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"you","chang","ya","yin","ya","ren","jiong",0,"dao","dao","bo","jie","xiao","xiao","wu","wang","wang","wu","si","yao","ji","ji","xin","xin","shou","sui",0,"ri","ri","yue","dai","mu","min","shui","shui","biao","zhao","zhao","qiang","niu","quan",0,0,"mu","shi","shi","shi","si","si","gang","wang",0,"wang",0,"ren","ren",0,0,"yu","yu","rou","ju","cao","cao","cao","hu","yi","xi","xi","jian",0,0,"yan","bei",0,"che","chuo","chuo","chuo","fu","jin","chang","chang","zhang","men",0,"fu","yu","qing","wei","ye","feng","fei",
"shi",0,"shi","shi",0,"ma","gu","gui","yu","niao","lu","mai","huang","mian","qi","qi","chi","chi","long","long","gui","gui","gui",0,0,0,0,0,0,0,0,0,0,0,0,"yi","gun","zhu","pie","yi","jue","er","tou","ren","er","ru","ba","jiong","mi","bing","ji","qian","dao","li","bao","bi","fang","xi","shi","bo","jie","chang","si","you","kou","wei","tu","shi","zhi","sui","xi","da","nu","zi","mian","cun","xiao","you","shi","che","shan","chuan","gong","ji","jin","gan","yao","guang","yin","gong","yi","gong","ji","shan","chi","xin","ge","hu","shou","zhi","pu","wen","dou","jin","fang","wu","ri","yue","yue","mu","qian","zhi","dai","shu","wu","bi","mao","shi","qi","shui","huo","zhao","fu","yao","pan","pian","ya","niu","quan",
"xuan","yu","gua","wa","gan","sheng","yong","tian","pi","ne","bo","bai","pi","min","mu","mao","shi","shi","shi","rou","he","xue","li","zhu","mi","mi","fou","wang","yang","yu","lao","er","lei","er","yu","rou","chen","zi","zhi","jiu","she","chuan","zhou","gen","se","cao","hu","chong","xue","xing","yi","ya","jian","jiao","yan","gu","dou","shi","zhi","bei","chi","zou","zu","shen","che","xin","chen","chuo","yi","you","bian","li","jin","zhang","men","fu","li","zhui","yu","qing","fei","mian","ge","wei","jiu","yin","ye","feng","fei","shi","shou","xiang","ma","gu","gao","biao","dou","chang","ge","gui","yu","niao","lu","lu","mai","ma","huang","shu","hei","zhi","mian","ding","gu","shu","bi","qi","chi","long","gui","yue",0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"ling",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"shi","nian","sa",0,0,0,0,0,0,0,"a",0,"i",0,"u",0,"e",0,"o","ka","ga","ki","gi","ku","gu","ke","ge","ko","go","sa","za","shi","ji","su","zu","se","ze","so","zo","ta",
"da","chi","dji",0,"tsu","dzu","te","de","to","do","na","ni","nu","ne","no","ha","ba","pa","hi","bi","pi","fu","bu","pu","he","be","pe","ho","bo","po","ma","mi","mu","me","mo",0,"ya",0,"yu",0,"yo","ra","ri","ru","re","ro",0,"wa","wi","we","wo","n","vu",0,0,0,0,0,0,0,0,"","",0,0,0,"a",0,"i",0,"u",0,"e",0,"o","ka","ga","ki","gi","ku","gu","ke","ge","ko","go","sa","za","shi","ji","su","zu","se","ze","so","zo","ta","da","chi","dji",0,"tsu","dzu","te","de","to","do","na","ni","nu","ne","no","ha","ba","pa","hi","bi","pi","fu","bu","pu","he","be","pe","ho","bo","po","ma","mi","mu",
"me","mo",0,"ya",0,"yu",0,"yo","ra","ri","ru","re","ro",0,"wa","wi","we","wo","n","vu",0,0,"va","vi","ve","vo",0,0,"","",0,0,0,0,0,0,"b","p","m1","f","d","t","n1","l","g","k","h","j","q","x","zhi1","chi1","shi1","ri1","zi1","ci1","si1","a1","o1","e1","eh1","ai1","ei1","ao1","ou1","an1","en1","ang1","eng1","er1","yi1","wu1","yu1",0,0,0,0,0,0,0,"g","kk","gs","n","nj","nh","d","tt","l","lg","lm","lb","ls","lt","lp",0,"m","b","pp",0,"s","ss","","j","jj","ch","k","t","p","h","a","ae","ya","yae","eo","e","yeo","ye","o","wa","wae","oe","yo","u","wo","we","wi","yu","eu",
"ui","i",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"g","n","d","l",
"m","b","s","","j","ch","k","t","p","h","ga","na","da","la","ma","ba","sa","a","ja","cha","ka","ta","pa","ha",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,"hPa","da","AU","bar","oV","pc","dm",0,0,"IU",0,0,0,0,0,"pA","nA",0,"mA","kA","KB","MB","GB","cal","kcal","pF","nF",0,0,"mg","kg","Hz","kHz","MHz","GHz","THz",0,0,0,0,"fm","nm",0,"mm","cm","km",0,0,0,0,0,0,0,0,0,0,"Pa","kPa","MPa","GPa","rad",0,0,"ps","ns",0,"ms","pV","nV",0,"mV","kV","MV","pW","nW",0,"mW","kW","MW",0,0,0,"Bq","cc","cd",0,0,"dB","Gy","ha","HP","in","KK","KM","kt","lm","ln","log","lx","mb","mil","mol","pH",0,"PPM","PR","sr","Sv","Wb",0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"qiu","tian",0,0,"kua","wu","yin",0,0,0,0,0,"yi",0,0,0,0,0,0,0,0,0,"xie",0,0,0,0,0,"chou",0,0,0,0,"nuo",0,0,"dan",0,0,0,"xu","xing",0,"xiong","liu","lin","xiang","yong","xin","zhen","dai","wu","pan",0,0,"ma","qian","yi","yin","nei","cheng","feng",0,0,0,"zhuo","fang","ao","wu","zuo",0,"zhou","dong","su","yi","qiong","kuang","lei","nao","zhu","shu",0,0,0,"xu",0,0,"shen","jie","die","nuo","su","yi","long","ying","beng",0,0,0,"lan","miao","yi","li","ji",
"yu","luo","chai",0,0,0,"hun","xu","hui","rao",0,"zhou",0,"han","xi","tai","yao","hui","jun","ma","lue","tang","yao","zhao","zhai","yu","zhuo","er","ran","qi","chi","wu","han","tang","se",0,"qiong","lei","sa",0,0,"kui","pu","ta","shu","yang","ou","tai",0,"mian","yin","diao","yu","mie","jun","niao","xie","you",0,0,"che","feng","lei","li",0,"luo",0,"ji",0,0,0,0,"quan",0,"cai","liang","gu","mao",0,"gua","sui",0,0,"mao","man","quan","shi","li",0,"wang","kou","du","zhen","ting",0,0,"bing","huo","dong","gong","cheng",0,"qin","jiong","lu","xing",0,"nan","xie",0,"bi","jie","su",0,"gong",0,"you","xing","qia","pi","dian","fu","luo","qia","qia","tang","bai","gan","ci",
"xuan","lang",0,0,"she",0,"li","hua","tou","pian","di","ruan","e","qie","yi","zhuo","rui","jian",0,"chi","chong","xi",0,"lue","deng","lin","jue","su","xiao","zan",0,0,"zhu","zhan","jian","zou","chua","xie","li",0,"chi","xi","jian",0,"ji",0,"fei","chu","beng","jie",0,"ba","liang","kuai",0,"xia","bie","jue","lei","xin","bai","yang","lu","bei","e","lu",0,0,"che","nuo","xuan","heng","yu",0,"gui","yi","xuan","gong","lou","ti","le","shi",0,"sun","yao","xian","zou",0,"que","yin","xi","zhi","jia","hu","la","yi","ke","fu","qin","ai",0,"ke","chu","xie","chu","wei",0,0,"huan","su","you",0,"jun","zhao","xu","shi",0,"shua","kui","shuang","he","gai","yan","qiu","shen","hua","xi","fan","pang",
"dan","fang","gong","ao","fu","ne","xue","you","hua",0,"chen","guo","n","hua","li","fa","xiao","pou",0,"si",0,0,"le","lin","yi","hou",0,"xu","qu","er",0,0,"xun",0,0,0,0,"nie","wei","xie","ti","hong","tun","nie","nie","yin","zhen",0,0,0,0,0,"wai","shou","nuo","ye","qi","tou","han","jun","dong","hun","lu","ju","huo","ling",0,"tian","lun",0,0,0,0,0,0,"ge","yan","shi","xue","pen","chun","niu","duo","ze","e","xie","you","e","sheng","wen","ku","hu","ge","xia","man","lue","ji","hou","zhi",0,0,"wai",0,"bai","ai","zhui","qian","gou","dan","bei","bo","chu","li","xiao","xiu",0,0,0,0,0,"hong","ti","cu","kuo","lao","zhi","xie","xi",0,
"qie","zha","xi",0,0,"cong","ji","huo","ta","yan","xu","po","sai",0,0,0,"guo","ye","xiang","xue","he","zuo","yi","ci",0,"leng","xian","tai","rong","yi","zhi","xi","xian","ju","ji","han",0,"pao","li",0,"lan","sai","han","yan","qu",0,"yan","han","kan","chi","nie","huo",0,"bi","xia","weng","xuan","wan","you","qin","xu","nie","bi","hao","jing","ao","ao",0,0,"zhen","tan","ju",0,"zuo","bu","jie","ai","zang","ci","fa",0,0,0,0,"nie","liu","mei","dui","bang","bi","bao",0,"chu","xia","tian","chang",0,0,"duo","wei","fu","duo","yu","ye","kui","wei","kuai",0,"wei","yao","long","xing","bu","chi","xie","nie","lang","yi","zong","man","zhang","xia","gun","xie",0,"ji","liao","yi","ji",
"yin",0,"da","yi","xie","hao","yong","kan","chan","tai","tang","zhi","bao","meng","kui","chan","lei",0,"xi",0,"xi","qiao","nang","yun",0,"long","fu","zong",0,"gu","kai","diao","hua","kui",0,"gao","tao",0,"shan","lai","nie","fu","gao","qie","ban","jia","kong","xi","yu","zhui","shen","chuo","xiao","ji","nu","xiao","yi","yu","yi","yan","shen","ran","hao","sa","jun","you",0,"xin","pei","qiu","chan",0,"bu","dong","si","er",0,"mao","yun","ji",0,"qiao","xiong","pao","chu","peng","nuo","jie","yi","er","duo",0,0,0,"duo",0,0,"qie","lu","qiu","sou","can","dou","xi","feng","yi","suo","qie","po","xin","tong","xin","you","bei","long",0,0,0,0,"yun","li","ta","lan","man","qiang","zhou","yan","xi","lu",
"xi","sao","fan",0,"wei","fa","yi","nao","cheng","tan","ji","shu","pian","an","kua","cha",0,"xian","zhi",0,0,"feng","lian","xun","xu","mi","hui","mu","yong","zhan","yi","nou","tang","xi","yun","shu","fu","yi","da",0,"lian","cao","can","ju","lu","su","nen","ao","an","qian",0,"cui","cong",0,"ran","nian","mai","xin","yue","nai","ao","shen","ma",0,0,"lan","xi","yue","zhi","weng","huai","meng","niao","wan","mi","nie","qu","zan","lian","zhi","zi","hai","xu","hao","xuan","zhi","mian","chun","gou",0,"chun","luan","zhu","shou","liao","jiu","xie","ding","jie","rong","mang",0,"ke","yao","ning","yi","lang","yong","yin","yan","su",0,"lin","ya","mao","ming","zui","yu","yi","gou","mi","jun","wen",0,"kang","dian","long",0,"xing",
"cui","qiao","mian","meng","qin",0,"wan","de","ai",0,"bian","nou","lian","jin","yu","chui","zuo","bo","hui","yao","tui","ji","an","luo","ji","wei","bo","za","xu","nian","yun",0,"ba","zhe","ju","wei","xie","qi","yi","xie","ci","qiu","du","niao","qi","ji","tui",0,"song","dian","lao","zhan",0,0,"yin","cen","ji","hui","zi","lan","nao","ju","qin","dai",0,"jie","xu","cong","yong","dou","chi",0,"min","huang","sui","ke","zu","hao","cheng","xue","ni","chi","lian","an","mu","si","xiang","yang","hua","cuo","qiu","lao","fu","dui","mang","lang","tuo","han","mang","bo","qun","qi","han",0,"long",0,"tiao","ze","qi","zan","mi","pei","zhan","xiang","gang",0,"qi",0,"lu",0,"yun","e","duan","min","wei","quan","sou","min","tu",
0,"ming","yao","jue","li","kuai","gang","yuan","da",0,"lao","lou","qian","ao","biao","yong","mang","dao",0,"ao",0,"xi","fu","dan","jiu","run","tong","qu","e","qi","ji","ji","hua","jiao","zui","biao","meng","bai","wei","yi","ao","yu","hao","dui","wo","ni","cuan",0,"li","lu","niao","huai","li",0,"lu","feng","mi","yu",0,"ju",0,0,"zhan","peng","yi",0,"ji","bi",0,"ren","huang","fan","ge","ku","jie","sha",0,"si","tong","yuan","zi","bi","kua","li","huang","xun","nuo",0,"zhe","wen","xian","qia","ye","mao",0,0,"shu",0,"qiao","zhun","kun","wu","ying","chuang","ti","lian","bi","gou","mang","xie","feng","lou","zao","zheng","chu","man","long",0,"yin","pin","zheng","jian","luan","nie","yi",0,"ji","ji","zhai",
"yu","jiu","huan","zhi","la","ling","zhi","ben","zha","ju","dan","liao","yi","zhao","xian","chi","ci","chi","yan","lang","dou","long","chan",0,"tui","cha","ai","chi",0,"ying","zhe","tou",0,"tui","cha","yao","zong",0,"pan","qiao","lian","qin","lu","yan","kang","su","yi","chan","jiong","jiang",0,"jing",0,"dong",0,"juan","han","di",0,0,"hong",0,"chi","diao","bi",0,"xun","lu",0,"xie","bi",0,"bi",0,"xian","rui","bie","er","juan",0,"zhen","bei","e","yu","qu","zan","mi","yi","si",0,0,0,"shan","tai","mu","jing","bian","rong","ceng","can","ding",0,0,0,0,"di","tong","ta","xing","song","duo","xi","tao",0,"ti","shan","jian","zhi","wei","yin",0,0,"huan","zhong","qi","zong",0,"xie","xie",
"ze","wei",0,0,"ta","zhan","ning",0,0,0,"yi","ren","shu","cha","zhuo",0,"mian","ji","fang","pei","ai","fan","ao","qin","qia","xiao","fen","gan","qiao","ge","tong","chan","you","gao","ben","fu","chu","zhu",0,"zhou",0,"hang","nin","jue","chong","cha","kong","lie","li","yu",0,"yu","hai","li","hou","gong","ke","yuan","de","hui",0,"guang","jiong","zuo","fu","qie","bei","che","ci","mang","han","xi","qiu","huang",0,0,"chou","san","yan","zhi","de","te","men","ling","shou","tui","can","die","che","peng","yi","ju","ji","lai","tian","yuan",0,"cai","qi","yu","lian","cong",0,0,0,"yu","ji","wei","mi","sui","xie","xu","chi","qiu","hui",0,"yu","qie","shun","shui","duo","lou",0,"pang","tai","zhou","yin","sao","fei",
"chen","yuan","yi","hun","se","ye","min","fen","he",0,"yin","ce","ni","ao","feng","lian","chang","chan","ma","die","hu","lu",0,"yi","hua","zha","hu","e","huo","sun","ni","xian","li","xian","yan","long","men","jin","ji",0,"bian","yu","huo","miao","chou","mai",0,"le","jie","wei","yi","xuan","xi","can","lan","yin","xie","za","luo","ling","qian","huo","jian","wo",0,0,"ge","zhu","die","yong","ji","yang","ru","xi","shuang","yu","yi","qian","ji","qu","tian","shou","qian","mu","jin","mao","yin","gai","po","xuan","mao","fang","ya","gang","song","hui","yu","gua","guai","liu","e","zi","zi","bi","wa",0,"lie",0,0,"kuai",0,"hai","yin","zhu","chong","xian","xuan",0,"qiu","pei","gui","er","gong","qiong","hu","lao","li","chen","san",
"zhuo","wo","pou","keng","tun","peng","te","ta","zhuo","biao","gu","hu",0,"bing","zhi","dong","dui","zhou","nei","lin","po","ji","min","wei","che","gou","bang","ru","tan","bu","zong","kui","lao","han","ying","zhi","jie","xing","xie","xun","shan","qian","xie","su","hai","mi","hun","pi",0,"hui","na","song","ben","chou","jie","huang","lan",0,"hu","dou","huo","gun","yao","ce","gui","jian","jian","dao","jin","ma","hui","mian","can","lue","pi","yang","ju","ju","que",0,"qian","shai",0,"jiu","huo","yun","da","xuan","xiao","fei","ce","ye",0,"den",0,"qin","hui","tun",0,"qiang","xi","ni","sai","meng","tuan","lan","hao","ci","zhai","ao","luo","mie",0,"fu",0,"xie","bo","hui","qing","xie",0,0,"bo","qian","po","jiao","jue","kun","song",
"ju","e","nie","qian","die","die",0,"qi","zhi","qi","zhui","ku","yu","qin","ku","he","fu",0,"di","xian","gui","he","qun","han","tong","bo","shan","bi","lu","ye","ni","chuai","san","diao","lu","tou","lian","ke","san","zhen","chuai","lian","mao",0,"qian","kai","shao","xiao","bi","zha","yin","xi","shan","su","sa","rui","chuo","lu","ling","cha",0,"huan",0,0,"jia","ban","hu","dou",0,"lou","ju","juan","ke","suo","luo","zhe","ding","duan","zhu","yan","pang","cha",0,0,0,0,"yi",0,0,"you","hui","yao","yao","zhi","gong","qi","gen",0,0,"hou","mi","fu","hu","guang","tan","di",0,"yan",0,0,"qu",0,"chang","ming","tao","bao","an",0,0,"xian",0,0,0,"mao","lang","nan","bei","chen",0,
"fei","zhou","ji","jie","shu",0,"kun","die","lu",0,0,0,0,"yu","tai","chan","man","min","huan","wen","nuan","huan","hou","jing","bo","xian","li","jin",0,"mang","piao","hao","yang",0,"xian","su","wei","che","xi","jin","ceng","he","fen","shai","ling",0,"dui","qi","pu","yue","bo",0,"hui","die","yan","ju","jiao","nan","lie","yu","ti","tian","wu","hong","xiao","hao",0,"tiao","zheng",0,"huang","fu",0,0,"tun",0,"reng","jiao",0,"xin",0,0,"yuan","jue","hua",0,"bang","mou",0,"gang","wei",0,"mei","si","bian","lu","qu",0,0,"ge","zhe","lu","pai","rong","qiu","lie","gong","xian","xi","xin",0,"niao",0,0,0,"xie","lie","fu","cuo","zhuo","ba","zuo","zhe","zui","he","ji",0,"jian",0,
0,0,"tu","xian","yan","tang","ta","di","jue","ang","han","xiao","ju","wei","bang","zhui","nie","tian","nai",0,0,"you","mian",0,0,"nai","sheng","cha","yan","gen","chong","ruan","jia","qin","mao","e","li","chi","zang","he","jie","nian",0,"guan","hou","gai",0,"ben","suo","wu","ji","xi","qiong","he","weng","xian","jie","hun","pi","shen","chou","zhen",0,"zhan","shuo","ji","song","zhi","ben",0,0,0,"lang","bi","xuan","pei","dai",0,"zhi","pi","chan","bi","su","huo","hen","jiong","chuan","jiang","nen","gu","fang",0,0,"ta","cui","xi","de","xian","kuan","zhe","ta","hu","cui","lu","juan","lu","qian","pao","zhen",0,"li","cao","qi",0,0,"ti","ling","qu","lian","lu","shu","gong","zhe","pao","jin","qing",0,0,"zong",
"pu","jin","biao","jian","gun",0,0,"zao","lie","li","luo","shen","mian","jian","di","bei",0,"lian",0,"xian","pin","que","long","zui",0,"jue","shan","xue",0,"xie",0,"lan","qi","yi","nuo","li","yue",0,"yi","chi","ji","hang","xie","keng","zi","he","xi","qu","hai","xia","hai","gui","chan","xun","xu","shen","kou","xia","sha","yu","ya","pou","zu","you","zi","lian","xian","xia","yi","sha","yan","jiao","xi","chi","shi","kang","yin","hei","yi","xi","se","jin","ye","you","que","ye","luan","kun","zheng",0,0,0,0,"xie",0,"cui","xiu","an","xiu","can","chuan","zha",0,"yi","pi","ku","sheng","lang","tui","xi","ling","qi","wo","lian","du","men","lan","wei","duan","kuai","ai","zai","hui","yi","mo","zi","fen","peng",0,
"bi","li","lu","luo","hai","zhen","gai","que","zhen","kong","cheng","jiu","jue","ji","ling",0,"shao","que","rui","chuo","neng","zhi","lou","pao",0,0,"bao","rong","xian","lei","xiao","fu","qu",0,"sha","zhi","tan","rong","su","ying","mao","nai","bian",0,"shuai","tang","han","sao","rong",0,"deng","pu","jiao","tan",0,"ran","ning","lie","die","die","zhong",0,"lu","dan","xi","gui","ji","ni","yi","nian","yu","wang","guo","ze","yan","cui","xian","jiao","tou","fu","pei",0,"you","qiu","ya","bu","bian","shi","zha","yi","bian",0,"dui","lan","yi","chai","chong","xuan","xu","yu","xiu",0,0,0,"ta","guo",0,0,0,"long","xie","che","jian","tan","pi","zan","xuan","xian","niao",0,0,0,0,0,"mi","ji","nou","hu","hua",
"wang","you","ze","bi","mi","qiang","xie","fan","yi","tan","lei","yong",0,"jin","she","yin","ji",0,"su",0,0,0,"wang","mian","su","yi","shai","xi","ji","luo","you","mao","zha","sui","zhi","bian","li",0,0,0,0,0,0,0,"qiao","guan","xi","zhen","yong","nie","jun","xie","yao","xie","zhi","neng",0,"si","long","chen","mi","que","dan","shan",0,0,0,"su","xie","bo","ding","zu",0,"shu","she","han","tan","gao",0,0,0,"na","mi","xun","men","jian","cui","jue","he","fei","shi","che","shen","nu","ping","man",0,0,0,0,"yi","chou",0,"ku","bao","lei","ke","sha","bi","sui","ge","pi","yi","xian","ni","ying","zhu","chun","feng","xu","piao","wu","liao","cang","zou","zuo","bian","yao","huan",
"pai","xiu",0,"lei","qing","xiao","jiao","guo",0,0,"yan","xue","zhu","heng","ying","xi",0,0,"lian","xian","huan","yin",0,"lian","shan","cang","bei","jian","shu","fan","dian",0,"ba","yu",0,0,"nang","lei","yi","dai",0,"chan","chao","gan","jin","nen",0,0,0,"liao","mo","you",0,"liu","han",0,"yong","jin","chi","ren","nong",0,0,"hong","tian",0,"ai","gua","biao","bo","qiong",0,"shu","chui","hui","chao","fu","hui","e","wei","fen","tan",0,"lun","he","yong","hui",0,"yu","zong","yan","qiu","zhao","jiong","tai",0,0,0,0,0,0,"tui","lin","jiong","zha","xing","hu",0,"xu",0,0,0,"cui","qing","mo",0,"zao","beng","chi",0,0,"yan","ge","mo","bei","juan","die","zhao",0,
"wu","yan",0,"jue","xian","tai","han",0,"dian","ji","jie",0,"zuan",0,"xie","lai","fan","huo","xi","nie","mi","ran","cuan","yin","mi",0,"jue","qu","tong","wan","zhe","li","shao","kong","xian","zhe","zhi","tiao","shu","bei","ye","pian","chan","hu","ken","jiu","an","chun","qian","bei","ba","fen","ke","tuo","tuo","zuo","ling",0,"gui","yan","shi","hou","lie","sha","si",0,"bei","ren","du","bo","liang","qian","fei","ji","zong","hui","he","li","yuan","yue","xiu","chan","di","lei","jin","chong","si","pu","yao","jiang","huan","huan","tao","ru","weng","ying","rao","yin","shi","yin","jue","tun","xuan","jia","zhong","qie","zhu","diao",0,"you",0,0,"yi","shi","yi","mo",0,0,"que","xiao","wu","geng","ying","ting","shi","ni","geng","ta","wo",
"ju","chan","piao","zhuo","hu","nao","yan","gou","yu","hou",0,"si","chi","hu","yang","weng","xian","pin","rong","lou","lao","shan","xiao","ze","hai","fan","han","chan","zhan",0,"ta","zhu","nong","han","yu","zhuo","you","li","huo","xi","xian","chan","lian",0,"si","jiu","pu","qiu","gong","zi","yu",0,0,"reng","niu","mei","ba","jiu",0,"xu","ping","bian","mao",0,0,0,0,"yi","yu",0,"ping","qu","bao","hui",0,0,0,"bu","mang","la","tu","wu","li","ling",0,"ji","jun","zou","duo","jue","dai","bei",0,0,0,0,0,"la","bin","sui","tu","xue",0,0,0,0,0,"duo",0,0,"sui","bi","tu","se","can","tu","mian","jin","lu",0,0,"zhan","bi","ji","zen","xuan","li",0,0,
"sui","yong","shu",0,0,"e",0,0,0,0,"qiong","luo","zhen","tun","gu","yu","lei","bo","nei","pian","lian","tang","lian","wen","dang","li","ting","wa","zhou","gang","xing","ang","fan","peng","bo","tuo","shu","yi","bo","qie","tou","gong","tong","han","cheng","jie","huan","xing","dian","chai","dong","pi","ruan","lie","sheng","ou","di","yu","chuan","rong","kang","tang","cong","piao","chuang","lu","tong","zheng","li","sa","pan","si",0,"dang","hu","yi","xian","xie","luo","liu",0,"tan","gan",0,"tan",0,0,0,"you","nan",0,"gang","jun","chi","gou","wan","li","liu","lie","xia","bei","an","yu","ju","rou","xun","zi","cuo","can","zeng","yong","fu","ruan",0,"xi","shu","jiao","jiao","xu","zhang",0,0,"shui","chen","fan","ji","zhi",0,"gu",
"wu",0,"qie","shu","hai","tuo","du","zi","ran","mu","fu","ling","ji","xiu","xuan","nai","ya","jie","li","da","ru","yuan","lu","shen","li","liang","geng","xin","xie","qin","qie","che","you","bu","kuang","que","ai","qin","qiang","chu","pei","kuo","yi","guai","sheng","pian",0,"zhou","huang","hui","hu","bei",0,0,"zha","ji","gu","xi","gao","chai","ma","zhu","tui","zhui","xian","lang",0,0,0,"zhi","ai","xian","guo","xi",0,"tui","can","sao","xian","jie","fen","qun",0,"yao","dao","jia","lei","yan","lu","tui","ying","pi","luo","li","bie",0,"mao","bai","huang",0,"yao","he","chun","he","ning","chou","li","tang","huan","bi","ba","che","yang","da","ao","xue",0,"zi","da","ran","bang","cuo","wan","ta","bao","gan","yan","xi","zhu",
"ya","fan","you","an","tui","meng","she","jin","gu","ji","qiao","jiao","yan","xi","kan","mian","xuan","shan","wo","qian","huan","ren","zhen","tian","jue","xie","qi","ang","mei","gu",0,"tao","fan","ju","chan","shun","bi","mao","shuo","gu","hong","hua","luo","hang","jia","quan","gai","huang","bu","gu","feng","mu","ai","ying","shun","liang","jie","chi","jie","chou","ping","chen","yan","du","di",0,"liang","xian","biao","xing","meng","ye","mi","qi","qi","wo","xie","yu","qia","cheng","yao","ying","yang","ji","zong","xuan","min","lou","kai","yao","yan","sun","gui","huang","ying","sheng","cha","lian",0,"xuan","chuan","che","ni","qu","miao","huo","yu","zhan","hu","ceng","biao","qian","xi","jiang","kou","mai","mang","zhan","bian","ji","jue","nang","bi","shi","shuo","mo","lie","mie","mo",
"xi","chan","qu","jiao","huo","xian","xu","niu","tong","hou","yu",0,"chong","bo","zuan","diao","zhuo","ji","qia",0,"xing","hui","shi","ku",0,"dui","yao","yu","bang","jie","zhe","jia","shi","di","dong","ci","fu","min","zhen","zhen",0,"yan","qiao","hang","gong","qiao","lue","guai","la","rui","fa","cuo","yan","gong","jie","guai","guo","suo","wo","zheng","nie","diao","lai","ta","cui","ya","gun",0,0,"di",0,"mian","jie","min","ju","yu","zhen","zhao","zha","xing",0,"ban","he","gou","hong","lao","wu","bo","keng","lu","cu","lian","yi","qiao","shu",0,"xuan","jin","qin","hui","su","chuang","dun","long",0,"nao","tan","dan","wei","gan","da","li","ca","xian","pan","la","zhu","niao","huai","ying","xian","lan","mo","ba",0,"gui","bi","fu","huo",
"yi","liu",0,"yin","juan","huo","cheng","dou","e",0,"yan","zhui","zha","qi","yu","quan","huo","nie","huang","ju","she",0,0,"peng","ming","cao","lou","li","chuang",0,"cui","shan","dan","qi",0,"lai","ling","liao","reng","yu","yi","diao","qi","yi","nian","fu","jian","ya","fang","rui","xian",0,0,"bi","shi","po","nian","zhi","tao","tian","tian","ru","yi","lie","an","he","qiong","li","gui","zi","su","yuan","ya","cha","wan","juan","ting","you","hui","jian","rui","mang","ju","zi","ju","an","sui","lai","hun","quan","chang","duo","kong","ne","can","ti","xu","jiu","huang","qi","jie","mao","yan",0,"zhi","tui",0,"ai","pang","cang","tang","en","hun","qi","chu","suo","zhuo","nou","tu","shen","lou","biao","li","man","xin","cen","huang","mei","gao",
"lian","dao","zhan","zi",0,0,"zhi","ba","cui","qiu",0,"long","xian","fei","guo","cheng","jiu","e","chong","yue","hong","yao","ya","yao","tong","zha","you","xue","yao","ke","huan","lang","yue","chen",0,0,"shen",0,"ning","ming","hong","chuang","yun","xuan","jin","zhuo","yu","tan","kang","qiong",0,"cheng","jiu","xue","zheng","chong","pan","qiao",0,"qu","lan","yi","rong","si","qian","si",0,"fa",0,"meng","hua",0,0,"hai","qiao","chu","que","dui","li","ba","jie","xu","luo",0,"yun","zhong","hu","yin",0,"zhi","qian",0,"gan","jian","zhu","zhu","ku","nie","rui","ze","ang","zhi","gong","yi","chi","ji","zhu","lao","ren","rong","zheng","na","ce",0,0,"yi","jue","bie","cheng","jun","dou","wei","yi","zhe","yan",0,"san","lun","ping",
"zhao","han","yu","dai","zhao","fei","sha","ling","ta","qu","mang","ye","bao","gui","gua","nan","ge",0,"shi","ke","suo","ci","zhou","tai","kuai","qin","xu","du","ce","huan","cong","sai","zheng","qian","jin","zong","wei",0,0,"xi","na","pu","sou","ju","zhen","shao","tao","ban","ta","qian","weng","rong","luo","hu","sou","zhong","pu","mie","jin","shao","mi","shu","ling","lei","jiang","leng","zhi","diao",0,"san","gu","fan","mei","sui","jian","tang","xie","ku","wu","fan","luo","can","ceng","ling","yi","cong","yun","meng","yu","zhi","yi","dan","huo","wei","tan","se","xie","sou","song","qian","liu","yi",0,"lei","li","fei","lie","lin","xian","xiao","ou","mi","xian","rang","zhuan","shuang","yan","bian","ling","hong","qi","liao","ban","bi","hu","hu",0,"ce","pei",
"qiong","ming","jiu","bu","mei","san","wei",0,0,"li","quan",0,"hun","xiang",0,"shi","ying",0,"nan","huang","jiu","yan",0,"sa","tuan","xie","zhe","men","xi","man",0,"huang","tan","xiao","ye","bi","luo","fan","li","cui","chua","dao","di","kuang","chu","xian","chan","mi","qian","qiu","zhen",0,0,0,"hu","gan","chi","guai","mu","bo","hua","geng","yao","mao","wang",0,0,0,"ru","xue","zheng","min","jiang",0,"zhan","zuo","yue","lie",0,"zhou","bi","ren","yu",0,"chuo","er","yi","mi","qing",0,"wang","ji","bu",0,"bie","fan","yue","li","fan","qu","fu","er","e","zheng","tian","yu","jin","qi","ju","lai","che","bei","niu","yi","xu","mou","xun","fu",0,"nin","ting","beng","zha","wei","ke","yao","ou","xiao","geng",
"tang","gui","hui","ta",0,"yao","da","qi","jin","lue","mi","mi","jian","lu","fan","ou","mi","jie","fu","bie","huang","su","yao","nie","jin","lian","bo","jian","ti","ling","zuan","shi","yin","dao","chou","ca","mie","yan","lan","chong","jiao","shuang","quan","nie","luo",0,"shi","luo","zhu",0,"chou","juan","jiong","er","yi","rui","cai","ren","fu","lan","sui","yu","you","dian","ling","zhu","ta","ping","zhai","jiao","chui","bu","kou","cun",0,"han","han","mou","hu","gong","di","fu","xuan","mi","mei","lang","gu","zhao","ta","yu","zong","li","lu","wu","lei","ji","li","li",0,"po","yang","wa","tuo","peng",0,"zhao","gui",0,"xu","nai","que","wei","zheng","dong","wei","bo",0,"huan","xuan","zan","li","yan","huang","xue","hu","bao","ran","xiao","po",
"liao","zhou","yi","xu","luo","kao","chu",0,"na","han","chao","lu","zhan","ta","fu","hong","zeng","qiao","su","pin","guan",0,"hun","chu",0,"er","er","ruan","qi","si","ju",0,"yan","bang","ye","zi","ne","chuang","ba","cao","ti","han","zuo","ba","zhe","wa","geng","bi","er","zhu","wu","wen","zhi","zhou","lu","wen","gun","qiu","la","zai","sou","mian","di","qi","cao","piao","lian","shi","long","su","qi","yuan","feng","xu","jue","di","pian","guan","niu","ren","zhen","gai","pi","tan","chao","chun","he","zhuan","mo","bie","qi","shi","bi","jue","si",0,"gua","na","hui","xi","er","xiu","mou",0,"xi","zhi","run","ju","die","zhe","shao","meng","bi","han","yu","xian","pang","neng","can","bu",0,"qi","ji","zhuo","lu","jun","xian","xi","cai",
"wen","zhi","zi","kun","cong","tian","chu","di","chun","qiu","zhe","zha","rou","bin","ji","xi","zhu","jue","ge","ji","da","chen","suo","ruo","xiang","huang","qi","zhu","sun","chai","weng","ke","kao","gu","gai","fan","cong","cao","zhi","chan","lei","xiu","zhai","zhe","yu","gui","gong","zan","dan","huo","sou","tan","gu","xi","man","duo","ao","pi","wu","ai","meng","pi","meng","yang","zhi","bo","ying","wei","rang","lan","yan","chan","quan","zhen","pu",0,"tai","fei","shu",0,"dang","cuo","tan","tian","chi","ta","jia","shun","huang","liao",0,0,"chen","jin","e","gou","fu","duo",0,"e","beng","tao","di",0,"di","bu","wan","zhao","lun","qi","mu","qian",0,"zong","sou",0,"you","zhou","ta",0,"su","bu","xi","jiang","cao","fu","teng","che","fu",
"fei","wu","xi","yang","ming","pang","mang","seng","meng","cao","tiao","kai","bai","xiao","xin","qi",0,0,"shao","huan","niu","xiao","chen","dan","feng","yin","ang","ran","ri","man","fan","qu","shi","he","bian","dai","mo","deng",0,0,"kuang",0,"cha","duo","you","hao",0,"gua","xue","lei","jin","qi","qu","wang","yi","liao",0,0,"yan","yi","yin","qi","zhe","xi","yi","ye","wu","zhi","zhi","han","chuo","fu","chun","ping","kuai","chou",0,"tuo","qiong","cong","gao","kua","qu","qu","zhi","meng","li","zhou","ta","zhi","gu","liang","hu","la","dian","ci","ying",0,0,"qi",0,"cha","mao","du","yin","chai","rui","hen","ruan","fu","lai","xing","jian","yi","mei",0,"mang","ji","suo","han",0,"li","zi","zu","yao","ge","li","qi","gong",
"li","bing","suo",0,0,"su","chou","jian","xie","bei","xu","jing","pu","ling","xiang","zuo","diao","chun","qing","nan","zhai","lu","yi","shao","yu","hua","li","pa",0,0,"li",0,0,"shuang",0,"yi","ning","si","ku","fu","yi","deng","ran","ce",0,"ti","qin","biao","sui","wei","dun","se","ai","qi","zun","kuan","fei",0,"yin",0,"sao","dou","hui","xie","ze","tan","tang","zhi","yi","fu","e",0,"jun","jia","cha","xian","man",0,"bi","ling","jie","kui","jia",0,"cheng","lang","xing","fei","lu","zha","he","ji","ni","ying","xiao","teng","lao","ze","kui",0,"qian","ju","piao","fan","tou","lin","mi","zhuo","xie","hu","mi","jie","za","cong","li","ran","zhu","yin","han",0,"yi","luan","yue","ran","ling","niang","yu","nue",0,
"yi","nue","yi","qian","xia","chu","yin","mi","xi","na","kan","zu","xia","yan","tu","ti","wu","suo","yin","chong","zhou","mang","yuan","nu","miao","zao","wan","li","qu","na","shi","bi","zi","bang",0,"juan","xiang","kui","pai","kuang","xun","zha","yao","kun","hui","xi","e","yang","tiao","you","jue","li",0,"li","cheng","ji","hu","zhan","fu","chang","guan","ju","meng","chang","tan","mou","xing","li","yan","sou","shi","yi","bing","cong","hou","wan","di","ji","ge","han","bo","xiu","liu","can","can","yi","xuan","yan","zao","han","yong","zong",0,"kang","yu","qi","zhe","ma",0,0,"shuang","jin","guan","pu","lin",0,"ting","jiang","la","yi","yong","ci","yan","jie","xun","wei","xian","ning","fu","ge",0,"mo","zhu","nai","xian","wen","li","can","mie",
"jian","ni","chai","wan","xu","nu","mai","zui","kan","ka","hang",0,0,"yu","wei","zhu",0,0,"yi",0,"diao","fu","bi","zhu","zi","shu","xia","ni",0,"jiao","xun","chong","nou","rong","zhi","sang",0,"shan","yu",0,"jin",0,"lu","han","bie","yi","zui","zhan","yu","wan","ni","guan","jue","beng","can",0,"duo","qi","yao","kui","ruan","hou","xun","xie",0,"kui",0,"xie","bo","ke","cui","xu","bai","ou","zong",0,"ti","chu","chi","niao","guan","feng","xie","deng","wei","jue","kui","zeng","sa","duo","ling","meng",0,"guo","meng","long",0,"ying",0,"guan","cu","li","du",0,"biao",0,"xi",0,"de","de","xian","lian",0,"shao","xie","shi","wei",0,0,"he","you","lu","lai","ying","sheng","juan","qi","jian","yun",
0,"qi",0,"lin","ji","mai","chuang","nian","bin","li","ling","gang","cheng","xuan","xian","hu","bi","zu","dai","dai","hun","sai","che","ti",0,"nuo","zhi","liu","fei","jiao","guan","xi","lin","xuan","reng","tao","pi","xin","shan","zhi","wa","tou","tian","yi","xie","pi","yao","yao","nu","hao","nin","yin","fan","nan","yao","wan","yuan","xia","zhou","yuan","shi","mian","xi","ji","tao","fei","xue","ni","ci","mi","bian",0,"na","yu","e","zhi","ren","xu","lue","hui","xun","nao","han","jia","dou","hua","tu","ping","cu","xi","song","mi","xin","wu","qiong","zhang","tao","xing","jiu","ju","hun","ti","man","yan","ji","shou","lei","wan","che","can","jie","you","hui","zha","su","ge","nao","xi",0,"dui","chi","wei","zhe","gun","chao","chi","zao","hui","luan",
"liao","lao","tuo","hui","wu","ao","she","sui","mai","tan","xin","jing","an","ta","chan","wei","tuan","ji","chen","che","yu","xian","xin",0,0,0,"nao",0,"yan","qiu","jiang","song","jun","liao","ju",0,"man","lie",0,"chu","chi","xiang","qin","mei","shu","chai","chi","gu","yu","yin",0,"liu","lao","shu","zhe","shuang","hui",0,0,"e",0,"sha","zong","jue","jun","tuan","lou","wei","chong","zhu","lie",0,"zhe","zhao",0,"yi","chu","ni","bo","suan","yi","hao","ya","huan","man","man","qu","lao","hao","zhong","min","xian","zhen","shu","zuo","zhu","gou","xuan","yi","zhi","xie","jin","can",0,"bu","liang","zhi","ji","wan","guan","ju","jing","ai","fu","gui","hou","yan","ruan","zhi","biao","yi","suo","die","gui","sheng","xun","chen","she","qing",
0,0,"chun","hong","dong","cheng","wei","ru","shu","cai","ji","za","qi","yan","fu","yu","fu","po","zhi","tan","zuo","che","qu","you","he","hou","gui","e","jiang","yun","tou","cun","tu","fu","zuo","hu",0,"bo","zhao","jue","tang","jue","fu","huang","chun","yong","chui","suo","chi","qian","cai","xiao","man","can","qi","jian","bi","ji","zhi","zhu","qu","zhan","ji","bian",0,"li","li","yue","quan","cheng","fu","cha","tang","shi","hang","qie","qi","bo","na","tou","chu","cu","yue","zhi","chen","chu","bi","meng","ba","tian","min","lie","feng","cheng","qiu","tiao","fu","kuo","jian",0,0,0,"zhen","qiu","zuo","chi","kui","lie","bei","du","wu",0,"zhuo","lu","tang",0,"chu","liang","tian","kun","chang","jue","tu","huan","fei","bi",0,"xia","wo",
"ji","qu","kui","hu","qiu","sui","cai",0,"qiu","pi","pang","wa","yao","rong","xun","cu","die","chi","cuo","meng","xuan","duo","bie","zhe","chu","chan","gui","duan","zou","deng","lai","teng","yue","quan","zhu","ling","chen","zhen","fu","she","tiao","kua","ai",0,"qiong","shu","hai","shan","wai","zhan","long","jiu","li",0,"chun","rong","yue","jue","kang","fan","qi","hong","fu","lu","hong","tuo","min","tian","juan","qi","zheng","qing","gong","tian","lang","mao","yin","lu","yuan","ju","pi",0,"xie","bian","hun","zhu","rong","sang","wu","cha","keng","shan","peng","man","xiu",0,"cong","keng","zhuan","chan","si","chong","sui","bei","kai",0,"zhi","wei","min","ling","zuan","nie","ling","qi","yue",0,"yi","xi","chen",0,"rong","chen","nong","you","ji","bo","fang",0,0,
"cu","di","jiao","yu","he","xu","yu","qu",0,"bai","geng","jiong",0,"ya","shu","you","song","ye","cang","yao","shu","yan","shuai","liao","cong","yu","bo","sui",0,"yan","lei","lin","ti","du","yue","ji",0,"yun",0,0,"ju","ju","chu","chen","gong","xiang","xian","an","gui","yu","lei",0,"tu","chen","xing","qiu","hang",0,"dang","cai","di","yan","zi",0,"ying","chan",0,"li","suo","ma","ma",0,"tang","pei","lou","qi","cuo","tu","e","can","jie","yi","ji","dang","jue","bi","lei","yi","chun","chun","po","li","zai","tai","po","cu","ju","xu","fan",0,"xu","er","huo","zhu","ran","fa","juan","han","liang","zhi","mi","yu",0,"cen","mei","yin","mian","tu","kui",0,0,"mi","rong","yu","qiang","mi","ju","pi","jin",
"wang","ji","meng","jian","xue","bao","gan","chan","li","li","qiu","dun","ying","yun","chen","zhi","ran",0,"lue","kai","gui","yue","hui","pi","cha","duo","chan","sha","shi","she","xing","ying","shi","chi","ye","han","fei","ye","yan","zuan","sou","jin","duo","xian","guan","tao","qie","chan","han","meng","yue","cu","qian","jin","shan","mu","yuan",0,"peng","zheng","zhi","chun","yu","mou","wan","jiang","qi","su","pie","tian","kuan","cu","sui",0,"jie","jian","ao","jiao","ye",0,"ye","long","zao","bao","lian",0,"huan","lu","wei","xian","tie","bo","zheng","zhu","bei","meng","xie","ou","you",0,"xiao","li","zha","mi",0,"ye",0,0,"po","xie",0,0,0,"shan","zhuo",0,"shan","jue","ji","jie",0,"niao","ao","chu","wu","guan","xie","ting","xue",
"dang","zhan","tan","peng","xie","xu","xian","si","kua","zheng","wu","huo","run","wen","du","huan","kuo","fu","chuai","xian","qin","qie","lan",0,"ya","ying","que","hang","chun","zhi",0,"wei","yan","xiang","yi","ni","zheng","chuai",0,"shi","ding","zi","jue","xu","yuan",0,0,"xu","dao","tian","ge","yi","hong","yi",0,"li","ku","xian","sui","xi","xuan",0,0,"di","lai","zhou","nian","cheng","jian","bi","zhuan","ling","hao","bang","tang","chi","ma","xian","shuan","yong","qu",0,"pu","hui","wei","yi","ye",0,"che","hao","bin",0,"xian","chan","hun",0,"han","ci","zhi","qi","kui","rou",0,"ying","xiong",0,"hu","cui",0,"que","di","wu","qiu",0,"yan","liao","bi",0,"bin",0,"yuan","nue","bao","ying","hong","ci","qia","ti","yu",
"lei","bao",0,"ji","fu","xian","cen","hu","se","beng","qing","yu","wa","ai","han","dan","ge","di","huo","pang",0,"zhui","ling","mai","mai","lian","xiao","xue","zhen","po","fu","nou","xi","dui","dan","yun","xian","yin","shu","dui","beng","hu","fei","fei","za","bei","fei","xian","shi","mian","zhan","zhan","zhan","hui","fu","wan","mo","qiao","liao",0,"mie","hu","hong","yu","qi","duo","ang",0,"ba","di","xuan","di","bi","zhou","pao","tie","yi",0,"jia","zhi","tu","xie","dan","tiao","xie","chang","yuan","guan","liang","beng",0,"lu","ji","xuan","shu","du","sou","hu","yun","chan","bang","rong","e","weng","ba","feng","yu","zhe","fen","guan","bu","ge","dun","huang","du","ti","bo","qian","lie","long","wei","zhan","lan","sui","na","bi","tuo","zhu","die",
"bu","ju","po","xia","wei","po","da","fan","chan","hu","za",0,0,0,0,0,"fan","xie","hong","chi","bao","yin",0,"jing","bo","ruan","chou","ying","yi","gai","kun","yun","zhen","ya","ju","hou","min","bai","ge","bian","zhuo","hao","zhen","sheng","gen","bi","duo","chun","chua","san","cheng","ran","chen","mao","pei","wei","pi","fu","zhuo","qi","lin","yi","men","wu","qi","die","chen","xia","he","sang","gua","hou","ao","fu","qiao","hun","pi","yan","si","xi","ming","kui","ge",0,"ao","san","shuang","lou","zhen","hui","chan",0,"lin","na","han","du","jin","mian","fan","e","chao","hong","hong","yu","xue","pao","bi","chao","you","yi","xue","sa","xu","li","li","yuan","dui","huo","sha","leng","pou","hu","guo","bu","rui","wei","sou","an","yu",
"xiang","heng","yang","xiao","yao",0,"bi",0,"heng","tao","liu",0,"zhu",0,"xi","zan","yi","dou","yuan","jiu",0,"bo","ti","ying",0,"yi","nian","shao","ben","gou","ban","mo","gai","en","she",0,"zhi","yang","jian","yuan","shui","ti","wei","xun","zhi","yi","ren","shi","hu","ne","ye","jian","sui","ying","bao","hu","hu","ye",0,"yang","lian","xi","en","dui","zan","zhu","ying","ying","jin","chuang","dan",0,"kuai","yi","ye","jian","en","ning","ci","qian","xue","bo","mi","shui","mo","liang","qi","qi","shou","fu","bo","beng","bie","yi","wei","huan","fan","qi","mao","bao","ang","ang","fu","qi","qun","tuo","yi","bo","pian","ba",0,"xuan",0,0,"yu","chi","lu","yi","li",0,"niao","xi","wu",0,"lei","pu","zhuo","zui","zhuo",
"chang","an","er","yu","leng","fu","zha","hun","chun","sou","bi","bi","zha",0,"he","li",0,"han","zai","gu","cheng","lou","mo","mi","mai","ao","zhe","zhu","huang","fan","deng","tong",0,"du","wo","wei","ji","chi","lin","biao","long","jian","nie","luo","shen",0,"gua","nie","yi","ku","wan","wa","qia","bo","kao","ling","gan","gua","hai","kuang","heng","kui","ze","ting","lang","bi","huan","po","yao","wan","ti","sui","kua","dui","ao","jian","mo","kui","kuai","an","ma","qing","qiao",0,"kao","hao","duo","xian","nai","suo","jie","pi","pa","song","chang","nie","man","song","ci","xian","kuo",0,"di","pou","tiao","zu","wo","fei","cai","peng","sai",0,"rou","qi","cuo","pan","bo","man","zong","ci","kui","ji","lan",0,"meng","mian","pan","lu","zuan",
0,"liu","yi","wen","li","li","zeng","zhu","hun","shen","chi","xing","wang","dong","huo","pi","hu","mei","che","mei","chao","ju","nou",0,"yi","ru","ling","ya",0,"qi","zi",0,"bang","gong","ze","jie","yu","qin","bei","ba","tuo","yang","qiao","you","zhi","jie","mo","sheng","shan","qi","shan","mi","gong","yi","geng","geng","tou","fu","xue","ye","ting","tiao","mou","liu","can","li","shu","lu","huo","cuo","pai","liu","ju","zhan","ju","zheng","zu","xian","zhi",0,0,"la",0,0,"la","xu","geng","e","mu","zhong","ti","yuan","zhan","geng","weng","lang","yu","sou","zha","hai","hua","zhan",0,"lou","chan","zhi","wei","xuan","zao","min","gui","su",0,0,"si","duo","cen","kuan","teng","nei","lao","lu","yi","xie","yan","qing","pu","chou","xian",
"guan","jie","lai","meng","ye",0,"li","yin","chun","qiu","teng","yu",0,0,"dai","du","hong",0,"xi",0,"qi",0,"yuan","ji","yun","fang","gong","hang","zhen","que",0,0,"jie","pi","gan","xuan","sheng","shi","qiao","ci","die","bo","diao","wan","ci","zhi","bai","wu","bao","dan","ba","tong",0,"gong","jiu","gui","ci","you","yuan","lao","ju","fu","nie","e","e","xing","kan","yan","tu","pou","beng","ming","shui","yan","qi","yuan","bie",0,"xuan","hou","huang","yao","juan","kui","e","ji","mo","chong","bao","wu","zhen","xu","ta","chi","xi","cong","ma","kou","yan","can",0,"he","deng","ran","tong","yu","xiang","nao","shun","fen","pu","ling","ao","huan","yi","huan","meng","ying","lei","yan","bao","die","ling","shi","jiao","lie","jing","ju","ti",
"pi","gang","xiao","wai","chuai","di","huan","yao","li","mi","hu","sheng","jia","yin","wei",0,"piao","lu","ling","yi","cai","shan","hu","shu","tuo","mo","hua","tie","bing","peng","hun","fu","guo","bu","li","chan","pi","cuo","meng","suo","qiang","zhi","kuang","bi","ao","meng","xian","ku","tou","tuan","wei","xian",0,"tuan","lao","chan","ni","ni","li","dong","ju","qian","bo","shai","zha","tao","qian","nong","yi","jing","gan","di","jian","mei","da","jian","yu","xie","zai","mang","li","gun","xun","ta","zhe","yang","tuan","shang","xi","qiao","wei","ying","chua","qu","wa",0,"zhi","ting","gu","shang","ca","fu","tie","ta","ta","zhuo","han","ping","he","zhui","zhou","bo","liu","nu","xi","pao","di","he","ti","wai","ti","qi","ji","chi","ba","jin","ke","li","ju",
"qu","la","gu","qia","qi","xian","jian","shi","jian","ai","hua","zha","ze","yao","zhan","ji","cha","yan","jian",0,"yan",0,"jiao","tong","nan","yue",0,"chi",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"yi","ding","kao","qi","shang","xia","han","wan","zhang","san","shang","xia","ji","bu","yu","mian","gai","chou","chou","zhuan","qie","pi","shi","shi","qiu","bing","ye",
"cong","dong","si","cheng","diu","qiu","liang","diu","you","liang","yan","bing","sang","gun","jiu","ge","ya","qiang","zhong","ji","jie","feng","guan","chuan","chan","lin","zhuo","zhu","ha","wan","dan","wei","zhu","jing","li","ju","pie","fu","yi","yi","nai","wu","jiu","jiu","tuo","me","yi","yi","zhi","wu","zha","hu","fa","le","yin","ping","pang","qiao","hu","guai","cheng","cheng","yi","yin","ya","mie","jiu","qi","ye","xi","xiang","gai","jiu","xia","hu","shu","dou","shi","ji","nang","jia","ju","shi","mao","hu","mai","luan","zi","ru","xue","yan","fu","sha","na","gan","suo","yu","cui","zhe","gan","zhi","gui","gan","luan","lin","yi","jue","le","ma","yu","zheng","shi","shi","er","chu","yu","kui","yu","yun","hu","qi","wu","jing","si","sui","gen","gen","ya","xie",
"ya","qi","ya","ji","tou","wang","kang","ta","jiao","hai","yi","chan","heng","mu","ye","xiang","jing","ting","liang","xiang","jing","ye","qin","bo","you","xie","dan","lian","duo","men","ren","ren","ji","ji","wang","yi","shen","ren","le","ding","ze","jin","pu","chou","ba","zhang","jin","jie","bing","reng","cong","fo","san","lun","bing","cang","zi","shi","ta","zhang","fu","xian","xian","tuo","hong","tong","ren","qian","gan","ge","bo","dai","ling","yi","chao","chang","sa","shang","yi","mu","men","ren","jia","chao","yang","qian","zhong","pi","wo","wu","jian","jia","yao","feng","cang","ren","wang","fen","di","fang","zhong","qi","pei","yu","diao","dun","wu","yi","xin","kang","yi","ji","ai","wu","ji","fu","fa","xiu","jin","pi","dan","fu","tang","zhong","you","huo","hui","yu","cui",
"chuan","san","wei","chuan","che","ya","xian","shang","chang","lun","cang","xun","xin","wei","zhu","ze","xian","nu","bo","gu","ni","ni","xie","ban","xu","ling","zhou","shen","qu","ci","beng","shi","jia","pi","yi","si","yi","zheng","dian","han","mai","dan","zhu","bu","qu","bi","zhao","ci","wei","di","zhu","zuo","you","yang","ti","zhan","he","bi","tuo","she","yu","yi","fu","zuo","gou","ning","tong","ni","xian","qu","yong","wa","qian","shi","ka","bao","pei","hui","he","lao","xiang","ge","yang","bai","fa","ming","jia","er","bing","ji","hen","huo","gui","quan","tiao","jiao","ci","yi","shi","xing","shen","tuo","kan","zhi","gai","lai","yi","chi","kua","guang","li","yin","shi","mi","zhu","xu","you","an","lu","mou","er","lun","dong","cha","chi","xun","gong","zhou","yi",
"ru","cun","xia","si","zai","lu","ta","jiao","zhen","ce","qiao","kuai","chai","ning","nong","jin","wu","hou","jiong","cheng","zhen","zuo","chou","qin","lu","ju","shu","ting","shen","tui","bo","nan","xiao","bian","tui","yu","xi","cu","e","qiu","xu","guang","ku","wu","jun","yi","fu","liang","zu","qiao","li","yong","hun","jing","qian","san","pei","su","fu","xi","li","fu","ping","bao","yu","qi","xia","xin","xiu","yu","di","che","chou","zhi","yan","lia","li","lai","si","jian","xiu","fu","huo","ju","xiao","pai","jian","biao","chu","fei","feng","ya","an","bei","yu","xin","bi","hu","chang","zhi","bing","jiu","yao","cui","lia","wan","lai","cang","zong","ge","guan","bei","tian","shu","shu","men","dao","tan","jue","chui","xing","peng","tang","hou","yi","qi","ti","gan","jing",
"jie","sui","chang","jie","fang","zhi","kong","juan","zong","ju","qian","ni","lun","zhuo","wo","luo","song","leng","hun","dong","zi","ben","wu","ju","nai","cai","jian","zhai","ye","zhi","sha","qing","qie","ying","cheng","jian","yan","ruan","zhong","chun","jia","ji","wei","yu","bing","ruo","ti","wei","pian","yan","feng","tang","wo","e","xie","che","sheng","kan","di","zuo","cha","ting","bei","xie","huang","yao","zhan","chou","yan","you","jian","xu","zha","ci","fu","bi","zhi","zong","mian","ji","yi","xie","xun","cai","duan","ce","zhen","ou","tou","tou","bei","za","lou","jie","wei","fen","chang","gui","sou","zhi","su","xia","fu","yuan","rong","li","nu","yun","jiang","ma","bang","dian","tang","hao","jie","xi","shan","qian","jue","cang","chu","san","bei","xiao","yong","yao","tan","suo","yang",
"fa","bing","jia","dai","zai","tang","gu","bin","chu","nuo","can","lei","cui","yong","zao","zong","beng","song","ao","chuan","yu","zhai","zu","shang","chuang","jing","chi","sha","han","zhang","qing","yan","di","xie","lou","bei","piao","jin","lian","lu","man","qian","xian","tan","ying","dong","zhuan","xiang","shan","qiao","jiong","tui","zun","pu","xi","lao","chang","guang","liao","qi","cheng","chan","wei","ji","bo","hui","chuan","tie","dan","jiao","jiu","seng","fen","xian","ju","e","jiao","jian","tong","lin","bo","gu","xian","su","xian","jiang","min","ye","jin","jia","qiao","pi","feng","zhou","ai","sai","yi","jun","nong","chan","yi","dang","jing","xuan","kuai","jian","chu","dan","jiao","sha","zai","can","bin","an","ru","tai","chou","chai","lan","ni","jin","qian","meng","wu","ning","qiong","ni","chang","lie",
"lei","lu","kuang","bao","yu","biao","zan","zhi","si","you","hao","chen","chen","li","teng","wei","long","chu","chan","rang","shu","hui","li","luo","zan","nuo","tang","yan","lei","nang","er","wu","yun","zan","yuan","xiong","chong","zhao","xiong","xian","guang","dui","ke","dui","mian","tu","chang","er","dui","er","jin","tu","si","yan","yan","shi",0,"dang","qian","dou","fen","mao","shen","dou",0,"jing","li","huang","ru","wang","nei","quan","liang","yu","ba","gong","liu","xi","han","lan","gong","tian","guan","xing","bing","qi","ju","dian","zi","fen","yang","jian","shou","ji","yi","ji","chan","jiong","mao","ran","nei","yuan","mao","gang","ran","ce","jiong","ce","zai","gua","jiong","mao","zhou","mao","gou","xu","mian","mi","rong","yin","xie","kan","jun","nong","yi","mi","shi","guan","meng",
"zhong","ju","yuan","ming","kou","lin","fu","xie","mi","bing","dong","tai","gang","feng","bing","hu","chong","jue","hu","kuang","ye","leng","pan","fu","min","dong","xian","lie","qia","jian","jing","shu","mei","tu","qi","gu","zhun","song","jing","liang","qing","diao","ling","dong","gan","jian","yin","cou","yi","li","chuang","ming","zhun","cui","si","duo","jin","lin","lin","ning","xi","du","ji","fan","fan","fan","feng","ju","chu","zheng","feng","mu","zhi","fu","feng","ping","feng","kai","huang","kai","gan","deng","ping","qian","xiong","kuai","tu","ao","chu","ji","dang","han","han","zao","dao","diao","dao","ren","ren","chuang","fen","qie","yi","ji","kan","qian","cun","chu","wen","ji","dan","xing","hua","wan","jue","li","yue","lie","liu","ze","gang","chuang","fu","chu","qu","ju","shan","min","ling",
"zhong","pan","bie","jie","jie","pao","li","shan","bie","chan","jing","gua","geng","dao","chuang","kui","ku","duo","er","zhi","shua","quan","sha","ci","ke","jie","gui","ci","gui","kai","duo","ji","ti","jing","lou","luo","ze","yuan","cuo","xue","ke","la","qian","sha","chuang","gua","jian","cuo","li","ti","fei","pou","chan","qi","chuang","zi","gang","wan","bo","ji","duo","qing","shan","du","jian","ji","bo","yan","ju","huo","sheng","jian","duo","duan","wu","gua","fu","sheng","jian","ge","da","kai","chuang","chuan","chan","tuan","lu","li","peng","shan","piao","kou","jiao","gua","qiao","jue","hua","zha","zhuo","lian","ju","pi","liu","gui","jiao","gui","jian","jian","tang","huo","ji","jian","yi","jian","zhi","chan","jian","mo","li","zhu","li","ya","quan","ban","gong","jia","wu","mai","lie",
"jin","keng","xie","zhi","dong","zhu","nu","jie","qu","shao","yi","zhu","mo","li","jin","lao","lao","juan","kou","yang","wa","xiao","mou","kuang","jie","lie","he","shi","ke","jin","gao","bo","min","chi","lang","yong","yong","mian","ke","xun","juan","qing","lu","bu","meng","chi","lei","kai","mian","dong","xu","xu","kan","wu","yi","xun","weng","sheng","lao","mu","lu","piao","shi","ji","qin","jiang","chao","quan","xiang","yi","jue","fan","juan","tong","ju","dan","xie","mai","xun","xun","lu","li","che","rang","quan","bao","shao","yun","jiu","bao","gou","wu","yun","wen","bi","gai","gai","bao","cong","yi","xiong","peng","ju","tao","ge","pu","e","pao","fu","gong","da","jiu","qiong","bi","hua","bei","nao","shi","fang","jiu","yi","za","jiang","kang","jiang","kuang","hu","xia","qu",
"bian","gui","qie","zang","kuang","fei","hu","yu","gui","kui","hui","dan","gui","lian","lian","suan","du","jiu","jue","xi","pi","qu","yi","ke","yan","bian","ni","qu","shi","xun","qian","nian","sa","zu","sheng","wu","hui","ban","shi","xi","wan","hua","xie","wan","bei","zu","zhuo","xie","dan","mai","nan","dan","ji","bo","shuai","bo","kuang","bian","bu","zhan","ka","lu","you","lu","xi","gua","wo","xie","jie","jie","wei","ang","qiong","zhi","mao","yin","wei","shao","ji","que","luan","chi","juan","xie","xu","jin","que","wu","ji","e","qing","xi","san","chang","wei","e","ting","li","zhe","han","li","ya","ya","yan","she","di","zha","pang","ya","he","ya","zhi","ce","pang","ti","li","she","hou","ting","zui","cuo","fei","yuan","ce","yuan","xiang","yan","li","jue",
"sha","dian","chu","jiu","jin","ao","gui","yan","si","li","chang","lan","li","yan","yan","yuan","si","gong","lin","rou","qu","qu","er","lei","du","xian","zhuan","san","can","can","can","can","ai","dai","you","cha","ji","you","shuang","fan","shou","guai","ba","fa","ruo","shi","shu","zhuo","qu","shou","bian","xu","jia","pan","sou","gao","wei","sou","die","rui","cong","kou","gu","ju","ling","gua","dao","kou","zhi","jiao","zhao","ba","ding","ke","tai","chi","shi","you","qiu","po","ye","hao","si","tan","chi","le","diao","ji","liao","hong","mie","xu","mang","chi","ge","xuan","yao","zi","he","ji","diao","cun","tong","ming","hou","li","tu","xiang","zha","xia","ye","lu","ya","ma","ou","huo","yi","jun","chou","lin","tun","yin","fei","bi","qin","qin","jie","bu","fou",
"ba","dun","fen","e","han","ting","keng","shun","qi","hong","zhi","yin","wu","wu","chao","na","xue","xi","chui","dou","wen","hou","hong","wu","gao","ya","jun","lu","e","ge","mei","dai","qi","cheng","wu","gao","fu","jiao","hong","chi","sheng","na","tun","fu","yi","dai","ou","li","bei","yuan","guo","wen","qiang","wu","e","shi","juan","pen","wen","ne","m","ling","ran","you","di","zhou","shi","zhou","tie","xi","yi","qi","ping","zi","gu","ci","wei","xu","a","nao","ga","pei","yi","xiao","shen","hu","ming","da","qu","ju","han","za","tuo","duo","pou","pao","bie","fu","yang","he","za","he","hai","jiu","yong","fu","da","zhou","wa","ka","gu","ka","zuo","bu","long","dong","ning","ta","si","xian","huo","qi","er","e","guang","zha","xi","yi","lie",
"zi","mie","mi","zhi","yao","ji","zhou","ge","shu","zan","xiao","hai","hui","kua","huai","tao","xian","e","xuan","xiu","guo","yan","lao","yi","ai","pin","shen","tong","hong","xiong","duo","wa","ha","zai","you","die","pai","xiang","ai","gen","kuang","ya","da","xiao","bi","hui","nian","hua","xing","kuai","duo","fen","ji","nong","mou","yo","hao","yuan","long","pou","mang","ge","o","chi","shao","li","na","zu","he","ku","xiao","xian","lao","bo","zhe","zha","liang","ba","mie","lie","sui","fu","bu","han","heng","geng","shuo","ge","you","yan","gu","gu","bei","han","suo","chun","yi","ai","jia","tu","xian","wan","li","xi","tang","zuo","qiu","che","wu","zao","ya","dou","qi","di","qin","ma","mo","gong","dou","qu","lao","liang","suo","zao","huan","lang","sha","ji","zuo",
"wo","feng","jin","hu","qi","shou","wei","shua","chang","er","li","qiang","an","ze","yo","nian","yu","tian","lai","sha","xi","tuo","hu","ai","zhao","nou","ken","zhuo","zhuo","shang","di","heng","lin","a","cai","xiang","tun","wu","wen","cui","sha","gu","qi","qi","tao","dan","dan","ye","zi","bi","cui","chuai","he","ya","qi","zhe","fei","liang","xian","pi","sha","la","ze","ying","gua","pa","zhe","se","zhuan","nie","guo","luo","yan","di","quan","chan","bo","ding","lang","xiao","ju","tang","chi","ti","an","jiu","dan","ka","yong","wei","nan","shan","yu","zhe","la","jie","hou","han","die","zhou","chai","wai","nuo","yu","yin","za","yao","o","mian","hu","yun","chuan","hui","huan","huan","xi","he","ji","kui","zhong","wei","sha","xu","huang","duo","nie","xuan","liang","yu",
"sang","chi","qiao","yan","dan","pen","can","li","yo","zha","wei","miao","ying","pen","bu","kui","xi","yu","jie","lou","ku","zao","hu","ti","yao","he","a","xiu","qiang","se","yong","su","hong","xie","ai","suo","ma","cha","hai","ke","da","sang","chen","ru","sou","wa","ji","pang","wu","qian","shi","ge","zi","jie","luo","weng","wa","si","chi","hao","suo",0,"hai","suo","qin","nie","he","zhi","sai","n","ge","na","dia","ai","qiang","tong","bi","ao","ao","lian","zui","zhe","mo","sou","sou","tan","di","qi","jiao","chong","jiao","kai","tan","shan","cao","jia","ai","xiao","piao","lou","ga","gu","xiao","hu","hui","guo","ou","xian","ze","chang","xu","po","de","ma","ma","hu","lei","du","ga","tang","ye","beng","ying","sai","jiao","mi","xiao","hua","mai",
"ran","chuai","peng","lao","xiao","ji","zhu","chao","kui","zui","xiao","si","hao","fu","liao","qiao","xi","chu","chan","dan","hei","xun","e","zun","fan","chi","hui","zan","chuang","cu","dan","yu","tun","ceng","jiao","ye","xi","qi","hao","lian","xu","deng","hui","yin","pu","jue","qin","xun","nie","lu","si","yan","ying","da","zhan","o","zhou","jin","nong","hui","xie","qi","e","zao","yi","shi","jiao","yuan","ai","yong","jue","kuai","yu","pen","dao","ga","hm","dun","dang","xin","sai","pi","pi","yin","zui","ning","di","lan","ta","huo","ru","hao","xia","ye","duo","pi","chou","ji","jin","hao","ti","chang","xun","me","ca","ti","lu","hui","bo","you","nie","yin","hu","me","hong","zhe","li","liu","hai","nang","xiao","mo","yan","li","lu","long","mo","dan","chen",
"pin","pi","xiang","huo","mo","xi","duo","ku","yan","chan","ying","rang","dian","la","ta","xiao","jue","chuo","huan","huo","zhuan","nie","xiao","ca","li","chan","chai","li","yi","luo","nang","za","su","xi","zen","jian","za","zhu","lan","nie","nang","lan","lo","wei","hui","yin","qiu","si","nin","jian","hui","xin","yin","nan","tuan","tuan","dun","kang","yuan","jiong","pian","yun","cong","hu","hui","yuan","e","guo","kun","cong","tong","tu","wei","lun","guo","qun","ri","ling","gu","guo","tai","guo","tu","you","guo","yin","hun","pu","yu","han","yuan","lun","quan","yu","qing","guo","chuan","wei","yuan","quan","ku","fu","yuan","yuan","ya","tu","tu","tu","tuan","lue","hui","yi","huan","luan","luan","tu","ya","tu","ting","sheng","pu","lu","kuai","ya","zai","wei","ge","yu","wu",
"gui","pi","yi","de","qian","qian","zhen","zhuo","dang","qia","xia","shan","kuang","chang","qi","nie","mo","ji","jia","zhi","zhi","ban","xun","yi","qin","mei","jun","rong","tun","fang","ben","ben","tan","kan","huai","zuo","keng","bi","jing","di","jing","ji","kuai","di","jing","jian","tan","li","ba","wu","fen","zhui","po","ban","tang","kun","qu","tan","zhi","tuo","gan","ping","dian","gua","ni","tai","pi","jiong","yang","fo","ao","lu","qiu","mu","ke","gou","xue","ba","chi","che","ling","zhu","fu","hu","zhi","chui","la","long","long","lu","ao","dai","pao","min","xing","dong","ji","he","lu","ci","chi","lei","gai","yin","hou","dui","zhao","fu","guang","yao","duo","duo","gui","cha","yang","yin","fa","gou","yuan","die","xie","ken","shang","shou","e","bing","dian","hong","ya",
"kua","da","ka","dang","kai","hang","nao","an","xing","xian","yuan","bang","fu","ba","yi","yin","han","xu","chui","qin","geng","ai","beng","fang","que","yong","jun","jia","di","mai","lang","juan","cheng","shan","jin","zhe","lie","lie","bu","cheng","hua","bu","shi","xun","guo","jiong","ye","nian","di","yu","bu","ya","quan","sui","pi","qing","wan","ju","lun","zheng","kong","chong","dong","dai","tan","an","cai","chu","beng","kan","zhi","duo","yi","zhi","yi","pei","ji","zhun","qi","sao","ju","ni","ku","ke","tang","kun","ni","jian","dui","jin","gang","yu","e","peng","gu","tu","leng","fang","ya","qian","kun","an","shen","duo","nao","tu","cheng","yin","hun","bi","lian","guo","die","zhuan","hou","bao","bao","yu","di","mao","jie","ruan","ye","geng","kan","zong","yu","huang","e",
"yao","yan","bao","ci","mei","chang","du","tuo","yin","feng","zhong","jie","jin","heng","gang","chun","jian","ping","lei","xiang","huang","leng","duan","wan","xuan","ji","ji","kuai","ying","ta","cheng","yong","kai","su","su","shi","mi","ta","weng","cheng","tu","tang","que","zhong","li","zhong","bang","sai","zang","dui","tian","wu","zheng","xun","ge","zhen","ai","gong","yan","kan","tian","yuan","wen","xie","liu","hai","lang","chang","peng","beng","chen","lu","lu","ou","qian","mei","mo","zhuan","shuang","shu","lou","chi","man","biao","jing","ce","shu","zhi","zhang","kan","yong","dian","chen","zhi","xi","guo","qiang","jin","di","shang","mu","cui","yan","ta","zeng","qian","qiang","liang","wei","zhui","qiao","zeng","xu","shan","shan","ba","pu","kuai","dong","fan","que","mo","dun","dun","zun","di","sheng","duo","duo",
"tan","deng","mu","fen","huang","tan","da","ye","zhu","jian","ao","qiang","ji","qiao","ken","yi","pi","bi","dian","jiang","ye","yong","xue","tan","lan","ju","huai","dang","rang","qian","xun","xian","xi","he","ai","ya","dao","hao","ruan","jin","lei","kuang","lu","yan","tan","wei","huai","long","long","rui","li","lin","rang","chan","xun","yan","lei","ba","wan","shi","ren","san","zhuang","zhuang","sheng","yi","mai","ke","zhu","zhuang","hu","hu","kun","yi","hu","xu","kun","shou","mang","zun","shou","yi","zhi","gu","chu","jiang","feng","bei","zhai","bian","sui","qun","ling","fu","cuo","xia","xiong","xie","nao","xia","kui","xi","wai","yuan","mao","su","duo","duo","ye","qing","wai","gou","gou","qi","meng","meng","yin","huo","chen","da","ze","tian","tai","fu","guai","yao","yang","hang","gao",
"shi","tao","tai","tou","yan","bi","yi","kua","jia","duo","hua","kuang","yun","jia","ba","en","lian","huan","di","yan","pao","juan","qi","nai","feng","xie","fen","dian","yang","kui","zou","huan","qi","kai","zha","ben","yi","jiang","tao","zang","ben","xi","huang","fei","diao","xun","beng","dian","ao","she","weng","ha","ao","wu","ao","jiang","lian","duo","yun","jiang","shi","fen","huo","bi","luan","duo","nu","nu","ding","nai","qian","jian","ta","jiu","nuan","cha","hao","xian","fan","ji","shuo","ru","fei","wang","hong","zhuang","fu","ma","dan","ren","fu","jing","yan","hai","wen","zhong","pa","du","ji","keng","zhong","yao","jin","yun","miao","fou","chi","yue","zhuang","niu","yan","na","xin","fen","bi","yu","tuo","feng","wan","fang","wu","yu","gui","du","ba","ni","zhou","zhuo","zhao",
"da","nai","yuan","tou","xian","zhi","e","mei","mo","qi","bi","shen","qie","e","he","xu","fa","zheng","min","ban","mu","fu","ling","zi","zi","shi","ran","shan","yang","man","jie","gu","si","xing","wei","zi","ju","shan","pin","ren","yao","dong","jiang","shu","ji","gai","xiang","hua","juan","jiao","gou","lao","jian","jian","yi","nian","zhi","ji","ji","xian","heng","guang","jun","kua","yan","ming","lie","pei","e","you","yan","cha","shen","yin","shi","gui","quan","zi","song","wei","hong","wa","lou","ya","rao","jiao","luan","ping","xian","shao","li","cheng","xie","mang","fu","suo","mei","wei","ke","chuo","chuo","ting","niang","xing","nan","yu","na","pou","nei","juan","shen","zhi","han","di","zhuang","e","pin","tui","xian","mian","wu","yan","wu","ai","yan","yu","si","yu","wa",
"li","xian","ju","qu","zhui","qi","xian","zhuo","dong","chang","lu","ai","e","e","lou","mian","cong","pou","ju","po","cai","ling","wan","biao","xiao","shu","qi","hui","fan","wo","rui","tan","fei","fei","jie","tian","ni","quan","jing","hun","jing","qian","dian","xing","hu","wan","lai","bi","yin","chou","nao","fu","jing","lun","an","lan","kun","yin","ya","ju","li","dian","xian","hua","hua","ying","chan","shen","ting","dang","yao","wu","nan","chuo","jia","tou","xu","yu","wei","di","rou","mei","dan","ruan","qin","hui","wo","qian","chun","miao","fu","jie","duan","yi","zhong","mei","huang","mian","an","ying","xuan","jie","wei","mei","yuan","zheng","qiu","shi","xie","tuo","lian","mao","ran","si","pian","wei","wa","jiu","hu","ao","qie","bao","xu","tou","gui","chu","yao","pi","xi",
"yuan","ying","rong","ru","chi","liu","mei","pan","ao","ma","gou","kui","qin","jia","sao","zhen","yuan","jie","rong","ming","ying","ji","su","niao","xian","tao","pang","lang","nao","bao","ai","pi","pin","yi","piao","yu","lei","xuan","man","yi","zhang","kang","yong","ni","li","di","gui","yan","jin","zhuan","chang","ze","han","nen","lao","mo","zhe","hu","hu","ao","nen","qiang","ma","pie","gu","wu","qiao","tuo","zhan","mao","xian","xian","mo","liao","lian","hua","gui","deng","zhi","xu","yi","hua","xi","kui","rao","xi","yan","chan","jiao","mei","fan","fan","xian","yi","hui","jiao","fu","shi","bi","shan","sui","qiang","lian","huan","xin","niao","dong","yi","can","ai","niang","ning","ma","tiao","chou","jin","ci","yu","pin","rong","ru","nai","yan","tai","ying","can","niao","yue","ying",
"mian","bi","ma","shen","xing","ni","du","liu","yuan","lan","yan","shuang","ling","jiao","niang","lan","qian","ying","shuang","hui","quan","mi","li","luan","yan","zhu","lan","zi","jie","jue","jue","kong","yun","ma","zi","cun","sun","fu","bei","zi","xiao","xin","meng","si","tai","bao","ji","gu","nu","xue","you","zhuan","hai","luan","sun","nao","mie","cong","qian","shu","can","ya","zi","ni","fu","zi","li","xue","bo","ru","nai","nie","nie","ying","luan","mian","ning","rong","ta","gui","zhai","qiong","yu","shou","an","tu","song","wan","rou","yao","hong","yi","jing","zhun","mi","zhu","dang","hong","zong","guan","zhou","ding","wan","yi","bao","shi","shi","chong","shen","ke","xuan","shi","you","huan","yi","tiao","shi","xian","gong","cheng","qun","gong","xiao","zai","zha","bao","hai","yan","xiao",
"jia","shen","chen","rong","huang","mi","kou","kuan","bin","su","cai","zan","ji","yuan","ji","yin","mi","kou","qing","que","zhen","jian","fu","ning","bing","huan","mei","qin","han","yu","shi","ning","jin","ning","zhi","yu","bao","kuan","ning","qin","mo","cha","ju","gua","qin","hu","wu","liao","shi","ning","zhai","shen","wei","xie","kuan","hui","liao","jun","huan","yi","yi","bao","qin","chong","bao","feng","cun","dui","si","xun","dao","lu","dui","shou","po","feng","zhuan","fu","she","ke","jiang","jiang","zhuan","wei","zun","xun","shu","dui","dao","xiao","jie","shao","er","er","er","ga","jian","shu","chen","shang","shang","mo","ga","chang","liao","xian","xian","kun","you","wang","you","liao","liao","yao","mang","wang","wang","wang","ga","yao","duo","kui","zhong","jiu","gan","gu","gan","tui","gan",
"gan","shi","yin","chi","kao","ni","jin","wei","niao","ju","pi","ceng","xi","bi","ju","jie","tian","qu","ti","jie","wu","diao","shi","shi","ping","ji","xie","zhen","xie","ni","zhan","xi","wei","man","e","lou","ping","ti","fei","shu","xie","tu","lu","lu","xi","ceng","lu","ju","xie","ju","jue","liao","jue","shu","xi","che","tun","ni","shan","wa","xian","li","e","dao","hui","long","yi","qi","ren","wu","han","shen","yu","chu","sui","qi","ren","yue","ban","yao","ang","ya","wu","jie","e","ji","qian","fen","wan","qi","cen","qian","qi","cha","jie","qu","gang","xian","ao","lan","dao","ba","zuo","zuo","yang","ju","gang","ke","gou","xue","po","li","tiao","qu","yan","fu","xiu","jia","ling","tuo","pi","ao","dai","kuang","yue","qu","hu","po","min",
"an","tiao","ling","chi","ping","dong","han","kui","xiu","mao","tong","xue","yi","bian","he","ba","luo","e","fu","xun","die","lu","en","er","gai","quan","dong","yi","mu","shi","an","wei","huan","zhi","mi","li","ji","tong","wei","you","gu","xia","li","yao","jiao","zheng","luan","jiao","e","e","yu","xie","bu","qiao","qun","feng","feng","nao","li","you","xian","hong","dao","shen","cheng","tu","geng","jun","hao","xia","yin","yu","lang","kan","lao","lai","xian","que","kong","chong","chong","ta","lin","hua","ju","lai","qi","min","kun","kun","zu","gu","cui","ya","ya","gang","lun","lun","leng","jue","duo","zheng","guo","yin","dong","han","zheng","wei","xiao","pi","yan","song","jie","beng","zu","ku","dong","zhan","gu","yin","zi","ze","huang","yu","wai","yang","feng","qiu","yang",
"ti","yi","zhi","shi","zai","yao","e","zhu","kan","lu","yan","mei","han","ji","ji","huan","ting","sheng","mei","qian","wu","yu","zong","lan","ke","yan","yan","wei","zong","cha","sui","rong","ke","qin","yu","ti","lou","tu","dui","xi","weng","cang","dang","rong","jie","kai","liu","wu","song","qiao","zi","wei","beng","dian","cuo","qian","yong","nie","cuo","ji","shi","ruo","song","zong","jiang","liao","kang","chan","die","cen","ding","tu","lou","zhang","zhan","zhan","ao","cao","qu","qiang","cui","zui","dao","dao","xi","yu","pei","long","xiang","ceng","bo","qin","jiao","yan","lao","zhan","lin","liao","liao","jin","deng","duo","zun","jiao","gui","yao","jiao","yao","jue","zhan","yi","xue","nao","ye","ye","yi","nie","xian","ji","xie","ke","xi","di","ao","zui","wei","yi","rong","dao",
"ling","za","yu","yue","yin","ru","jie","li","gui","long","long","dian","rong","xi","ju","chan","ying","kui","yan","wei","nao","quan","chao","cuan","luan","dian","dian","nie","yan","yan","yan","kui","yan","chuan","kuai","chuan","zhou","huang","jing","xun","chao","chao","lie","gong","zuo","qiao","ju","gong","ju","wu","pu","pu","cha","qiu","qiu","ji","yi","si","ba","zhi","zhao","xiang","yi","jin","xun","juan","ba","xun","jin","fu","za","bi","shi","bu","ding","shuai","fan","nie","shi","fen","pa","zhi","xi","hu","dan","wei","zhang","tang","dai","mo","pei","pa","tie","bo","lian","zhi","zhou","bo","zhi","di","mo","yi","yi","ping","qia","juan","ru","shuai","dai","zheng","shui","qiao","zhen","shi","qun","xi","bang","dai","gui","chou","ping","zhang","san","wan","dai","wei","chang","sha","qi",
"ze","guo","mao","du","hou","zheng","xu","mi","wei","wo","fu","yi","bang","ping","die","gong","pan","huang","tao","mi","jia","teng","hui","zhong","shan","man","mu","biao","guo","ze","mu","bang","zhang","jing","chan","fu","zhi","hu","fan","chuang","bi","bi","zhang","mi","qiao","chan","fen","meng","bang","chou","mie","chu","jie","xian","lan","gan","ping","nian","jian","bing","bing","xing","gan","yao","huan","you","you","ji","guang","pi","ting","ze","guang","zhuang","mo","qing","bi","qin","dun","chuang","gui","ya","bai","jie","xu","lu","wu","zhuang","ku","ying","di","pao","dian","ya","miao","geng","ci","fu","tong","pang","fei","xiang","yi","zhi","tiao","zhi","xiu","du","zuo","xiao","tu","gui","ku","mang","ting","you","bu","bing","cheng","lai","bi","ji","an","shu","kang","yong","tuo","song","shu",
"qing","yu","yu","miao","sou","ce","xiang","fei","jiu","e","gui","liu","sha","lian","lang","sou","zhi","pou","qing","jiu","jiu","jin","ao","kuo","lou","yin","liao","dai","lu","yi","chu","chan","tu","si","xin","miao","chang","wu","fei","guang","ku","kuai","bi","qiang","xie","lin","lin","liao","lu","ji","ying","xian","ting","yong","li","ting","yin","xun","yan","ting","di","pai","jian","hui","nai","hui","gong","nian","kai","bian","yi","qi","nong","fen","ju","yan","yi","zang","bi","yi","yi","er","san","shi","er","shi","shi","gong","diao","yin","hu","fu","hong","wu","tui","chi","jiang","ba","shen","di","zhang","jue","tao","fu","di","mi","xian","hu","chao","nu","jing","zhen","yi","mi","quan","wan","shao","ruo","xuan","jing","diao","zhang","jiang","qiang","peng","dan","qiang","bi","bi",
"she","dan","jian","gou","ge","fa","bi","kou","jian","bie","xiao","dan","guo","jiang","hong","mi","guo","wan","jue","ji","ji","gui","dang","lu","lu","tuan","hui","zhi","hui","hui","yi","yi","yi","yi","yue","yue","shan","xing","wen","tong","yan","yan","yu","chi","cai","biao","diao","bin","peng","yong","piao","zhang","ying","chi","chi","zhuo","tuo","ji","fang","zhong","yi","wang","che","bi","di","ling","fu","wang","zheng","cu","wang","jing","dai","xi","xun","hen","yang","huai","lu","hou","wang","cheng","zhi","xu","jing","tu","cong","zhi","lai","cong","de","pai","xi","dong","ji","chang","zhi","cong","zhou","lai","yu","xie","jie","jian","shi","jia","bian","huang","fu","xun","wei","pang","yao","wei","xi","zheng","piao","ti","de","zheng","zheng","bie","de","chong","che","jiao","hui","jiao","hui",
"mei","long","xiang","bao","qu","xin","xin","bi","yi","le","ren","dao","ding","gai","ji","ren","ren","chan","tan","te","te","gan","qi","shi","cun","zhi","wang","mang","xi","fan","ying","tian","min","wen","zhong","chong","wu","ji","wu","xi","jia","you","wan","cong","song","kuai","yu","bian","zhi","qi","cui","chen","tai","tun","qian","nian","hun","xiong","niu","kuang","xian","xin","kang","hu","kai","fen","huai","tai","song","wu","ou","chang","chuang","ju","yi","bao","chao","min","pei","zuo","zen","yang","ju","ban","nu","nao","zheng","pa","bu","tie","hu","hu","ju","da","lian","si","chou","di","dai","yi","tu","you","fu","ji","peng","xing","yuan","ni","guai","fu","xi","bi","you","qie","xuan","cong","bing","huang","xu","chu","bi","shu","xi","tan","yong","zong","dui","mo","zhi",
"yi","shi","nen","xun","shi","xi","lao","heng","kuang","mou","zhi","xie","lian","tiao","huang","die","hao","kong","gui","heng","xi","jiao","shu","si","hu","qiu","yang","hui","hui","chi","jia","yi","xiong","guai","lin","hui","zi","xu","chi","shang","nu","hen","en","ke","dong","tian","gong","quan","xi","qia","yue","peng","ken","de","hui","e","xiao","tong","yan","kai","ce","nao","yun","mang","yong","yong","yuan","pi","kun","qiao","yue","yu","tu","jie","xi","zhe","lin","ti","han","hao","qie","ti","bu","yi","qian","hui","xi","bei","man","yi","heng","song","quan","cheng","kui","wu","wu","you","li","liang","huan","cong","yi","yue","li","nin","nao","e","que","xuan","qian","wu","min","cong","fei","bei","duo","cui","chang","men","san","ji","guan","guan","xing","dao","qi","kong","tian",
"lun","xi","kan","gun","ni","qing","chou","dun","guo","zhan","jing","wan","yuan","jin","ji","lan","yu","huo","he","quan","tan","ti","ti","nie","wang","chuo","hu","hun","xi","chang","xin","wei","hui","e","suo","zong","jian","yong","dian","ju","can","cheng","de","bei","qie","can","dan","guan","duo","nao","yun","xiang","zhui","die","huang","chun","qiong","re","xing","ce","bian","min","zong","ti","qiao","chou","bei","xuan","wei","ge","qian","wei","yu","yu","bi","xuan","huan","min","bi","yi","mian","yong","kai","dang","yin","e","chen","mao","qia","ke","yu","ai","qie","yan","nuo","gan","yun","zong","sai","leng","fen","ying","kui","kui","que","gong","yun","su","su","qi","yao","song","huang","ji","gu","ju","chuang","ni","xie","kai","zheng","yong","cao","xun","shen","bo","kai","yuan","xi",
"hun","yong","yang","li","sao","tao","yin","ci","xu","qian","tai","huang","yun","shen","ming","gong","she","cong","piao","mu","mu","guo","chi","can","can","can","cui","min","te","zhang","tong","ao","shuang","man","guan","que","zao","jiu","hui","kai","lian","ou","song","qin","yin","lu","shang","wei","tuan","man","qian","she","yong","qing","kang","di","zhi","lou","juan","qi","qi","yu","ping","liao","cong","you","chong","zhi","tong","cheng","qi","qu","peng","bei","bie","qiong","jiao","zeng","chi","lian","ping","kui","hui","qiao","cheng","yin","yin","xi","xi","dan","tan","duo","dui","dui","su","jue","ce","xiao","fan","fen","lao","lao","chong","han","qi","xian","min","jing","liao","wu","can","jue","cu","xian","tan","sheng","pi","yi","chu","xian","nao","dan","tan","jing","song","han","jiao","wei","xuan",
"dong","qin","qin","ju","cao","ken","xie","ying","ao","mao","yi","lin","se","jun","huai","men","lan","ai","lin","yan","kuo","xia","chi","yu","yin","dai","meng","ai","meng","dui","qi","mo","lan","men","chou","zhi","nuo","nuo","yan","yang","bo","zhi","kuang","kuang","you","fu","liu","mie","cheng","hui","chan","meng","lan","huai","xuan","rang","chan","ji","ju","huan","she","yi","lian","nan","mi","tang","jue","gang","gang","zhuang","ge","yue","wu","jian","xu","shu","rong","xi","cheng","wo","jie","ge","jian","qiang","huo","qiang","zhan","dong","qi","jia","die","zei","jia","ji","zhi","kan","ji","kui","gai","deng","zhan","qiang","ge","jian","jie","yu","jian","yan","lu","hu","zhan","xi","xi","chuo","dai","qu","hu","hu","hu","e","shi","ti","mao","hu","li","fang","suo","bian","dian",
"jiong","shang","yi","yi","shan","hu","fei","yan","shou","shou","cai","zha","qiu","le","pu","ba","da","reng","fan","ru","zai","tuo","zhang","diao","kang","yu","ku","gan","shen","cha","tuo","gu","kou","wu","den","qian","zhi","ren","kuo","men","sao","yang","niu","ban","che","rao","xi","qian","ban","jia","yu","fu","ao","xi","pi","zhi","zhi","e","den","zhao","cheng","ji","yan","kuang","bian","chao","ju","wen","hu","yue","jue","ba","qin","dan","zheng","yun","wan","ne","yi","shu","zhua","pou","tou","dou","kang","zhe","pou","fu","pao","ba","ao","ze","tuan","kou","lun","qiang","yun","hu","bao","bing","zhi","peng","tan","bu","pi","tai","yao","zhen","zha","yang","bao","he","ni","ye","di","chi","pi","jia","mo","mei","chen","ya","chou","qu","min","chu","jia","fu","zha",
"zhu","dan","chai","mu","nian","la","fu","pao","ban","pai","lin","na","guai","qian","ju","ta","ba","tuo","tuo","ao","ju","zhuo","pan","zhao","bai","bai","di","ni","ju","kuo","long","jian","qia","yong","lan","ning","bo","ze","qian","hen","kuo","shi","jie","zheng","nin","gong","gong","quan","shuan","cun","za","kao","yi","xie","ce","hui","pin","zhuai","shi","na","bai","chi","gua","zhi","kuo","duo","duo","zhi","qie","an","nong","zhen","ge","jiao","kua","dong","na","tiao","lie","zha","lu","die","wa","jue","lie","ju","zhi","luan","ya","wo","ta","xie","nao","dang","jiao","zheng","ji","hui","xian","yu","ai","tuo","nuo","cuo","bo","geng","ti","zhen","cheng","sa","sa","keng","mei","long","ju","peng","jian","yi","ting","shan","rua","wan","xie","cha","feng","jiao","wu","jun","jiu",
"tong","kun","huo","tu","zhuo","pou","lu","ba","han","shao","nie","juan","ze","shu","ye","jue","bu","wan","bu","zun","yi","zhai","lu","sou","tuo","lao","sun","bang","jian","huan","dao","wei","wan","qin","peng","she","lie","min","men","fu","bai","ju","dao","wo","ai","juan","yue","zong","chen","chui","jie","tu","ben","na","nian","ruo","zuo","wo","xi","xian","cheng","dian","sao","lun","qing","gang","duo","shou","diao","pou","di","zhang","hun","ji","tao","qia","qi","pai","shu","qian","ling","ye","ya","jue","zheng","liang","gua","yi","huo","shan","zheng","e","cai","tan","che","bing","jie","ti","kong","tui","yan","cuo","zhou","ju","tian","qian","ken","bai","pa","jie","lu","guai","ming","geng","zhi","dan","meng","can","sao","guan","peng","yuan","nuo","jian","zheng","jiu","jian","yu","yan",
"kui","nan","hong","rou","pi","wei","sai","zou","xuan","miao","ti","nie","cha","shi","zong","zhen","yi","xun","yong","bian","yang","huan","yan","zan","an","xu","ya","wo","ke","chuai","ji","ti","la","la","chen","kai","jiu","jiu","tu","jie","hui","gen","chong","xiao","die","xie","yuan","qian","ye","cha","zha","bei","yao","wei","beng","lan","wen","qin","chan","ge","lou","zong","geng","jiao","gou","qin","rong","que","chou","chuai","zhan","sun","sun","bo","chu","rong","bang","cuo","sao","ke","yao","dao","zhi","nu","la","jian","sou","qiu","gao","xian","shuo","sang","jin","mie","e","chui","nuo","shan","ta","zha","tang","pan","ban","da","li","tao","hu","zhi","wa","hua","qian","wen","qiang","tian","zhen","e","xie","nuo","quan","cha","zha","ge","wu","en","she","kang","she","shu","bai",
"yao","bin","sou","tan","sa","chan","suo","jiu","chong","chuang","guai","bing","feng","shuai","di","qi","sou","zhai","lian","cheng","chi","guan","lu","luo","lou","zong","gai","hu","zha","chuang","tang","hua","cui","nai","mo","jiang","gui","ying","zhi","ao","zhi","nie","man","chan","kou","chu","she","tuan","jiao","mo","mo","zhe","can","keng","biao","jiang","yin","gou","qian","liao","ji","ying","jue","pie","pie","lao","dun","xian","ruan","gui","zan","yi","xian","cheng","cheng","sa","nao","hong","si","han","guang","da","zun","nian","lin","zheng","hui","zhuang","jiao","ji","cao","dan","dan","che","bo","che","jue","fu","liao","ben","fu","qiao","bo","cuo","zhuo","zhuan","wei","pu","qin","dun","nian","hua","xie","lu","jiao","cuan","ta","han","qiao","wo","jian","gan","yong","lei","nang","lu","shan","zhuo","ze",
"pu","chuo","ji","dang","se","cao","qing","qing","huan","jie","qin","kuai","dan","xie","ka","pi","bai","ao","ju","ye","e","meng","sou","mi","ji","tai","zhuo","dao","xing","lan","ca","ju","ye","ru","ye","ye","ni","wo","ji","bin","ning","ge","zhi","zhi","kuo","mo","jian","xie","lie","tan","bai","sou","lu","lue","rao","ti","pan","yang","lei","ca","shu","zan","nian","xian","jun","huo","li","la","huan","ying","lu","long","qian","qian","zan","qian","lan","xian","ying","mei","rang","chan","ying","cuan","xie","she","luo","jun","mi","li","zan","luan","tan","zuan","li","dian","wa","dang","jiao","jue","lan","li","nang","zhi","gui","gui","qi","xun","pu","pu","shou","kao","you","gai","yi","gong","gan","ban","fang","zheng","po","dian","kou","min","wu","gu","he","ce","xiao",
"mi","chu","ge","di","xu","jiao","min","chen","jiu","shen","duo","yu","chi","ao","bai","xu","jiao","duo","lian","nie","bi","chang","dian","duo","yi","gan","san","ke","yan","dun","ji","tou","xiao","duo","jiao","jing","yang","xia","min","shu","ai","qiao","ai","zheng","di","zhen","fu","shu","liao","qu","xiong","yi","jiao","shan","jiao","zhuo","yi","lian","bi","li","xiao","xiao","wen","xue","qi","qi","zhai","bin","jue","zhai","lang","fei","ban","ban","lan","yu","lan","wei","dou","sheng","liao","jia","hu","xie","jia","yu","zhen","jiao","wo","tiao","dou","jin","chi","yin","fu","qiang","zhan","qu","zhuo","zhan","duan","cuo","si","xin","zhuo","zhuo","qin","lin","zhuo","chu","duan","zhu","fang","chan","hang","yu","shi","pei","you","mei","pang","qi","zhan","mao","lu","pei","pi","liu","fu",
"fang","xuan","jing","jing","ni","zu","zhao","yi","liu","shao","jian","yu","yi","qi","zhi","fan","piao","fan","zhan","kuai","sui","yu","wu","ji","ji","ji","huo","ri","dan","jiu","zhi","zao","xie","tiao","xun","xu","ga","la","gan","han","tai","di","xu","chan","shi","kuang","yang","shi","wang","min","min","tun","chun","wu","yun","bei","ang","ze","ban","jie","kun","sheng","hu","fang","hao","gui","chang","xuan","ming","hun","fen","qin","hu","yi","xi","xin","yan","ze","fang","tan","shen","ju","yang","zan","bing","xing","ying","xuan","po","zhen","ling","chun","hao","mei","zuo","mo","bian","xu","hun","zhao","zong","shi","shi","yu","fei","die","mao","ni","chang","wen","dong","ai","bing","ang","zhou","long","xian","kuang","tiao","chao","shi","huang","huang","xuan","kui","xu","jiao","jin","zhi",
"jin","shang","tong","hong","yan","gai","xiang","shai","xiao","ye","yun","hui","han","han","jun","wan","xian","kun","zhou","xi","cheng","sheng","bu","zhe","zhe","wu","han","hui","hao","chen","wan","tian","zhuo","zui","zhou","pu","jing","xi","shan","ni","xi","qing","qi","jing","gui","zheng","yi","zhi","an","wan","lin","liang","chang","wang","xiao","zan","fei","xuan","geng","yi","xia","yun","hui","xu","min","kui","ye","ying","shu","wei","shu","qing","mao","nan","jian","nuan","an","yang","chun","yao","suo","jin","ming","jiao","kai","gao","weng","chang","qi","hao","yan","li","ai","ji","ji","men","zan","xie","hao","mu","mo","cong","ni","zhang","hui","bao","han","xuan","chuan","liao","xian","dan","jing","pie","lin","tun","xi","yi","ji","huang","dai","ye","ye","li","tan","tong","xiao","fei","shen",
"zhao","hao","yi","xiang","xing","shen","jiao","bao","jing","yan","ai","ye","ru","shu","meng","xun","yao","pu","li","chen","kuang","die","liao","yan","huo","lu","xi","rong","long","nang","luo","luan","shai","tang","yan","zhu","yue","yue","qu","ye","geng","ye","hu","he","shu","cao","cao","sheng","man","ceng","ceng","ti","zui","can","xu","hui","yin","qie","fen","pi","yue","you","ruan","peng","fen","fu","ling","fei","qu","ti","nu","tiao","shuo","zhen","lang","lang","zui","ming","huang","wang","tun","chao","ji","qi","ying","zong","wang","tong","lang","lao","meng","long","mu","deng","wei","mo","ben","zha","shu","shu","mu","zhu","ren","ba","pu","duo","duo","dao","li","gui","ji","jiu","bi","xiu","cheng","ci","sha","ru","za","quan","qian","yu","gan","wu","cha","shan","xun","fan","wu",
"zi","li","xing","cai","cun","ren","biao","tuo","di","zhang","mang","chi","yi","gai","gong","du","li","qi","shu","gang","tiao","jiang","shan","wan","lai","jiu","mang","yang","ma","miao","si","yuan","hang","fei","bei","jie","dong","gao","yao","xian","chu","chun","pa","shu","hua","xin","chou","zhu","chou","song","ban","song","ji","wo","jin","gou","ji","mao","pi","bi","wang","ang","fang","fen","yi","fu","nan","xi","hu","ya","dou","xin","zhen","yao","lin","rui","e","mei","zhao","guo","zhi","cong","yun","zui","dou","shu","zao","duo","li","lu","jian","cheng","song","qiang","feng","nan","xiao","xian","ku","ping","tai","xi","zhi","guai","xiao","jia","jia","gou","bao","mo","yi","ye","ye","shi","nie","bi","duo","yi","ling","bing","ni","la","he","ban","fan","zhong","dai","ci","yang",
"fu","bai","mou","gan","qi","ran","rou","mao","shao","song","zhe","xia","you","shen","gui","tuo","zha","nan","ning","yong","di","zhi","zha","cha","dan","gu","bu","jiu","ao","fu","jian","ba","duo","ke","nai","zhu","bi","liu","chai","shan","si","chu","pei","shi","guai","zha","yao","cheng","jiu","shi","zhi","liu","mei","li","rong","zha","zao","biao","zhan","zhi","long","dong","lu","sheng","li","lan","yong","shu","xun","shuan","qi","zhen","qi","li","yi","xiang","zhen","li","se","gua","kan","ben","ren","xiao","bai","ren","bing","zi","chou","yi","ci","xu","zhu","jian","zui","er","er","you","fa","gong","kao","lao","zhan","lie","yin","yang","he","gen","yi","shi","ge","zai","luan","fu","jie","heng","gui","tao","guang","wei","kuang","ru","an","an","juan","yi","zhuo","ku","zhi",
"qiong","tong","sang","sang","huan","ju","jiu","xue","duo","zhui","yu","zan",0,"ying","jie","liu","zhan","ya","rao","zhen","dang","qi","qiao","hua","gui","jiang","zhuang","xun","suo","sha","zhen","bei","ting","kuo","jing","po","ben","fu","rui","tong","jue","xi","lang","liu","feng","qi","wen","jun","gan","su","liang","qiu","ting","you","mei","bang","long","peng","zhuang","di","xuan","tu","zao","ao","gu","bi","di","han","zi","zhi","ren","bei","geng","jian","huan","wan","nuo","jia","tiao","ji","xiao","lu","hun","shao","cen","fen","song","meng","wu","li","li","dou","qin","ying","suo","ju","ti","xie","kun","zhuo","shu","chan","fan","wei","jing","li","bin","xia","fo","tao","zhi","lai","lian","jian","zhuo","ling","li","qi","bing","lun","cong","qian","mian","qi","qi","cai","gun","chan","de",
"fei","pai","bang","bang","hun","zong","cheng","zao","ji","li","peng","yu","yu","gu","jun","dong","tang","gang","wang","di","cuo","fan","cheng","zhan","qi","yuan","yan","yu","quan","yi","sen","ren","chui","leng","qi","zhuo","fu","ke","lai","zou","zou","zhao","guan","fen","fen","shen","qing","ni","wan","guo","lu","hao","jie","yi","chou","ju","ju","cheng","zuo","liang","qiang","zhi","chui","ya","ju","bei","jiao","zhuo","zi","bin","peng","ding","chu","chang","men","hua","jian","gui","xi","du","qian","dao","gui","dian","luo","zhi","quan","ming","fu","geng","peng","zhan","yi","tuo","sen","duo","ye","fu","wei","wei","duan","jia","zong","jian","yi","shen","xi","yan","yan","chuan","jian","chun","yu","he","zha","wo","pian","bi","yao","huo","xu","ruo","yang","la","yan","ben","hui","kui","jie",
"kui","si","feng","xie","tuo","zhi","jian","mu","mao","chu","hu","hu","lian","leng","ting","nan","yu","you","mei","song","xuan","xuan","yang","zhen","pian","ye","ji","jie","ye","chu","dun","yu","zou","wei","mei","ti","ji","jie","kai","qiu","ying","rou","huang","lou","le","quan","xiang","pin","shi","gai","tan","lan","wen","yu","chen","lu","ju","shen","chu","pi","xie","jia","yi","zhan","fu","nuo","mi","lang","rong","gu","jian","ju","ta","yao","zhen","bang","sha","yuan","zi","ming","su","jia","yao","jie","huang","gan","fei","zha","qian","ma","sun","yuan","xie","rong","shi","zhi","cui","yun","ting","liu","rong","tang","que","zhai","si","sheng","ta","ke","xi","gu","qi","gao","gao","sun","pan","tao","ge","xun","dian","nou","ji","shuo","gou","chui","qiang","cha","qian","huai","mei",
"xu","gang","gao","zhuo","tuo","qiao","yang","dian","jia","kan","zui","dao","long","bin","zhu","sang","xi","ji","lian","hui","yong","qian","guo","gai","gai","tuan","hua","qi","sen","cui","peng","you","hu","jiang","hu","huan","gui","nie","yi","gao","kang","gui","gui","cao","man","jin","di","zhuang","le","lang","chen","cong","li","xiu","qing","shuang","fan","tong","guan","ze","su","lei","lu","liang","mi","lou","chao","su","ke","chu","tang","biao","lu","jiu","zhe","zha","shu","zhang","man","mo","niao","yang","tiao","peng","zhu","sha","xi","quan","heng","jian","cong","ji","yan","qiang","xue","ying","er","xun","zhi","qiao","zui","cong","pu","shu","hua","kui","zhen","zun","yue","shan","xi","chun","dian","fa","gan","mo","wu","qiao","rao","lin","liu","qiao","xian","run","fan","zhan","tuo","lao","yun",
"shun","dun","cheng","tang","meng","ju","cheng","su","jue","jue","dian","hui","ji","nuo","xiang","tuo","ning","rui","zhu","tong","zeng","fen","qiong","ran","heng","qian","gu","liu","lao","gao","chu","xi","sheng","zi","san","ji","dou","jing","lu","jian","chu","yuan","ta","shu","jiang","tan","lin","nong","yin","xi","sui","shan","zui","xuan","cheng","gan","ju","zui","yi","qin","pu","yan","lei","feng","hui","dang","ji","sui","bo","ping","cheng","chu","zhua","gui","ji","jie","jia","qing","zhai","jian","qiang","dao","yi","biao","song","she","lin","li","cha","meng","yin","tao","tai","mian","qi","tuan","bin","huo","ji","qian","ni","ning","yi","gao","kan","yin","nou","qing","yan","qi","mi","zhao","gui","chun","ji","kui","po","deng","chu","ge","mian","you","zhi","huang","qian","lei","lei","sa","lu",
"li","cuan","lu","mie","hui","ou","lu","zhi","gao","du","yuan","li","fei","zhuo","sou","lian","jiang","chu","qing","zhu","lu","yan","li","zhu","chen","jie","e","su","huai","nie","yu","long","lai","jiao","xian","gui","ju","xiao","ling","ying","jian","yin","you","ying","xiang","nong","bo","chan","lan","ju","shuang","she","wei","cong","quan","qu","cang","jiu","yu","luo","li","cuan","luan","dang","jue","yan","lan","lan","zhu","lei","li","ba","nang","yu","ling","guang","qian","ci","huan","xin","yu","yi","qian","ou","xu","chao","chu","qi","kai","yi","jue","xi","xu","he","yu","kui","lang","kuan","shuo","xi","ai","yi","qi","chua","chi","qin","kuan","kan","kuan","kan","chuan","sha","gua","yin","xin","xie","yu","qian","xiao","ye","ge","wu","tan","jin","ou","hu","ti","huan","xu",
"pen","xi","xiao","chua","she","shan","han","chu","yi","e","yu","chuo","huan","zhi","zheng","ci","bu","wu","qi","bu","bu","wai","ju","qian","chi","se","chi","se","zhong","sui","sui","li","cuo","yu","li","gui","dai","e","si","jian","zhe","mo","mo","yao","mo","cu","yang","tian","sheng","dai","shang","xu","xun","shu","can","jue","piao","qia","qiu","su","qing","yun","lian","yi","fou","zhi","ye","can","hun","dan","ji","die","zhen","yun","wen","chou","bin","ti","jin","shang","yin","diao","jiu","hui","cuan","yi","dan","du","jiang","lian","bin","du","jian","jian","shu","ou","duan","zhu","yin","qing","yi","sha","qiao","ke","xiao","xun","dian","hui","hui","gu","qiao","ji","yi","ou","hui","duan","yi","xiao","wu","guan","mu","mei","mei","ai","jie","du","yu","bi","bi",
"bi","pi","pi","bi","chan","mao","hao","cai","pi","lie","jia","zhan","sai","mu","tuo","xun","er","rong","xian","ju","mu","hao","qiu","dou","sha","tan","pei","ju","duo","cui","bi","san","san","mao","sai","shu","yu","tuo","he","jian","ta","san","lu","mu","mao","tong","rong","chang","pu","lu","zhan","sao","zhan","meng","lu","qu","die","shi","di","min","jue","mang","qi","pie","nai","qi","dao","xian","chuan","fen","yang","nei","bin","fu","shen","dong","qing","qi","yin","xi","hai","yang","an","ya","ke","qing","ya","dong","dan","lu","qing","yang","yun","yun","shui","shui","zheng","bing","yong","dang","shui","le","ni","tun","fan","gui","ting","zhi","qiu","bin","ze","mian","cuan","hui","diao","han","cha","zhuo","chuan","wan","fan","da","xi","tuo","mang","qiu","qi","shan","pin",
"han","qian","wu","wu","xun","si","ru","gong","jiang","chi","wu","tu","jiu","tang","zhi","zhi","qian","mi","gu","wang","jing","jing","rui","jun","hong","tai","quan","ji","bian","bian","gan","wen","zhong","fang","xiong","jue","hu","niu","qi","fen","xu","xu","qin","yi","wo","yun","yuan","hang","yan","chen","chen","dan","you","dun","hu","huo","qi","mu","nu","mei","da","mian","mi","chong","pang","bi","sha","zhi","pei","pan","zhui","za","gou","liu","mei","ze","feng","ou","li","lun","cang","feng","wei","hu","mo","mei","shu","ju","zan","tuo","tuo","tuo","he","li","mi","yi","fa","fei","you","tian","zhi","zhao","gu","zhan","yan","si","kuang","jiong","ju","xie","qiu","yi","jia","zhong","quan","po","hui","mi","ben","ze","zhu","le","you","gu","hong","gan","fa","mao","si",
"hu","ping","ci","fan","zhi","su","ning","cheng","ling","pao","bo","qi","si","ni","ju","sa","zhu","sheng","lei","xuan","jue","fu","pan","min","tai","yang","ji","yong","guan","beng","xue","long","lu","dan","luo","xie","po","ze","jing","yin","pan","jie","yi","hui","hui","zai","cheng","yin","wei","hou","jian","yang","lie","si","ji","er","xing","fu","sa","se","zhi","yin","wu","xi","kao","zhu","jiang","luo","luo","an","dong","ti","mou","lei","yi","mi","quan","jin","po","wei","xiao","xie","hong","xu","su","kuang","tao","qie","ju","er","zhou","ru","ping","xun","xiong","zhi","guang","huan","ming","huo","wa","qia","pai","wu","qu","liu","yi","jia","jing","qian","jiang","jiao","zhen","shi","zhuo","ce","fa","hui","ji","liu","chan","hun","hu","nong","xun","jin","lie","qiu","wei",
"zhe","jun","han","bang","mang","zhuo","you","xi","bo","dou","huan","hong","yi","pu","ying","lan","hao","lang","han","li","geng","fu","wu","lian","chun","feng","yi","yu","tong","lao","hai","jin","jia","chong","jiong","mei","sui","cheng","pei","xian","shen","tu","kun","ping","nie","han","jing","xiao","she","nian","tu","yong","xiao","xian","ting","e","su","tun","juan","cen","ti","li","shui","si","lei","shui","tao","du","lao","lai","lian","wei","wo","yun","huan","di","heng","run","jian","zhang","se","fu","guan","xing","shou","shuan","ya","chuo","zhang","ye","kong","wo","han","tuo","dong","he","wo","ju","she","liang","hun","ta","zhuo","dian","qie","de","juan","zi","xi","xiao","qi","gu","guo","yan","lin","tang","zhou","peng","hao","chang","shu","qi","fang","zhi","lu","nao","ju","tao","cong",
"lei","zhe","ping","fei","song","tian","pi","dan","yu","ni","yu","lu","gan","mi","jing","ling","lun","yin","cui","qu","huai","yu","nian","shen","biao","chun","hu","yuan","lai","hun","qing","yan","qian","tian","miao","zhi","yin","mi","ben","yuan","wen","ruo","fei","qing","yuan","ke","ji","she","yuan","se","lu","zi","du","qi","jian","mian","pi","xi","yu","yuan","shen","shen","rou","huan","zhu","jian","nuan","yu","qiu","ting","qu","du","fan","zha","bo","wo","wo","di","wei","wen","ru","xie","ce","wei","he","gang","yan","hong","xuan","mi","ke","mao","ying","yan","you","hong","miao","sheng","mei","zai","hun","nai","gui","chi","e","pai","mei","lian","qi","qi","mei","tian","cou","wei","can","tuan","mian","hui","mo","xu","ji","pen","jian","jian","hu","feng","xiang","yi","yin",
"zhan","shi","jie","cheng","huang","tan","yu","bi","min","shi","tu","sheng","yong","ju","dong","tuan","jiao","jiao","qiu","yan","tang","long","huo","yuan","nan","ban","you","quan","zhuang","liang","chan","yan","chun","nie","zi","wan","shi","man","ying","la","kui","feng","jian","xu","lou","wei","gai","xia","ying","po","jin","yan","tang","yuan","suo","yuan","lian","yao","meng","zhun","cheng","ke","tai","ta","wa","liu","gou","sao","ming","zha","shi","yi","lun","ma","pu","wei","li","cai","wu","xi","wen","qiang","ze","shi","su","ai","qin","sou","yun","xiu","yin","rong","hun","su","suo","ni","ta","shi","ru","ai","pan","chu","chu","pang","weng","cang","mie","ge","dian","hao","huang","xi","zi","di","zhi","xing","fu","jie","hua","ge","zi","tao","teng","sui","bi","jiao","hui","gun","yin",
"gao","long","zhi","yan","she","man","ying","chun","lu","lan","luan","xiao","bin","tan","yu","xiu","hu","bi","biao","zhi","jiang","kou","shen","shang","di","mi","ao","lu","hu","hu","you","chan","fan","yong","gun","man","qing","yu","piao","ji","ya","chao","qi","xi","ji","lu","lou","long","jin","guo","cong","lou","zhi","gai","qiang","li","yan","cao","jiao","cong","chun","tuan","ou","teng","ye","xi","mi","tang","mo","shang","han","lian","lan","wa","chi","gan","feng","xuan","yi","man","zi","mang","kang","luo","peng","shu","zhang","zhang","zhuang","xu","huan","huo","jian","yan","shuang","liao","cui","ti","yang","jiang","cong","ying","hong","xun","shu","guan","ying","xiao","zong","kun","xu","lian","zhi","wei","pi","yu","jiao","po","dang","hui","jie","wu","pa","ji","pan","wei","su","qian","qian",
"xi","lu","xi","xun","dun","huang","min","run","su","lao","zhen","cong","yi","zhe","wan","shan","tan","chao","xun","kui","ye","shao","tu","zhu","sa","hei","bi","shan","chan","chan","shu","tong","pu","lin","wei","se","se","cheng","jiong","cheng","hua","jiao","lao","che","gan","cun","hong","si","shu","peng","han","yun","liu","hong","fu","hao","he","xian","jian","shan","xi","yu","lu","lan","ning","yu","lin","mian","zao","dang","huan","ze","xie","yu","li","shi","xue","ling","wan","zi","yong","hui","can","lian","dian","ye","ao","huan","zhen","chan","man","dan","dan","yi","sui","pi","ju","ta","qin","ji","zhuo","lian","nong","guo","jin","fen","se","ji","sui","hui","chu","ta","song","ding","se","zhu","lai","bin","lian","mi","shi","shu","mi","ning","ying","ying","meng","jin","qi",
"bi","ji","hao","ru","cui","wo","tao","yin","yin","dui","ci","huo","jing","lan","jun","ai","pu","zhuo","wei","bin","gu","qian","ying","bin","kuo","fei","cang","me","jian","wei","luo","zan","lu","li","you","yang","lu","si","zhi","ying","du","wang","hui","xie","pan","shen","biao","chan","mo","liu","jian","pu","se","cheng","gu","bin","huo","xian","lu","qin","han","ying","rong","li","jing","xiao","ying","sui","wei","xie","huai","xue","zhu","long","lai","dui","fan","hu","lai","shu","ling","ying","mi","ji","lian","jian","ying","fen","lin","yi","jian","yue","chan","dai","rang","jian","lan","fan","shuang","yuan","zhuo","feng","she","lei","lan","cong","qu","yong","qian","fa","guan","que","yan","hao","ying","sa","zan","luan","yan","li","mi","shan","tan","dang","jiao","chan","ying","hao","ba",
"zhu","lan","lan","nang","wan","luan","xun","xian","yan","gan","yan","yu","huo","biao","mie","guang","deng","hui","xiao","xiao","hui","hong","ling","zao","zhuan","jiu","zha","xie","chi","zhuo","zai","zai","can","yang","qi","zhong","fen","niu","jiong","wen","po","yi","lu","chui","pi","kai","pan","yan","kai","pang","mu","chao","liao","gui","kang","dun","guang","xin","zhi","guang","guang","wei","qiang","bian","da","xia","zheng","zhu","ke","zhao","fu","ba","xie","duo","ling","zhuo","xuan","ju","tan","pao","jiong","pao","tai","tai","bing","yang","tong","han","zhu","zha","dian","wei","shi","lian","chi","huang","zhou","hu","shuo","lan","ting","jiao","xu","heng","quan","lie","huan","yang","xiu","xiu","xian","yin","wu","zhou","yao","shi","wei","tong","mie","zai","kai","hong","lao","xia","zhu","xuan","zheng","po","yan",
"hui","guang","che","hui","kao","chen","fan","shao","ye","hui",0,"tang","jin","re","lie","xi","fu","jiong","xie","pu","ting","zhuo","ting","wan","hai","peng","lang","yan","xu","feng","chi","rong","hu","xi","shu","he","xun","ku","juan","xiao","xi","yan","han","zhuang","jun","di","xie","ji","wu","yan","lu","han","yan","huan","men","ju","dao","bei","fen","lin","kun","hun","tun","xi","cui","wu","hong","chao","fu","wo","jiao","cong","feng","ping","qiong","ruo","xi","qiong","xin","chao","yan","yan","yi","jue","yu","gang","ran","pi","xiong","wang","sheng","chang","shao","xiong","nian","geng","wei","chen","he","kui","zhong","duan","xia","hui","feng","lian","xuan","xing","huang","jiao","jian","bi","ying","zhu","wei","tuan","shan","xi","nuan","nuan","chan","yan","jiong","jiong","yu","mei","sha","wei","zha",
"xin","qiong","rou","mei","huan","xu","zhao","wei","fan","qiu","sui","yang","lie","zhu","jie","gao","gua","bao","hu","yun","xia","shi","liang","bian","gou","tui","tang","chao","shan","en","bo","huang","xie","xi","wu","xi","yun","he","he","xi","yun","xiong","nai","shan","qiong","yao","xun","mi","lian","ying","wu","rong","gong","yan","qiang","liu","xi","bi","biao","cong","lu","jian","shu","yi","lou","peng","sui","yi","teng","jue","zong","yun","hu","yi","zhi","ao","wei","liu","han","ou","re","jiong","man","kun","shang","cuan","zeng","jian","xi","xi","xi","yi","xiao","chi","huang","chan","ye","tan","ran","yan","xian","qiao","jun","deng","dun","shen","jiao","fen","si","liao","yu","lin","tong","shao","fen","fan","yan","xun","lan","mei","tang","yi","jing","men","jing","jiao","ying","yu","yi",
"xue","lan","tai","zao","can","sui","xi","que","cong","lian","hui","zhu","xie","ling","wei","yi","xie","zhao","hui","da","nong","lan","ru","xian","kao","xun","jin","chou","dao","yao","he","lan","biao","rong","li","mo","bao","ruo","lu","la","ao","xun","kuang","shuo","liao","li","lu","jue","liao","yan","xi","xie","long","ye","can","rang","yue","lan","cong","jue","chong","guan","ju","che","mi","tang","lan","zhu","lan","ling","cuan","yu","zhao","zhao","pa","zheng","pao","cheng","yuan","ai","wei","han","jue","jue","fu","ye","ba","die","ye","yao","zu","shuang","er","pan","chuang","ke","zang","die","qiang","yong","qiang","pian","ban","pan","chao","jian","pai","du","chuang","yu","zha","bian","die","bang","bo","chuang","you","you","du","ya","cheng","niu","niu","pin","jiu","mou","ta","mu","lao",
"ren","mang","fang","mao","mu","gang","wu","yan","ge","bei","si","jian","gu","you","ge","sheng","mu","di","qian","quan","quan","zi","te","xi","mang","keng","qian","wu","gu","xi","li","li","pou","ji","gang","zhi","ben","quan","chun","du","ju","jia","jian","feng","pian","ke","ju","kao","chu","xi","bei","luo","jie","ma","san","wei","mao","dun","tong","qiao","jiang","xi","li","du","lie","pai","piao","bo","xi","chou","wei","kui","chou","quan","quan","ba","fan","qiu","ji","cai","zhuo","an","ge","zhuang","guang","ma","you","kang","bo","hou","ya","yin","huan","zhuang","yun","kuang","niu","di","qing","zhong","mu","bei","pi","ju","yi","sheng","pao","xia","tuo","hu","ling","fei","pi","ni","yao","you","gou","xue","ju","dan","bo","ku","xian","ning","huan","hen","jiao","he","zhao",
"ji","xun","shan","ta","rong","shou","tong","lao","du","xia","shi","kuai","zheng","yu","sun","yu","bi","mang","xi","juan","li","xia","yin","suan","lang","bei","zhi","yan","sha","li","han","xian","jing","pai","fei","xiao","bai","qi","ni","biao","yin","lai","lie","jian","qiang","kun","yan","guo","zong","mi","chang","yi","zhi","zheng","ya","meng","cai","cu","she","lie","dian","luo","hu","zong","gui","wei","feng","wo","yuan","xing","zhu","mao","wei","chuan","xian","tuan","ya","nao","xie","jia","hou","bian","you","you","mei","cha","yao","sun","bo","ming","hua","yuan","sou","ma","yuan","dai","yu","shi","hao","qiang","yi","zhen","cang","hao","man","jing","jiang","mo","zhang","chan","ao","ao","hao","cui","ben","jue","bi","bi","huang","pu","lin","xu","tong","yao","liao","shuo","xiao","shou","dun",
"jiao","ge","juan","du","hui","kuai","xian","xie","ta","xian","xun","ning","pin","huo","nou","meng","lie","nao","guang","shou","lu","ta","xian","mi","rang","huan","nao","luo","xian","qi","jue","xuan","miao","zi","lu","lu","yu","su","wang","qiu","ga","ding","le","ba","ji","hong","di","chuan","gan","jiu","yu","qi","yu","chang","ma","gong","wu","fu","wen","jie","ya","bin","bian","bang","yue","jue","men","jue","wan","jian","mei","dan","pin","wei","huan","xian","qiang","ling","dai","yi","an","ping","dian","fu","xuan","xi","bo","ci","gou","jia","shao","po","ci","ke","ran","sheng","shen","yi","zu","jia","min","shan","liu","bi","zhen","zhen","jue","fa","long","jin","jiao","jian","li","guang","xian","zhou","gong","yan","xiu","yang","xu","luo","su","zhu","qin","yin","xun","bao","er",
"xiang","yao","xia","hang","gui","chong","xu","ban","pei","lao","dang","ying","hui","wen","e","cheng","di","wu","wu","cheng","jun","mei","bei","ting","xian","chu","han","xuan","yan","qiu","xuan","lang","li","xiu","fu","liu","ya","xi","ling","li","jin","lian","suo","suo","feng","wan","dian","pin","zhan","se","min","yu","ju","chen","lai","wen","sheng","wei","tian","chu","zuo","beng","cheng","hu","qi","e","kun","chang","qi","beng","wan","lu","cong","guan","yan","diao","bei","lin","qin","pi","pa","que","zhuo","qin","fa","jin","qiong","du","jie","hun","yu","mao","mei","chun","xuan","ti","xing","dai","rou","min","jian","wei","ruan","huan","xie","chuan","jian","zhuan","chang","lian","quan","xia","duan","yuan","ya","nao","hu","ying","yu","huang","rui","se","liu","shi","rong","suo","yao","wen","wu",
"zhen","jin","ying","ma","tao","liu","tang","li","lang","gui","zhen","qiang","cuo","jue","zhao","yao","ai","bin","shu","chang","kun","zhuan","cong","jin","yi","cui","cong","qi","li","ying","suo","qiu","xuan","ao","lian","men","zhang","yin","hua","ying","wei","lu","wu","deng","xiu","zeng","xun","qu","dang","lin","liao","qiong","su","huang","gui","pu","jing","fan","jin","liu","ji","hui","jing","ai","bi","can","qu","zao","dang","jiao","gun","tan","hui","huan","se","sui","tian","chu","yu","jin","lu","bin","shu","wen","zui","lan","xi","zi","xuan","ruan","wo","gai","lei","du","li","zhi","rou","li","zan","qiong","ti","gui","sui","la","long","lu","li","zan","lan","ying","mi","xiang","qiong","guan","dao","zan","huan","gua","bo","die","bo","hu","zhi","piao","ban","rang","li","wa",0,
"xiang","qian","ban","pen","fang","dan","weng","ou",0,0,"wa","hu","ling","yi","ping","ci","bai","juan","chang","chi",0,"dang","meng","bu","zhui","ping","bian","zhou","zhen",0,"ci","ying","qi","xian","lou","di","ou","meng","zhuan","beng","lin","zeng","wu","pi","dan","weng","ying","yan","gan","dai","shen","tian","tian","han","chang","sheng","qing","shen","chan","chan","rui","sheng","su","shen","yong","shuai","lu","fu","yong","beng","feng","ning","tian","you","jia","shen","zha","dian","fu","nan","dian","ping","ting","hua","ting","zhen","zai","meng","bi","qi","liu","xun","liu","chang","mu","yun","fan","fu","geng","tian","jie","jie","quan","wei","fu","tian","mu","duo","pan","jiang","wa","da","nan","liu","ben","zhen","chu","mu","mu","ce","tian","gai","bi","da","zhi","e","qi","lue","pan",
"yi","fan","hua","she","yu","mu","jun","yi","liu","she","die","chou","hua","dang","zhui","ji","wan","jiang","cheng","chang","tun","lei","ji","cha","liu","die","tuan","lin","jiang","jiang","chou","pi","die","die","pi","jie","dan","shu","shu","zhi","yi","ne","nai","ding","bi","jie","liao","gang","ge","jiu","zhou","xia","shan","xu","nue","li","yang","chen","you","ba","jie","jue","qi","xia","cui","bi","yi","li","zong","chuang","feng","zhu","pao","pi","gan","ke","ci","xue","zhi","dan","zhen","fa","zhi","teng","ju","ji","fei","ju","shan","jia","xuan","zha","bing","nie","zheng","yong","jing","quan","teng","tong","yi","jie","wei","hui","tan","yang","chi","zhi","hen","ya","mei","dou","jing","xiao","tong","tu","mang","pi","xiao","suan","fu","li","zhi","cuo","duo","wu","sha","lao","shou",
"huan","xian","yi","beng","zhang","guan","tan","fei","ma","lin","chi","ji","tian","an","chi","bi","bi","min","gu","dui","e","wei","yu","cui","ya","zhu","cu","dan","shen","zhong","chi","yu","hou","feng","la","yang","chen","tu","yu","guo","wen","huan","ku","jia","yin","yi","lou","sao","jue","chi","xi","guan","yi","wen","ji","chuang","ban","hui","liu","chai","shou","nue","dian","da","bie","tan","zhang","biao","shen","cu","luo","yi","zong","chou","zhang","zhai","sou","se","que","diao","lou","lou","mo","qin","yin","ying","huang","fu","liao","long","qiao","liu","lao","xian","fei","dan","yin","he","ai","ban","xian","guan","gui","nong","yu","wei","yi","yong","pi","lei","li","shu","dan","lin","dian","lin","lai","bie","ji","chi","yang","xuan","jie","zheng","me","li","huo","lai","ji",
"dian","xuan","ying","yin","qu","yong","tan","dian","luo","luan","luan","bo","bo","gui","ba","fa","deng","fa","bai","bai","qie","ji","zao","zao","mao","de","pa","jie","huang","gui","ci","ling","gao","mo","ji","jiao","peng","gao","ai","e","hao","han","bi","wan","chou","qian","xi","ai","xiao","hao","huang","hao","ze","cui","hao","xiao","ye","po","hao","jiao","ai","xing","huang","li","piao","he","jiao","pi","gan","pao","zhou","jun","qiu","cun","que","zha","gu","jun","jun","zhou","zha","gu","zhao","du","min","qi","ying","yu","bei","zhao","zhong","pen","he","ying","he","yi","bo","wan","he","ang","zhan","yan","jian","he","yu","kui","fan","gai","dao","pan","fu","qiu","sheng","dao","lu","zhan","meng","li","jin","xu","jian","pan","guan","an","lu","xu","zhou","dang","an",
"gu","li","mu","ding","gan","xu","mang","wang","zhi","qi","yuan","tian","xiang","dun","xin","xi","pan","feng","dun","min","ming","sheng","shi","yun","mian","pan","fang","miao","dan","mei","mao","kan","xian","kou","shi","yang","zheng","yao","shen","huo","da","zhen","kuang","ju","shen","yi","sheng","mei","mo","zhu","zhen","zhen","mian","shi","yuan","die","ni","zi","zi","chao","zha","xuan","bing","mi","long","sui","tong","mi","die","di","ne","ming","xuan","chi","kuang","juan","mou","zhen","tiao","yang","yan","mo","zhong","mo","zhe","zheng","mei","suo","shao","han","huan","di","cheng","cuo","juan","e","man","xian","xi","kun","lai","jian","shan","tian","gun","wan","leng","shi","qiong","lie","ya","jing","zheng","li","lai","sui","juan","shui","sui","du","bi","pi","mu","hun","ni","lu","yi","jie","cai",
"zhou","yu","hun","ma","xia","xing","hui","gun","zai","chun","jian","mei","du","hou","xuan","tian","kui","gao","rui","mao","xu","fa","wo","miao","chou","kui","mi","weng","kou","dang","chen","ke","sou","xia","qiong","mo","ming","man","shui","ze","zhang","yi","diao","kou","mo","shun","cong","lou","chi","man","piao","cheng","gui","meng","huan","run","pie","xi","qiao","pu","zhu","deng","shen","shun","liao","che","xian","kan","ye","xu","tong","mou","lin","gui","jian","ye","ai","hui","zhan","jian","gu","zhao","qu","mei","chou","sao","ning","xun","yao","huo","meng","mian","pin","mian","li","kuang","jue","xuan","mian","huo","lu","meng","long","guan","man","xi","chu","tang","kan","zhu","mao","jin","lin","yu","shuo","ze","jue","shi","yi","shen","zhi","hou","shen","ying","ju","zhou","jiao","cuo","duan",
"ai","jiao","zeng","yue","ba","shi","ding","qi","ji","zi","gan","wu","zhe","ku","gang","xi","fan","kuang","dang","ma","sha","dan","jue","li","fu","min","e","huo","kang","zhi","qi","kan","jie","bin","e","ya","pi","zhe","yan","sui","zhuan","che","dun","pan","yan","jin","feng","fa","mo","zha","ju","yu","ke","tuo","tuo","di","zhai","zhen","e","fu","mu","zhu","la","bian","nu","ping","peng","ling","pao","le","po","bo","po","shen","za","ai","li","long","tong","yong","li","kuang","chu","keng","quan","zhu","kuang","gui","e","nao","qia","lu","wei","ai","ge","xian","xing","yan","dong","peng","xi","lao","hong","shuo","xia","qiao","qing","wei","qiao","yi","keng","xiao","que","chan","lang","hong","yu","xiao","xia","mang","luo","yong","che","che","wo","liu","ying","mang","que",
"yan","sha","kun","yu","chi","hua","lu","chen","jian","nue","song","zhuo","keng","peng","yan","zhui","kong","cheng","qi","zong","qing","lin","jun","bo","ding","min","diao","jian","he","lu","ai","sui","que","leng","bei","yin","dui","wu","qi","lun","wan","dian","nao","bei","qi","chen","ruan","yan","die","ding","du","tuo","jie","ying","bian","ke","bi","wei","shuo","zhen","duan","xia","dang","ti","nao","peng","jian","di","tan","cha","tian","qi","dun","feng","xuan","que","que","ma","gong","nian","su","e","ci","liu","si","tang","bang","hua","pi","wei","sang","lei","cuo","tian","xia","xi","lian","pan","wei","yun","dui","zhe","ke","la","zhuan","qing","gun","zhuan","chan","qi","ao","peng","liu","lu","kan","chuang","chen","yin","lei","biao","qi","mo","qi","cui","zong","qing","chuo","lun","ji",
"shan","lao","qu","zeng","deng","jian","xi","lin","ding","tan","huang","pan","za","qiao","di","li","jian","jiao","xi","zhang","qiao","dun","jian","yu","zhui","he","ke","ze","lei","ke","chu","ye","que","dang","yi","jiang","pi","pi","yu","pin","e","ai","ke","jian","yu","ruan","meng","pao","ci","bo","yang","ma","ca","xian","kuang","lei","lei","zhi","li","li","fan","que","pao","ying","li","long","long","mo","bo","shuang","guan","lan","zan","yan","shi","shi","li","reng","she","yue","si","qi","ta","ma","xie","yao","xian","qi","qi","zhi","beng","dui","zhong","ren","yi","shi","you","zhi","tiao","fu","fu","mi","zu","zhi","suan","mei","zuo","qu","hu","zhu","shen","sui","ci","chai","mi","lu","yu","xiang","wu","tiao","piao","zhu","gui","xia","zhi","ji","gao","zhen","gao",
"shui","jin","shen","gai","kun","di","dao","huo","tao","qi","gu","guan","zui","ling","lu","bing","jin","dao","zhi","lu","chan","bei","zhe","hui","you","xi","yin","zi","huo","zhen","fu","yuan","wu","xian","yang","zhi","yi","mei","si","di","bei","zhuo","zhen","yong","ji","gao","tang","si","ma","ta","fu","xuan","qi","yu","xi","ji","si","chan","dan","gui","sui","li","nong","mi","dao","li","rang","yue","ti","zan","lei","rou","yu","yu","li","xie","qin","he","tu","xiu","si","ren","tu","zi","cha","gan","yi","xian","bing","nian","qiu","qiu","zhong","fen","hao","yun","ke","miao","zhi","jing","bi","zhi","yu","mi","ku","ban","pi","ni","li","you","zu","pi","bo","ling","mo","cheng","nian","qin","yang","zuo","zhi","zhi","shu","ju","zi","huo","ji","cheng","tong",
"zhi","huo","he","yin","zi","zhi","jie","ren","du","yi","zhu","hui","nong","fu","xi","kao","lang","fu","xun","shui","lu","kun","gan","jing","ti","cheng","tu","shao","shui","ya","lun","lu","gu","zuo","ren","zhun","bang","bai","ji","zhi","zhi","kun","leng","peng","ke","bing","chou","zui","yu","su","lue","xiang","yi","xi","bian","ji","fu","pi","nuo","jie","zhong","zong","xu","cheng","dao","wen","xian","zi","yu","ji","xu","zhen","zhi","dao","jia","ji","gao","gao","gu","rong","sui","rong","ji","kang","mu","can","mei","zhi","ji","lu","su","ji","ying","wen","qiu","se","he","yi","huang","qie","ji","sui","xiao","pu","jiao","zhuo","zhong","zui","lu","sui","nong","se","hui","rang","nuo","yu","pin","ji","tui","wen","cheng","huo","kuang","lu","biao","se","rang","zhuo","li",
"cuan","xue","wa","jiu","qiong","xi","qiong","kong","yu","shen","jing","yao","chuan","zhun","tu","lao","qie","zhai","yao","bian","bao","yao","bing","wa","zhu","jiao","qiao","diao","wu","gui","yao","zhi","chuang","yao","tiao","jiao","chuang","jiong","xiao","cheng","kou","cuan","wo","dan","ku","ke","zhuo","xu","su","guan","kui","dou","zhuo","xun","wo","wa","ya","yu","ju","qiong","yao","yao","tiao","chao","yu","tian","diao","ju","liao","xi","wu","kui","chuang","zhao","kuan","kuan","long","cheng","cui","piao","zao","cuan","qiao","qiong","dou","zao","long","qie","li","chu","shi","fu","qian","chu","hong","qi","hao","sheng","fen","shu","miao","qu","zhan","zhu","ling","long","bing","jing","jing","zhang","bai","si","jun","hong","tong","song","jing","diao","yi","shu","jing","qu","jie","ping","duan","shao","zhuan","ceng","deng",
"cun","wai","jing","kan","jing","zhu","zhu","le","peng","yu","chi","gan","mang","zhu","wan","du","ji","xiao","ba","suan","ji","qin","zhao","sun","ya","zhui","yuan","hu","hang","xiao","cen","bi","bi","jian","yi","dong","shan","sheng","da","di","zhu","na","chi","gu","li","qie","min","bao","tiao","si","fu","ce","ben","pei","da","zi","di","ling","ze","nu","fu","gou","fan","jia","gan","fan","shi","mao","po","ti","jian","qiong","long","min","bian","luo","gui","qu","chi","yin","yao","xian","bi","qiong","kuo","deng","xiao","jin","quan","sun","ru","fa","kuang","zhu","tong","ji","da","hang","ce","zhong","kou","lai","bi","shai","dang","zheng","ce","fu","yun","tu","pa","li","lang","ju","guan","jian","han","tong","xia","zhi","cheng","suan","shi","zhu","zuo","xiao","shao","ting","ce",
"yan","gao","kuai","gan","chou","kuang","gang","yun","o","qian","xiao","jian","pou","lai","zou","bi","bi","bi","ge","tai","guai","yu","jian","dao","gu","chi","zheng","qing","sha","zhou","lu","bo","ji","lin","suan","jun","fu","zha","gu","kong","qian","qian","jun","chui","guan","yuan","ce","zu","bo","ze","qie","tuo","luo","dan","xiao","ruo","jian","xuan","bian","sun","xiang","xian","ping","zhen","xing","hu","yi","zhu","yue","chun","lu","wu","dong","shuo","ji","jie","huang","xing","mei","fan","chuan","zhuan","pian","feng","zhu","huang","qie","hou","qiu","miao","qian","gu","kui","shi","lou","yun","he","tang","yue","chou","gao","fei","ruo","zheng","gou","nie","qian","xiao","cuan","long","peng","du","li","bi","zhuo","chu","shai","chi","zhu","qiang","long","lan","jian","bu","li","hui","bi","di","cong",
"yan","peng","can","zhuan","pi","piao","dou","yu","mie","tuan","ze","shai","gui","yi","hu","chan","kou","cu","ping","zao","ji","gui","su","lou","ce","lu","nian","suo","cuan","diao","suo","le","duan","liang","xiao","bo","mi","shai","dang","liao","dan","dian","fu","jian","min","kui","dai","jiao","deng","huang","sun","lao","zan","xiao","lu","shi","zan","qi","pai","qi","pai","gan","ju","du","lu","yan","bo","dang","sai","zhua","long","qian","lian","bu","zhou","lai","shi","lan","kui","yu","yue","hao","zhen","tai","ti","nie","chou","ji","yi","qi","teng","zhuan","zhou","fan","sou","zhou","qian","zhuo","teng","lu","lu","jian","tuo","ying","yu","lai","long","qie","lian","lan","qian","yue","zhong","qu","lian","bian","duan","zuan","li","si","luo","ying","yue","zhuo","yu","mi","di","fan","shen",
"zhe","shen","nu","he","lei","xian","zi","ni","cun","zhang","qian","zhai","bi","ban","wu","sha","kang","rou","fen","bi","cui","yin","zhe","chi","tai","hu","ba","li","gan","ju","po","mo","cu","zhan","zhou","li","su","tiao","li","xi","su","hong","tong","zi","ce","yue","zhou","lin","zhuang","bai","lao","fen","er","qu","he","liang","xian","fu","liang","can","jing","li","yue","lu","ju","qi","cui","bai","zhang","lin","zong","jing","guo","hua","san","san","tang","bian","rou","mian","hou","xu","zong","hu","jian","zan","ci","li","xie","fu","nuo","bei","gu","xiu","gao","tang","qiu","jia","cao","zhuang","tang","mi","san","fen","zao","kang","jiang","mo","san","san","nuo","xi","liang","jiang","kuai","bo","huan","shu","zong","xian","nuo","tuan","nie","li","zuo","di","nie","tiao","lan",
"mi","si","jiu","xi","gong","zheng","jiu","you","ji","cha","zhou","xun","yue","hong","yu","he","wan","ren","wen","wen","qiu","na","zi","tou","niu","fou","ji","shu","chun","pi","zhen","sha","hong","zhi","ji","fen","yun","ren","dan","jin","su","fang","suo","cui","jiu","za","ba","jin","fu","zhi","ci","zi","chou","hong","za","lei","xi","fu","xie","shen","bo","zhu","qu","ling","zhu","shao","gan","yang","fu","tuo","zhen","dai","chu","shi","zhong","xian","zu","jiong","ban","qu","mo","shu","zui","kuang","jing","ren","hang","xie","jie","zhu","chou","gua","bai","jue","kuang","hu","ci","huan","geng","tao","jie","ku","jiao","quan","gai","luo","xuan","beng","xian","fu","gei","dong","rong","tiao","yin","lei","xie","juan","xu","gai","die","tong","si","jiang","xiang","hui","jue","zhi","jian",
"juan","chi","mian","zhen","lu","cheng","qiu","shu","bang","tong","xiao","huan","qin","geng","xiu","ti","tou","xie","hong","xi","fu","ting","sui","dui","kun","fu","jing","hu","zhi","yan","jiong","feng","ji","xu","ren","zong","chen","duo","li","lu","liang","chou","quan","shao","qi","qi","zhun","qi","wan","qian","xian","shou","wei","qi","tao","wan","gang","wang","beng","zhui","cai","guo","cui","lun","liu","qi","zhan","bi","chuo","ling","mian","qi","qie","tian","zong","gun","zou","xi","zi","xing","liang","jin","fei","rui","min","yu","zong","fan","lu","xu","ying","shang","qi","xu","xiang","jian","ke","xian","ruan","mian","ji","duan","chong","di","min","miao","yuan","xie","bao","si","qiu","bian","huan","geng","cong","mian","wei","fu","wei","tou","gou","miao","xie","lian","zong","bian","yun","yin","ti",
"gua","zhi","yun","cheng","chan","dai","xia","yuan","zong","xu","ying","wei","geng","xuan","ying","jin","yi","zhui","ni","bang","gu","pan","zhou","jian","ci","quan","shuang","yun","xia","cui","xi","rong","tao","fu","yun","chen","gao","ru","hu","zai","teng","xian","su","zhen","zong","tao","huang","cai","bi","feng","cu","li","suo","yan","xi","zong","lei","juan","qian","man","zhi","lu","mu","piao","lian","mi","xuan","zong","ji","shan","sui","fan","lu","beng","yi","sao","mou","yao","qiang","hun","xian","ji","sha","xiu","ran","xuan","sui","qiao","zeng","zuo","zhi","shan","san","lin","yu","fan","liao","chuo","zun","jian","rao","chan","rui","xiu","hui","hua","zuan","xi","qiang","yun","da","sheng","hui","xi","se","jian","jiang","huan","zao","cong","xie","jiao","bi","dan","yi","nong","sui","yi","shai",
"xu","ji","bin","qian","lan","pu","xun","zuan","qi","peng","yao","mo","lei","xie","zuan","kuang","you","xu","lei","xian","chan","jiao","lu","chan","ying","cai","rang","xian","zui","zuan","luo","li","dao","lan","lei","lian","si","jiu","yu","hong","zhou","xian","ge","yue","ji","wan","kuang","ji","ren","wei","yun","hong","chun","pi","sha","gang","na","ren","zong","lun","fen","zhi","wen","fang","zhu","zhen","niu","shu","xian","gan","xie","fu","lian","zu","shen","xi","zhi","zhong","zhou","ban","fu","chu","shao","yi","jing","dai","bang","rong","jie","ku","rao","die","hang","hui","gei","xuan","jiang","luo","jue","jiao","tong","geng","xiao","juan","xiu","xi","sui","tao","ji","ti","ji","xu","ling","ying","xu","qi","fei","chuo","shang","gun","sheng","wei","mian","shou","beng","chou","tao","liu","quan",
"zong","zhan","wan","lu","zhui","zi","ke","xiang","jian","mian","lan","ti","miao","ji","yun","hui","si","duo","duan","bian","xian","gou","zhui","huan","di","lu","bian","min","yuan","jin","fu","ru","zhen","feng","cui","gao","chan","li","yi","jian","bin","piao","man","lei","ying","suo","mou","sao","xie","liao","shan","zeng","jiang","qian","qiao","huan","jiao","zuan","fou","xie","gang","fou","que","fou","qi","bo","ping","xiang","zhao","gang","ying","ying","qing","xia","guan","zun","tan","cang","qi","weng","ying","lei","tan","lu","guan","wang","wang","gang","wang","han","luo","luo","fu","mi","fa","gu","zhu","ju","mao","gu","min","gang","ba","gua","ti","juan","fu","shen","yan","zhao","zui","gua","zhuo","yu","zhi","an","fa","lan","shu","si","pi","ma","liu","ba","fa","li","chao","wei","bi",
"ji","zeng","chong","liu","ji","juan","mi","zhao","luo","pi","ji","ji","luan","yang","mi","qiang","da","mei","yang","you","you","fen","ba","gao","yang","gu","qiang","zang","gao","ling","yi","zhu","di","xiu","qiang","yi","xian","rong","qun","qun","qiang","huan","suo","xian","yi","yang","qiang","qian","yu","geng","jie","tang","yuan","xi","fan","shan","fen","shan","lian","lei","geng","nou","qiang","chan","yu","gong","yi","chong","weng","fen","hong","chi","chi","cui","fu","xia","ben","yi","la","yi","pi","ling","liu","zhi","qu","xi","xie","xiang","xi","xi","ke","qiao","hui","hui","xiao","sha","hong","jiang","di","cui","fei","dao","sha","chi","zhu","jian","xuan","chi","pian","zong","wan","hui","hou","he","he","han","ao","piao","yi","lian","hou","ao","lin","pen","qiao","ao","fan","yi","hui",
"xuan","dao","yao","lao","lao","kao","mao","zhe","qi","gou","gou","gou","die","die","er","shua","ruan","nai","nai","duan","lei","ting","zi","geng","chao","hao","yun","ba","pi","yi","si","qu","jia","ju","huo","chu","lao","lun","ji","tang","ou","lou","nou","jiang","pang","zha","lou","ji","lao","huo","you","mo","huai","er","yi","ding","ye","da","song","qin","yun","chi","dan","dan","hong","geng","zhi","pan","nie","dan","zhen","che","ling","zheng","you","wa","liao","long","zhi","ning","tiao","er","ya","tie","gua","xu","lian","hao","sheng","lie","pin","jing","ju","bi","di","guo","wen","xu","ping","cong","ding","ni","ting","ju","cong","kui","lian","kui","cong","lian","weng","kui","lian","lian","cong","ao","sheng","song","ting","kui","nie","zhi","dan","ning","qie","ni","ting","ting","long",
"yu","yu","zhao","si","su","yi","su","si","zhao","zhao","rou","yi","le","ji","qiu","ken","cao","ge","bo","huan","huang","yi","ren","xiao","ru","zhou","yuan","du","gang","rong","gan","cha","wo","chang","gu","zhi","han","fu","fei","fen","pei","pang","jian","fang","zhun","you","na","ang","ken","ran","gong","yu","wen","yao","qi","pi","qian","xi","xi","fei","ken","jing","tai","shen","zhong","zhang","xie","shen","wei","zhou","die","dan","fei","ba","bo","qu","tian","bei","gua","tai","zi","ku","zhi","ni","ping","zi","fu","pang","zhen","xian","zuo","pei","jia","sheng","zhi","bao","mu","qu","hu","ke","chi","yin","xu","yang","long","dong","ka","lu","jing","nu","yan","pang","kua","yi","guang","hai","ge","dong","chi","jiao","xiong","xiong","er","an","heng","pian","neng","zi","gui",
"cheng","tiao","zhi","cui","mei","xie","cui","xie","mai","mai","ji","xie","nin","kuai","sa","zang","qi","nao","mi","nong","luan","wan","bo","wen","wan","xiu","jiao","jing","you","heng","cuo","lie","shan","ting","mei","chun","shen","qian","de","juan","cu","xiu","xin","tuo","pao","cheng","nei","pu","dou","tuo","niao","nao","pi","gu","luo","li","lian","zhang","cui","jie","liang","shui","pi","biao","lun","pian","lei","kui","chui","dan","tian","nei","jing","nai","la","ye","yan","ren","shen","chuo","fu","fu","ju","fei","qiang","wan","dong","pi","guo","zong","ding","wo","mei","ni","zhuan","chi","cou","luo","ou","di","an","xing","nao","shu","shuan","nan","yun","zhong","rou","e","sai","tu","yao","jian","wei","jiao","yu","jia","duan","bi","chang","fu","xian","ni","mian","wa","teng","tui","bang",
"qian","lu","wa","sou","tang","su","zhui","ge","yi","bo","liao","ji","pi","xie","gao","lu","bin","ou","chang","lu","guo","pang","chuai","biao","jiang","fu","tang","mo","xi","zhuan","lu","jiao","ying","lu","zhi","xue","chun","lin","tong","peng","ni","chuai","liao","cui","gui","xiao","teng","fan","zhi","jiao","shan","hu","cui","run","xiang","sui","fen","ying","shan","zhua","dan","kuai","nong","tun","lian","bi","yong","jue","chu","yi","juan","la","lian","sao","tun","gu","qi","cui","bin","xun","nao","wo","zang","xian","biao","xing","kuan","la","yan","lu","huo","za","luo","qu","zang","luan","ni","za","chen","qian","wo","guang","zang","lin","guang","zi","jiao","nie","chou","ji","gao","chou","mian","nie","zhi","zhi","ge","jian","die","zhi","xiu","tai","zhen","jiu","xian","yu","cha","yao","yu",
"chong","xi","xi","jiu","yu","yu","xing","ju","jiu","xin","she","she","she","jiu","shi","tan","shu","shi","tian","tan","pu","pu","guan","hua","tian","chuan","shun","xia","wu","zhou","dao","chuan","shan","yi","fan","pa","tai","fan","ban","chuan","hang","fang","ban","bi","lu","zhong","jian","cang","ling","zhu","ze","duo","bo","xian","ge","chuan","xia","lu","qiong","pang","xi","kua","fu","zao","feng","li","shao","yu","lang","ting","yu","wei","bo","meng","nian","ju","huang","shou","ke","bian","mu","die","dou","bang","cha","yi","sou","cang","cao","lou","dai","xue","yao","chong","deng","dang","qiang","lu","yi","ji","jian","huo","meng","qi","lu","lu","chan","shuang","gen","liang","jian","jian","se","yan","fu","ping","yan","yan","cao","cao","yi","le","ting","jiao","ai","nai","tiao","jiao","jie",
"peng","wan","yi","chai","mian","mi","gan","qian","yu","yu","shao","qiong","du","hu","qi","mang","zi","hui","sui","zhi","xiang","pi","fu","tun","wei","wu","zhi","qi","shan","wen","qian","ren","fu","kou","jie","lu","xu","ji","qin","qi","yan","fen","ba","rui","xin","ji","hua","hua","fang","wu","jue","gou","zhi","yun","qin","ao","chu","mao","ya","fei","reng","hang","cong","yin","you","bian","yi","qie","wei","li","pi","e","xian","chang","cang","zhu","su","ti","yuan","ran","ling","tai","shao","di","miao","qing","li","yong","ke","mu","bei","bao","gou","min","yi","yi","ju","pie","ruo","ku","ning","ni","bo","bing","shan","xiu","yao","xian","ben","hong","ying","zha","dong","ju","die","nie","gan","hu","ping","mei","fu","sheng","gu","bi","wei","fu","zhuo","mao","fan",
"jia","mao","mao","ba","ci","mo","zi","di","chi","ji","jing","long","cong","niao","yuan","xue","ying","qiong","ge","ming","li","rong","yin","gen","qian","chai","chen","yu","hao","zi","lie","wu","ji","gui","ci","jian","ci","gou","guang","mang","cha","jiao","jiao","fu","yu","zhu","zi","jiang","hui","yin","cha","fa","rong","ru","chong","mang","tong","zhong","qian","zhu","xun","huan","fu","quan","gai","da","jing","xing","chuan","cao","jing","er","an","qiao","chi","ren","jian","ti","huang","ping","li","jin","lao","shu","zhuang","da","jia","rao","bi","ze","qiao","hui","ji","dang","yu","rong","hun","xing","luo","ying","xun","jin","sun","yin","mai","hong","zhou","yao","du","wei","li","dou","fu","ren","yin","he","bi","bu","yun","di","tu","sui","sui","cheng","chen","wu","bie","xi","geng",
"li","pu","zhu","mo","li","zhuang","zuo","tuo","qiu","sha","suo","chen","peng","ju","mei","meng","xing","jing","che","shen","jun","yan","ting","you","cuo","guan","han","you","cuo","jia","wang","su","niu","shao","xian","lang","fu","e","mo","wen","jie","nan","mu","kan","lai","lian","shi","wo","tu","xian","huo","you","ying","ying","gong","chun","mang","mang","ci","wan","jing","di","qu","dong","jian","zou","gu","la","lu","ju","wei","jun","nie","kun","he","pu","zai","gao","guo","fu","lun","chang","chou","song","chui","zhan","men","cai","ba","li","tu","bo","han","bao","qin","juan","xi","qin","di","jie","pu","dang","jin","qiao","tai","geng","hua","gu","ling","fei","qin","an","wang","beng","zhou","yan","ju","jian","lin","tan","shu","tian","dao","hu","qi","he","cui","tao","chun",
"bi","chang","huan","fei","lai","qi","meng","ping","wei","dan","sha","huan","yan","yi","tiao","qi","wan","ce","nai","zhen","tuo","jiu","tie","luo","bi","yi","meng","bo","pao","ding","ying","ying","ying","xiao","sa","qiu","ke","xiang","wan","yu","yu","fu","lian","xuan","xuan","nan","ce","wo","chun","xiao","yu","bian","mao","an","e","luo","ying","kuo","kuo","jiang","mian","zuo","zuo","zu","bao","rou","xi","ye","an","qu","jian","fu","lu","jing","pen","feng","hong","hong","hou","yan","tu","zhe","zi","xiang","ren","ge","qia","qing","mi","huang","shen","pu","gai","dong","zhou","jian","wei","bo","wei","pa","ji","hu","zang","jia","duan","yao","sui","cong","quan","wei","zhen","kui","ting","hun","xi","shi","qi","lan","zong","yao","yuan","mei","yun","shu","di","zhuan","guan","ran","xue",
"chan","kai","kui","hua","jiang","lou","wei","pai","you","sou","yin","shi","chun","shi","yun","zhen","lang","ru","meng","li","que","suan","yuan","li","ju","xi","bang","chu","xu","tu","liu","huo","dian","qian","zu","po","cuo","yuan","chu","yu","kuai","pan","pu","pu","na","shuo","xi","fen","yun","zheng","jian","ji","ruo","cang","en","mi","hao","sun","zhen","ming","sou","xu","liu","xi","gu","lang","rong","weng","gai","cuo","shi","tang","luo","ru","suo","xuan","bei","yao","gui","bi","zong","gun","zuo","tiao","ce","pei","lan","dan","ji","li","shen","lang","yu","ling","ying","mo","diao","tiao","mao","tong","chu","peng","an","lian","cong","xi","ping","qiu","jin","chun","jie","wei","tui","cao","yu","yi","zi","liao","bi","lu","xu","bu","zhang","lei","qiang","man","yan","ling","ji",
"biao","gun","han","di","su","lu","she","shang","di","mie","xun","man","bo","di","cuo","zhe","shen","xuan","wei","hu","ao","mi","lou","cu","zhong","cai","po","jiang","mi","cong","niao","hui","juan","yin","jian","nian","shu","yin","guo","chen","hu","sha","kou","qian","ma","zang","ze","qiang","dou","lian","lin","kou","ai","bi","li","wei","ji","qian","sheng","fan","meng","ou","chan","dian","xun","jiao","rui","rui","lei","yu","qiao","chu","hua","jian","mai","yun","bao","you","qu","lu","rao","hui","e","ti","fei","jue","zui","fa","ru","fen","kui","shun","rui","ya","xu","fu","jue","dang","wu","dong","si","xiao","xi","long","wen","shao","qi","jian","yun","sun","ling","yu","xia","weng","ji","hong","si","nong","lei","xuan","yun","yu","xi","hao","bao","hao","ai","wei","hui",
"hui","ji","ci","xiang","wan","mie","yi","leng","jiang","can","shen","qiang","lian","ke","yuan","da","ti","tang","xue","bi","zhan","sun","xian","fan","ding","xie","gu","xie","shu","jian","hao","hong","sa","xin","xun","yao","bai","sou","shu","xun","dui","pin","wei","ning","chou","mai","ru","piao","tai","ji","zao","chen","zhen","er","ni","ying","gao","cong","xiao","qi","fa","jian","xu","kui","ji","bian","diao","mi","lan","jin","cang","miao","qiong","qie","xian","liao","ou","xian","su","lu","yi","xu","xie","li","yi","la","lei","jiao","di","zhi","bei","teng","yao","mo","huan","biao","fan","sou","tan","tui","qiong","qiao","wei","liu","hui","ou","gao","yun","bao","li","shu","chu","ai","lin","zao","xuan","qin","lai","huo","tuo","wu","rui","rui","qi","heng","lu","su","tui","meng",
"yun","ping","yu","xun","ji","jiong","xuan","mo","qiu","su","jiong","feng","nie","bo","rang","yi","xian","yu","ju","lian","lian","yin","qiang","ying","long","tou","wei","yue","ling","qu","yao","fan","mei","han","kui","lan","ji","dang","man","lei","lei","hui","feng","zhi","wei","kui","zhan","huai","li","ji","mi","lei","huai","luo","ji","kui","lu","jian","sa","teng","lei","quan","xiao","yi","luan","men","bie","hu","hu","lu","nue","lu","si","xiao","qian","chu","hu","xu","cuo","fu","xu","xu","lu","hu","yu","hao","jiao","ju","guo","bao","yan","zhan","zhan","kui","bin","xi","shu","chong","qiu","diao","ji","qiu","ding","shi","xia","jue","zhe","she","yu","han","zi","hong","hui","meng","ge","sui","xia","chai","shi","yi","ma","xiang","fang","e","ba","chi","qian","wen","wen",
"rui","bang","pi","yue","yue","jun","qi","tong","yin","qi","can","yuan","jue","hui","qin","qi","zhong","ya","hao","mu","wang","fen","fen","hang","gong","zao","fu","ran","jie","fu","chi","dou","bao","xian","ni","te","qiu","you","zha","ping","chi","you","he","han","ju","li","fu","ran","zha","gou","pi","pi","xian","zhu","diao","bie","bing","gu","zhan","qu","she","tie","ling","gu","dan","gu","ying","li","cheng","qu","mou","ge","ci","hui","hui","mang","fu","yang","wa","lie","zhu","yi","xian","kuo","jiao","li","yi","ping","qi","ha","she","yi","wang","mo","qiong","qie","gui","qiong","zhi","man","lao","zhe","jia","nao","si","qi","xing","jie","qiu","shao","yong","jia","tui","che","bai","e","han","shu","xuan","feng","shen","shen","fu","xian","zhe","wu","fu","li","lang",
"bi","chu","yuan","you","jie","dan","yan","ting","dian","tui","hui","wo","zhi","song","fei","ju","mi","qi","qi","yu","jun","la","meng","qiang","si","xi","lun","li","die","tiao","tao","kun","han","han","yu","bang","fei","pi","wei","dun","yi","yuan","suo","quan","qian","rui","ni","qing","wei","liang","guo","wan","dong","e","ban","di","wang","can","yang","ying","guo","chan","ding","la","ke","jie","xie","ting","mao","xu","mian","yu","jie","shi","xuan","huang","yan","bian","rou","wei","fu","yuan","mei","wei","fu","ru","xie","you","qiu","mao","xia","ying","shi","chong","tang","zhu","zong","ti","fu","yuan","kui","meng","la","du","hu","qiu","die","li","wo","yun","qu","nan","lou","chun","rong","ying","jiang","ban","lang","pang","si","xi","ci","xi","yuan","weng","lian","sou","ban",
"rong","rong","ji","wu","xiu","han","qin","yi","bi","hua","tang","yi","du","nai","he","hu","gui","ma","ming","yi","wen","ying","te","zhong","cang","sao","qi","man","tiao","shang","shi","cao","chi","di","ao","lu","wei","zhi","tang","chen","piao","qu","pi","yu","jian","luo","lou","qin","zhong","yin","jiang","shuai","wen","xiao","wan","zhe","zhe","ma","ma","guo","liu","mao","xi","cong","li","man","xiao","chang","zhang","mang","xiang","mo","zui","si","qiu","te","zhi","peng","peng","jiao","qu","bie","liao","pan","gui","xi","ji","zhuan","huang","fei","lao","jue","jue","hui","yin","chan","jiao","shan","nao","xiao","wu","chong","xun","si","chu","cheng","dang","li","xie","shan","yi","jing","da","chan","qi","ci","xiang","she","luo","qin","ying","chai","li","zei","xuan","lian","zhu","ze","xie",
"mang","xie","qi","rong","jian","meng","hao","ru","huo","zhuo","jie","pin","he","mie","fan","lei","jie","la","min","li","chun","li","qiu","nie","lu","du","xiao","zhu","long","li","long","feng","ye","beng","nang","gu","juan","ying","shu","xi","can","qu","quan","du","can","man","qu","jie","zhu","zhuo","xue","huang","niu","pei","nu","xin","zhong","mai","er","ka","mie","xi","xing","yan","kan","yuan","qu","ling","xuan","shu","xian","tong","xiang","jie","xian","ya","hu","wei","dao","chong","wei","dao","zhun","heng","qu","yi","yi","bu","gan","yu","biao","cha","yi","shan","chen","fu","gun","fen","shuai","jie","na","zhong","dan","yi","zhong","zhong","jie","zhi","xie","ran","zhi","ren","qin","jin","jun","yuan","mei","chai","ao","niao","hui","ran","jia","tuo","ling","dai","bao","pao","yao",
"zuo","bi","shao","tan","ju","he","xue","xiu","zhen","yi","pa","bo","di","wa","fu","gun","zhi","zhi","ran","pan","yi","mao","tuo","na","gou","xuan","zhe","qu","bei","gun","xi","ni","bo","bo","fu","chi","chi","ku","ren","jiang","jia","jian","bo","jie","er","ge","ru","zhu","gui","yin","cai","lie","ka","xing","zhuang","dang","xu","kun","ken","niao","shu","jia","kun","cheng","li","juan","shen","pou","ge","yi","yu","zhen","liu","qiu","qun","ji","yi","bu","zhuang","shui","sha","qun","li","lian","lian","ku","jian","fou","chan","bi","kun","tao","yuan","ling","chi","chang","chou","duo","biao","liang","shang","pei","pei","fei","yuan","luo","guo","yan","du","ti","zhi","ju","yi","ji","zhi","gua","ken","qi","ti","ti","fu","chong","xie","bian","die","kun","duan","xiu","xiu",
"he","yuan","bao","bao","fu","yu","tuan","yan","hui","bei","chu","lu","pao","dan","yun","ta","gou","da","huai","rong","yuan","ru","nai","jiong","suo","ban","tui","chi","sang","niao","ying","jie","qian","huai","ku","lian","lan","li","zhe","shi","lu","yi","die","xie","xian","wei","biao","cao","ji","qiang","sen","bao","xiang","bi","fu","jian","zhuan","jian","cui","ji","dan","za","fan","bo","xiang","xin","bie","rao","man","lan","ao","ze","gui","cao","sui","nong","chan","lian","bi","jin","dang","shu","tan","bi","lan","pu","ru","zhi","dui","shu","wa","shi","bai","xie","bo","chen","lai","long","xi","xian","lan","zhe","dai","ju","zan","shi","jian","pan","yi","lan","ya","xi","xi","yao","feng","tan","fu","fiao","fu","ba","he","ji","ji","jian","guan","bian","yan","gui","jue",
"pian","mao","mi","mi","mie","shi","si","chan","luo","jue","mi","tiao","lian","yao","zhi","jun","xi","shan","wei","xi","tian","yu","lan","e","du","qin","pang","ji","ming","ying","gou","qu","zhan","jin","guan","deng","jian","luo","qu","jian","wei","jue","qu","luo","lan","shen","di","guan","jian","guan","yan","gui","mi","shi","chan","lan","jue","ji","xi","di","tian","yu","gou","jin","qu","jiao","qiu","jin","cu","jue","zhi","chao","ji","gu","dan","zi","di","shang","hua","quan","ge","shi","jie","gui","gong","chu","jie","hun","qiu","xing","su","ni","ji","lu","zhi","zha","bi","xing","hu","shang","gong","zhi","xue","chu","xi","yi","li","jue","xi","yan","xi","yan","yan","ding","fu","qiu","qiu","jiao","hong","ji","fan","xun","diao","hong","chai","tao","xu","jie","yi",
"ren","xun","yin","shan","qi","tuo","ji","xun","yin","e","fen","ya","yao","song","shen","yin","xin","jue","xiao","ne","chen","you","zhi","xiong","fang","xin","chao","she","xian","sa","zhun","xu","yi","yi","su","chi","he","shen","he","xu","zhen","zhu","zheng","gou","zi","zi","zhan","gu","fu","jian","die","ling","di","yang","li","nao","pan","zhou","gan","yi","ju","yao","zha","yi","yi","qu","zhao","ping","bi","xiong","qu","ba","da","zu","tao","zhu","ci","zhe","yong","xu","xun","yi","huang","he","shi","cha","xiao","shi","hen","cha","gou","gui","quan","hui","jie","hua","gai","xiang","wei","shen","zhou","tong","mi","zhan","ming","e","hui","yan","xiong","gua","er","bing","tiao","yi","lei","zhu","kuang","kua","wu","yu","teng","ji","zhi","ren","cu","lang","e","kuang","ei",
"shi","ting","dan","bei","chan","you","keng","qiao","qin","shua","an","yu","xiao","cheng","jie","xian","wu","wu","gao","song","bu","hui","jing","shuo","zhen","shuo","du","hua","chang","shui","jie","ke","qu","cong","xiao","sui","wang","xian","fei","chi","ta","yi","ni","yin","diao","pi","zhuo","chan","chen","zhun","ji","qi","tan","zhui","wei","ju","qing","dong","zheng","ze","zou","qian","zhuo","liang","jian","chu","hao","lun","shen","biao","huai","pian","yu","die","xu","pian","shi","xuan","shi","hun","hua","e","zhong","di","xie","fu","pu","ting","jian","qi","yu","zi","zhuan","xi","hui","yin","an","xian","nan","chen","feng","zhu","yang","yan","huang","xuan","ge","nuo","qi","mou","ye","wei","xing","teng","zhou","shan","jian","po","kui","huang","huo","ge","ying","mi","xiao","mi","xi","qiang","chen",
"xue","ti","su","bang","chi","qian","shi","jiang","yuan","xie","he","tao","yao","yao","zhi","yu","biao","cong","qing","li","mo","mo","shang","zhe","miu","jian","ze","jie","lian","lou","can","ou","gun","xi","zhuo","ao","ao","jin","zhe","yi","hu","jiang","man","chao","han","hua","chan","xu","zeng","se","xi","zha","dui","zheng","nao","lan","e","ying","jue","ji","zun","jiao","bo","hui","zhuan","wu","zen","zha","shi","qiao","tan","zen","pu","sheng","xuan","zao","tan","dang","sui","xian","ji","jiao","jing","zhan","nang","yi","ai","zhan","pi","hui","hua","yi","yi","shan","rang","nou","qian","zhui","ta","hu","zhou","hao","ai","ying","jian","yu","jian","hui","du","zhe","xuan","zan","lei","shen","wei","chan","li","yi","bian","zhe","yan","e","chou","wei","chou","yao","chan","rang","yin",
"lan","chen","xie","nie","huan","zan","yi","dang","zhan","yan","du","yan","ji","ding","fu","ren","ji","jie","hong","tao","rang","shan","qi","tuo","xun","yi","xun","ji","ren","jiang","hui","ou","ju","ya","ne","xu","e","lun","xiong","song","feng","she","fang","jue","zheng","gu","he","ping","zu","shi","xiong","zha","su","zhen","di","zhou","ci","qu","zhao","bi","yi","yi","kuang","lei","shi","gua","shi","ji","hui","cheng","zhu","shen","hua","dan","gou","quan","gui","xun","yi","zheng","gai","xiang","cha","hun","xu","zhou","jie","wu","yu","qiao","wu","gao","you","hui","kuang","shuo","song","ei","qing","zhu","zou","nuo","du","zhuo","fei","ke","wei","yu","shui","shen","diao","chan","liang","zhun","sui","tan","shen","yi","mou","chen","die","huang","jian","xie","xue","ye","wei","e","yu",
"xuan","chan","zi","an","yan","di","mi","pian","xu","mo","dang","su","xie","yao","bang","shi","qian","mi","jin","man","zhe","jian","miu","tan","zen","qiao","lan","pu","jue","yan","qian","zhan","chen","gu","qian","hong","xia","ji","hong","han","hong","xi","xi","huo","liao","han","du","long","dou","jiang","qi","shi","li","deng","wan","bi","shu","xian","feng","zhi","zhi","yan","yan","shi","chu","hui","tun","yi","tun","yi","jian","ba","hou","e","chu","xiang","huan","jian","ken","gai","ju","fu","xi","bin","hao","yu","zhu","jia","fen","xi","bo","wen","huan","bin","di","zong","fen","yi","zhi","bao","chai","an","pi","na","pi","gou","na","you","diao","mo","si","xiu","huan","kun","he","hao","mo","han","mao","li","ni","bi","yu","jia","tuan","mao","pi","xi","e",
"ju","mo","chu","tan","huan","jue","bei","zhen","yuan","fu","cai","gong","te","yi","hang","wan","pin","huo","fan","tan","guan","ze","zhi","er","zhu","shi","bi","zi","er","gui","pian","bian","mai","dai","sheng","kuang","fei","tie","yi","chi","mao","he","bi","lu","lin","hui","gai","pian","zi","jia","xu","zei","jiao","gai","zang","jian","ying","xun","zhen","she","bin","bin","qiu","she","chuan","zang","zhou","lai","zan","ci","chen","shang","tian","pei","geng","xian","mai","jian","sui","fu","tan","cong","cong","zhi","ji","zhang","du","jin","xiong","chun","yun","bao","zai","lai","feng","cang","ji","sheng","yi","zhuan","fu","gou","sai","ze","liao","yi","bai","chen","wan","zhi","zhui","biao","yun","zeng","dan","zan","yan","pu","shan","wan","ying","jin","gan","xian","zang","bi","du","shu","yan",
"shang","xuan","long","gan","zang","bei","zhen","fu","yuan","gong","cai","ze","xian","bai","zhang","huo","zhi","fan","tan","pin","bian","gou","zhu","guan","er","jian","ben","shi","tie","gui","kuang","dai","mao","fei","he","yi","zei","zhi","jia","hui","zi","lin","lu","zang","zi","gai","jin","qiu","zhen","lai","she","fu","du","ji","shu","shang","ci","bi","zhou","geng","pei","dan","lai","feng","zhui","fu","zhuan","sai","ze","yan","zan","yun","zeng","shan","ying","gan","chi","xi","she","nan","tong","xi","cheng","he","cheng","zhe","xia","tang","zou","zou","li","jiu","fu","zhao","gan","qi","shan","qiong","yin","xian","ci","jue","qin","chi","ci","chen","chen","die","ju","chao","di","xi","zhan","jue","yue","qu","ji","chi","chu","gua","xue","zi","tiao","duo","lie","gan","suo","cu","xi",
"zhao","su","yin","ju","jian","que","tang","chuo","cui","lu","qu","dang","qiu","zi","ti","qu","chi","huang","qiao","qiao","jiao","zao","ti","er","zan","zan","zu","pa","bao","ku","ke","dun","jue","fu","chen","jian","fang","zhi","ta","yue","ba","qi","yue","qiang","tuo","tai","yi","nian","ling","mei","ba","die","ku","tuo","jia","ci","pao","qia","zhu","ju","dian","zhi","fu","pan","ju","shan","bo","ni","ju","li","gen","yi","ji","duo","xian","jiao","duo","zhu","quan","kua","zhuai","gui","qiong","kui","xiang","chi","lu","pian","zhi","jia","tiao","cai","jian","ta","qiao","bi","xian","duo","ji","ju","ji","shu","tu","chu","jing","nie","xiao","bu","xue","cun","mu","shu","liang","yong","jiao","chou","qiao","mou","ta","jian","qi","wo","wei","chuo","jie","ji","nie","ju","ju",
"lun","lu","leng","huai","ju","chi","wan","quan","ti","bo","zu","qie","yi","cu","zong","cai","zong","peng","zhi","zheng","dian","zhi","yu","duo","dun","chuan","yong","zhong","di","zha","chen","chuai","jian","gua","tang","ju","fu","zu","die","pian","rou","nuo","ti","cha","tui","jian","dao","cuo","qi","ta","qiang","nian","dian","ti","ji","nie","pan","liu","zan","bi","chong","lu","liao","cu","tang","dai","su","xi","kui","ji","zhi","qiang","di","pan","zong","lian","beng","zao","nian","bie","tui","ju","deng","ceng","xian","fan","chu","zhong","dun","bo","cu","cu","jue","jue","lin","ta","qiao","jue","pu","liao","dun","cuan","kuang","zao","da","bi","bi","zhu","ju","chu","qiao","dun","chou","ji","wu","yue","nian","lin","lie","zhi","li","zhi","chan","chu","duan","wei","long","lin","xian",
"wei","zuan","lan","xie","rang","sa","nie","ta","qu","jie","cuan","cuo","xi","kui","jue","lin","shen","gong","dan","fen","qu","ti","duo","duo","gong","lang","ren","luo","ai","ji","ju","tang","kong","lao","yan","mei","kang","qu","lou","lao","duo","zhi","yan","ti","dao","ying","yu","che","ya","gui","jun","wei","yue","xin","dai","xuan","fan","ren","shan","kuang","shu","tun","chen","dai","e","na","qi","mao","ruan","ren","qian","zhuan","hong","hu","qu","kuang","di","ling","dai","ao","zhen","fan","kuang","yang","peng","bei","gu","gu","pao","zhu","rong","e","ba","zhou","zhi","yao","ke","yi","zhi","shi","ping","er","gong","ju","jiao","guang","he","kai","quan","zhou","zai","zhi","she","liang","yu","shao","you","wan","yin","zhe","wan","fu","qing","zhou","ni","leng","zhe","zhan","liang",
"zi","hui","wang","chuo","guo","kan","yi","peng","qian","gun","nian","ping","guan","bei","lun","pai","liang","ruan","rou","ji","yang","xian","chuan","cou","chun","ge","you","hong","shu","fu","zi","fu","wen","ben","zhan","yu","wen","tao","gu","zhen","xia","yuan","lu","jiao","chao","zhuan","wei","hun","xue","zhe","jiao","zhan","bu","lao","fen","fan","lin","ge","se","kan","huan","yi","ji","zhui","er","yu","jian","hong","lei","pei","li","li","lu","lin","che","ya","gui","xuan","dai","ren","zhuan","e","lun","ruan","hong","gu","ke","lu","zhou","zhi","yi","hu","zhen","li","yao","qing","shi","zai","zhi","jiao","zhou","quan","lu","jiao","zhe","fu","liang","nian","bei","hui","gun","wang","liang","chuo","zi","cou","fu","ji","wen","shu","pei","yuan","xia","nian","lu","zhe","lin","xin","gu",
"ci","ci","pi","zui","bian","la","la","ci","xue","ban","bian","bian","bian","xue","bian","ban","ci","bian","bian","chen","ru","nong","nong","chan","chuo","chuo","yi","reng","bian","bian","shi","ru","liao","da","chan","gan","qian","yu","yu","qi","xun","yi","guo","mai","qi","za","wang","tu","zhun","ying","ti","yun","jin","hang","ya","fan","wu","da","e","hai","zhe","zhong","jin","yuan","wei","lian","chi","che","ni","tiao","zhi","yi","jiong","jia","chen","dai","er","di","po","zhu","die","ze","tao","shu","tuo","qu","jing","hui","dong","you","mi","beng","ji","nai","yi","jie","zhui","lie","xun","tui","song","shi","tao","pang","hou","ni","dun","jiong","xuan","xun","bu","you","xiao","qiu","tou","zhu","qiu","di","di","tu","jing","ti","dou","yi","zhe","tong","guang","wu","shi",
"cheng","su","zao","qun","feng","lian","suo","hui","li","gu","lai","ben","cuo","jue","beng","huan","dai","lu","you","zhou","jin","yu","chuo","kui","wei","ti","yi","da","yuan","luo","bi","nuo","yu","dang","sui","dun","sui","yan","chuan","chi","ti","yu","shi","zhen","you","yun","e","bian","guo","e","xia","huang","qiu","dao","da","wei","nan","yi","gou","yao","chou","liu","xun","ta","di","chi","yuan","su","ta","qian","ma","yao","guan","zhang","ao","shi","ca","chi","su","zao","zhe","dun","di","lou","chi","cuo","lin","zun","rao","qian","xuan","yu","yi","wu","liao","ju","shi","bi","yao","mai","xie","sui","hai","zhan","teng","er","miao","bian","bian","la","li","yuan","yao","luo","li","yi","ting","deng","qi","yong","shan","han","yu","mang","ru","qiong","wan","kuang","fu",
"kang","bin","fang","xing","na","xin","shen","bang","yuan","cun","huo","xie","bang","wu","ju","you","han","tai","qiu","bi","pi","bing","shao","bei","wa","di","zou","ye","lin","kuang","gui","zhu","shi","ku","yu","gai","he","qie","zhi","ji","huan","hou","xing","jiao","xi","gui","nuo","lang","jia","kuai","zheng","lang","yun","yan","cheng","dou","xi","lu","fu","wu","fu","gao","hao","lang","jia","geng","jun","ying","bo","xi","bei","li","yun","bu","xiao","qi","pi","qing","guo","zhou","tan","zou","ping","lai","ni","chen","you","bu","xiang","dan","ju","yong","qiao","yi","dou","yan","mei","ruo","bei","e","shu","juan","yu","yun","hou","kui","xiang","xiang","sou","tang","ming","xi","ru","chu","zi","zou","ye","wu","xiang","yun","hao","yong","bi","mao","chao","fu","liao","yin","zhuan",
"hu","qiao","yan","zhang","man","qiao","xu","deng","bi","xun","bi","zeng","wei","zheng","mao","shan","lin","po","dan","meng","ye","cao","kuai","feng","meng","zou","kuang","lian","zan","chan","you","ji","yan","chan","cuo","ling","huan","xi","feng","zan","li","you","ding","qiu","zhuo","pei","zhou","yi","gan","yu","jiu","yan","zui","mao","zhen","xu","dou","zhen","fen","yuan","fu","yun","tai","tian","qia","tuo","cu","han","gu","su","fa","chou","zai","ming","lao","chuo","chou","you","tong","zhi","xian","jiang","cheng","yin","tu","jiao","mei","ku","suan","lei","pu","zui","hai","yan","shai","niang","wei","lu","lan","yan","tao","pei","zhan","chun","tan","zui","zhui","cu","kun","ti","xian","du","hu","xu","xing","tan","qiu","chun","yun","po","ke","sou","mi","quan","chou","cuo","yun","yong","ang",
"zha","hai","tang","jiang","piao","chen","yu","li","zao","lao","yi","jiang","bu","jiao","xi","tan","fa","nong","yi","li","ju","yan","yi","niang","ru","xun","chou","yan","ling","mi","mi","niang","xin","jiao","shai","mi","yan","bian","cai","shi","you","shi","shi","li","zhong","ye","liang","li","jin","jin","qiu","yi","liao","dao","zhao","ding","po","qiu","ba","fu","zhen","zhi","ba","luan","fu","nai","diao","shan","qiao","kou","chuan","zi","fan","hua","hua","han","gang","qi","mang","ri","di","si","xi","yi","chai","shi","tu","xi","nu","qian","qiu","jian","pi","ye","jin","ba","fang","chen","xing","dou","yue","qian","fu","pi","na","xin","e","jue","dun","gou","yin","qian","ban","sa","ren","chao","niu","fen","yun","ji","qin","pi","guo","hong","yin","jun","shi","yi","zhong",
"xi","gai","ri","huo","tai","kang","yuan","lu","e","wen","duo","zi","ni","tu","shi","min","gu","ke","ling","bing","si","gu","bo","pi","yu","si","zuo","bu","you","tian","jia","zhen","shi","shi","zhi","ju","chan","shi","shi","xuan","zhao","bao","he","bi","sheng","chu","shi","bo","zhu","chi","za","po","tong","qian","fu","zhai","liu","qian","fu","li","yue","pi","yang","ban","bo","jie","gou","shu","zheng","mu","xi","xi","di","jia","mu","tan","huan","yi","si","kuang","ka","bei","jian","tong","xing","hong","jiao","chi","er","luo","bing","shi","mou","jia","yin","jun","zhou","chong","xiang","tong","mo","lei","ji","yu","xu","ren","zun","zhi","qiong","shan","chi","xian","xing","quan","pi","tie","zhu","xiang","ming","kua","yao","xian","xian","xiu","jun","cha","lao","ji","pi",
"ru","mi","yi","yin","guang","an","diu","you","se","kao","qian","luan","si","ai","diao","han","rui","shi","keng","qiu","xiao","zhe","xiu","zang","ti","cuo","gua","hong","zhong","tou","lu","mei","lang","wan","xin","yun","bei","wu","su","yu","chan","ding","bo","han","jia","hong","cuan","feng","chan","wan","zhi","si","xuan","hua","yu","tiao","gong","zhuo","lue","xing","qin","shen","han","lue","ye","chu","zeng","ju","xian","tie","mang","pu","li","pan","rui","cheng","gao","li","te","bing","zhu","zhen","tu","liu","zui","ju","chang","yuan","jian","gang","diao","tao","chang","lun","guo","ling","bei","lu","li","qiang","pou","juan","min","zui","peng","an","pi","xian","ya","zhui","lei","ke","kong","ta","kun","du","nei","chui","zi","zheng","ben","nie","zong","chun","tan","ding","qi","qian","zhui",
"ji","yu","jin","guan","mao","chang","tian","xi","lian","tao","gu","cuo","shu","zhen","lu","meng","lu","hua","biao","ga","lai","ken","fang","wu","nai","wan","zan","hu","de","xian","pian","huo","liang","fa","men","kai","ying","di","lian","guo","xian","du","tu","wei","zong","fu","rou","ji","e","jun","chen","ti","zha","hu","yang","duan","xia","yu","keng","xing","huang","wei","fu","zhao","cha","qie","shi","hong","kui","tian","mou","qiao","qiao","hou","tou","cong","huan","ye","min","jian","duan","jian","song","kui","hu","xuan","duo","jie","zhen","bian","zhong","zi","xiu","ye","mei","pai","ai","jie","qian","mei","suo","da","bang","xia","lian","suo","kai","liu","yao","ye","nou","weng","rong","tang","suo","qiang","li","shuo","chui","bo","pan","da","bi","sang","gang","zi","wu","ying","huang",
"tiao","liu","kai","sun","sha","sou","wan","hao","zhen","zhen","lang","yi","yuan","tang","nie","xi","jia","ge","ma","juan","song","zu","suo","xia","feng","wen","na","lu","suo","ou","zu","tuan","xiu","guan","xuan","lian","shou","ao","man","mo","luo","bi","wei","liu","di","san","zong","yi","lu","ao","keng","qiang","cui","qi","chang","tang","man","yong","chan","feng","jing","biao","shu","lou","xiu","cong","long","zan","jian","cao","li","xia","xi","kang","shuang","beng","zhang","qian","cheng","lu","hua","ji","pu","hui","qiang","po","lin","se","xiu","san","cheng","kui","si","liu","nao","huang","pie","sui","fan","qiao","quan","yang","tang","xiang","jue","jiao","zun","liao","qie","lao","dui","xin","zan","ji","jian","zhong","deng","ya","ying","dui","jue","nou","zan","pu","tie","fan","zhang","ding","shan",
"kai","jian","fei","sui","lu","juan","hui","yu","lian","zhuo","qiao","jian","zhuo","lei","bi","tie","huan","ye","duo","guo","dang","ju","fen","da","bei","yi","ai","zong","xun","diao","zhu","heng","zhui","ji","nie","he","huo","qing","bin","ying","kui","ning","xu","jian","jian","qian","cha","zhi","mie","li","lei","ji","zuan","kuang","shang","peng","la","du","shuo","chuo","lu","biao","bao","lu","xian","kuan","long","e","lu","xin","jian","lan","bo","jian","yao","chan","xiang","jian","xi","guan","cang","nie","lei","cuan","qu","pan","luo","zuan","luan","zao","nie","jue","tang","shu","lan","jin","ga","yi","zhen","ding","zhao","po","liao","tu","qian","chuan","shan","ji","fan","diao","men","nu","yang","chai","xing","gai","bu","tai","ju","dun","chao","zhong","na","bei","gang","ban","qian","yao","qin",
"jun","wu","gou","kang","fang","huo","tou","niu","ba","yu","qian","zheng","qian","gu","bo","e","po","bu","bo","yue","zuan","mu","tan","jia","dian","you","tie","bo","ling","shuo","qian","mao","bao","shi","xuan","ta","bi","ni","pi","duo","xing","kao","lao","er","mang","ya","you","cheng","jia","ye","nao","zhi","dang","tong","lu","diao","yin","kai","zha","zhu","xi","ding","diu","xian","hua","quan","sha","ha","diao","ge","ming","zheng","se","jiao","yi","chan","chong","tang","an","yin","ru","zhu","lao","pu","wu","lai","te","lian","keng","xiao","suo","li","zeng","chu","guo","gao","e","xiu","cuo","lue","feng","xin","liu","kai","jian","rui","ti","lang","qin","ju","a","qiang","zhe","nuo","cuo","mao","ben","qi","de","ke","kun","chang","xi","gu","luo","chui","zhui","jin","zhi",
"xian","juan","huo","pei","tan","ding","jian","ju","meng","zi","qie","ying","kai","qiang","si","e","cha","qiao","zhong","duan","sou","huang","huan","ai","du","mei","lou","zi","fei","mei","mo","zhen","bo","ge","nie","tang","juan","nie","na","liu","gao","bang","yi","jia","bin","rong","biao","tang","man","luo","beng","yong","jing","di","zu","xuan","liu","chan","jue","liao","pu","lu","dui","lan","pu","cuan","qiang","deng","huo","lei","huan","zhuo","lian","yi","cha","biao","la","chan","xiang","zhang","chang","jiu","ao","die","qu","liao","mi","zhang","men","ma","shuan","shan","huo","men","yan","bi","han","bi","shan","kai","kang","beng","hong","run","san","xian","xian","jian","min","xia","shui","dou","zha","nao","zhan","peng","xia","ling","bian","bi","run","ai","guan","ge","ge","fa","chu","hong","gui",
"min","se","kun","lang","lu","ting","sha","ju","yue","yue","chan","qu","lin","chang","shai","kun","yan","wen","yan","e","hun","yu","wen","xiang","bao","hong","qu","yao","wen","ban","an","wei","yin","kuo","que","lan","du","quan","feng","tian","nie","ta","kai","he","que","chuang","guan","dou","qi","kui","tang","guan","piao","kan","xi","hui","chan","pi","dang","huan","ta","wen","ta","men","shuan","shan","yan","han","bi","wen","chuang","run","wei","xian","hong","jian","min","kang","men","zha","nao","gui","wen","ta","min","lu","kai","fa","ge","he","kun","jiu","yue","lang","du","yu","yan","chang","xi","wen","hun","yan","e","chan","lan","qu","hui","kuo","que","he","tian","da","que","han","huan","fu","fu","le","dui","xin","qian","wu","gai","zhi","yin","yang","dou","e","sheng",
"ban","pei","keng","yun","ruan","zhi","pi","jing","fang","yang","yin","zhen","jie","cheng","e","qu","di","zu","zuo","dian","ling","a","tuo","tuo","bei","bing","fu","ji","lu","long","chen","xing","duo","lou","mo","jiang","shu","duo","xian","er","gui","yu","gai","shan","jun","qiao","xing","chun","fu","bi","xia","shan","sheng","zhi","pu","dou","yuan","zhen","chu","xian","dao","nie","yun","xian","pei","fei","zou","yi","dui","lun","yin","ju","chui","chen","pi","ling","tao","xian","lu","sheng","xian","yin","zhu","yang","reng","xia","chong","yan","yin","shu","di","yu","long","wei","wei","nie","dui","sui","an","huang","jie","sui","yin","gai","yan","hui","ge","yun","wu","kui","ai","xi","tang","ji","zhang","dao","ao","xi","yin","sa","rao","lin","tui","deng","jiao","sui","sui","ao","xian",
"fen","ni","er","ji","dao","xi","yin","e","hui","long","xi","li","li","li","zhui","hu","zhi","sun","juan","nan","yi","que","yan","qin","qian","xiong","ya","ji","gu","huan","zhi","gou","juan","ci","yong","ju","chu","hu","za","luo","yu","chou","diao","sui","han","wo","shuang","guan","chu","za","yong","ji","xi","chou","liu","li","nan","xue","za","ji","ji","yu","yu","xue","na","fou","se","mu","wen","fen","pang","yun","li","chi","yang","ling","lei","an","bao","wu","dian","dang","hu","wu","diao","xu","ji","mu","chen","xiao","zha","ting","zhen","pei","mei","ling","qi","zhou","huo","sha","fei","hong","zhan","yin","ni","zhu","tun","lin","ling","dong","ying","wu","ling","shuang","ling","xia","hong","yin","mai","mai","yun","liu","meng","bin","wu","wei","kuo","yin","xi",
"yi","ai","dan","teng","san","yu","lu","long","dai","ji","pang","yang","ba","pi","wei","feng","xi","ji","mai","meng","meng","lei","li","huo","ai","fei","dai","long","ling","ai","feng","li","bao","he","he","he","bing","qing","qing","jing","tian","zhen","jing","cheng","qing","jing","jing","dian","jing","tian","fei","fei","kao","mi","mian","mian","bao","ye","tian","hui","ye","ge","ding","cha","qian","ren","di","du","wu","ren","qin","jin","xue","niu","ba","yin","sa","na","mo","zu","da","ban","yi","yao","tao","bei","jia","hong","pao","yang","bing","yin","ge","tao","jie","xie","an","an","hen","gong","qia","da","qiao","ting","man","ying","sui","tiao","qiao","xuan","kong","beng","ta","shang","bing","kuo","ju","la","xie","rou","bang","eng","qiu","qiu","he","xiao","mu","ju","jian",
"bian","di","jian","wen","tao","gou","ta","bei","xie","pan","ge","bi","kuo","tang","lou","gui","qiao","xue","ji","jian","jiang","chan","da","hu","xian","qian","du","wa","jian","lan","wei","ren","fu","mei","quan","ge","wei","qiao","han","chang","kuo","rou","yun","she","wei","ge","bai","tao","gou","yun","gao","bi","wei","sui","du","wa","du","wei","ren","fu","han","wei","yun","tao","jiu","jiu","xian","xie","xian","ji","yin","za","yun","shao","le","peng","huang","ying","yun","peng","an","yin","xiang","hu","ye","ding","qing","kui","xiang","shun","han","xu","yi","xu","e","song","kui","qi","hang","yu","wan","ban","dun","di","dan","pan","po","ling","che","jing","lei","he","qiao","e","e","wei","xie","kuo","shen","yi","shen","hai","dui","yu","ping","lei","fu","jia","tou",
"hui","kui","jia","luo","ting","cheng","ying","yun","hu","han","jing","tui","tui","pin","lai","tui","zi","zi","chui","ding","lai","tan","han","qian","ke","cui","xuan","qin","yi","sai","ti","e","e","yan","wen","kan","yong","zhuan","yan","xian","xin","yi","yuan","sang","dian","dian","jiang","kui","lei","lao","piao","wai","man","cu","yao","hao","qiao","gu","xun","yan","hui","chan","ru","meng","bin","xian","pin","lu","lan","nie","quan","ye","ding","qing","han","xiang","shun","xu","xu","wan","gu","dun","qi","ban","song","hang","yu","lu","ling","po","jing","jie","jia","ting","he","ying","jiong","ke","yi","pin","hui","tui","han","ying","ying","ke","ti","yong","e","zhuan","yan","e","nie","man","dian","sang","hao","lei","chan","ru","pin","quan","feng","biao","gua","fu","xia","zhan","biao",
"sa","ba","tai","lie","gua","xuan","shao","ju","biao","si","wei","yang","yao","sou","kai","sou","fan","liu","xi","liu","piao","piao","liu","biao","biao","biao","liao","biao","se","feng","xiu","feng","yang","zhan","biao","sa","ju","si","sou","yao","liu","piao","biao","biao","fei","fan","fei","fei","shi","shi","can","ji","ding","si","tuo","zhan","sun","xiang","tun","ren","yu","juan","chi","yin","fan","fan","sun","yin","tou","yi","zuo","bi","jie","tao","liu","ci","tie","si","bao","shi","duo","hai","ren","tian","jiao","jia","bing","yao","tong","ci","xiang","yang","juan","er","yan","le","xi","can","bo","nei","e","bu","jun","dou","su","yu","shi","yao","hun","guo","shi","jian","zhui","bing","xian","bu","ye","tan","fei","zhang","wei","guan","e","nuan","yun","hu","huang","tie","hui",
"jian","hou","ai","tang","fen","wei","gu","cha","song","tang","bo","gao","xi","kui","liu","sou","tao","ye","yun","mo","tang","man","bi","yu","xiu","jin","san","kui","zhuan","shan","chi","dan","yi","ji","rao","cheng","yong","tao","wei","xiang","zhan","fen","hai","meng","yan","mo","chan","xiang","luo","zan","nang","shi","ding","ji","tuo","tang","tun","xi","ren","yu","chi","fan","yin","jian","shi","bao","si","duo","yi","er","rao","xiang","he","le","jiao","xi","bing","bo","dou","e","yu","nei","jun","guo","hun","xian","guan","cha","kui","gu","sou","chan","ye","mo","bo","liu","xiu","jin","man","san","zhuan","nang","shou","kui","guo","xiang","fen","bo","ni","bi","bo","tu","han","fei","jian","an","ai","fu","xian","yun","xin","fen","pin","xin","ma","yu","feng","han","di",
"tuo","zhe","chi","xun","zhu","zhi","pei","xin","ri","sa","yun","wen","zhi","dan","lu","you","bo","bao","jue","tuo","yi","qu","wen","qu","jiong","po","zhao","yuan","pei","zhou","ju","zhu","nu","ju","pi","zang","jia","ling","zhen","tai","fu","yang","shi","bi","tuo","tuo","si","liu","ma","pian","tao","zhi","rong","teng","dong","xun","quan","shen","jiong","er","hai","bo","zhu","yin","luo","zhou","dan","xie","liu","ju","song","qin","mang","lang","han","tu","xuan","tui","jun","e","cheng","xing","ai","lu","zhui","zhou","she","pian","kun","tao","lai","zong","ke","qi","qi","yan","fei","sao","yan","ge","yao","wu","pian","cong","pian","qian","fei","huang","qian","huo","yu","ti","quan","xia","zong","kui","rou","si","gua","tuo","gui","sou","qian","cheng","zhi","liu","peng","teng","xi",
"cao","du","yan","yuan","zou","sao","shan","li","zhi","shuang","lu","xi","luo","zhang","mo","ao","can","biao","cong","qu","bi","zhi","yu","xu","hua","bo","su","xiao","lin","zhan","dun","liu","tuo","ceng","dian","jiao","tie","yan","luo","zhan","jing","yi","ye","tuo","pin","zhou","yan","long","lu","teng","xiang","ji","shuang","ju","xi","huan","li","biao","ma","yu","tuo","xun","chi","qu","ri","bo","lu","zang","shi","si","fu","ju","zou","zhu","tuo","nu","jia","yi","dai","xiao","ma","yin","jiao","hua","luo","hai","pian","biao","li","cheng","yan","xing","qin","jun","qi","qi","ke","zhui","zong","su","can","pian","zhi","kui","sao","wu","ao","liu","qian","shan","biao","luo","cong","chan","zhou","ji","shuang","xiang","gu","wei","wei","wei","yu","gan","yi","ang","tou","jie","bao",
"bei","ci","ti","di","ku","hai","qiao","hou","kua","ge","tui","geng","pian","bi","ke","qia","yu","sui","lou","bo","xiao","bang","bo","ci","kuan","bin","mo","liao","lou","xiao","du","zang","sui","ti","bin","kuan","lu","gao","gao","qiao","kao","qiao","lao","sao","biao","kun","kun","di","fang","xiu","ran","mao","dan","kun","bin","fa","tiao","pi","zi","fa","ran","ti","bao","bi","mao","fu","er","rong","qu","gong","xiu","kuo","ji","peng","zhua","shao","suo","ti","li","bin","zong","di","peng","song","zheng","quan","zong","shun","jian","tuo","hu","la","jiu","qi","lian","zhen","bin","peng","ma","san","man","man","seng","xu","lie","qian","qian","nang","huan","kuo","ning","bin","lie","rang","dou","dou","nao","hong","xi","dou","han","dou","dou","jiu","chang","yu","yu","ge","yan",
"fu","qin","gui","zong","liu","gui","shang","yu","gui","mei","ji","qi","ga","kui","hun","ba","po","mei","xu","yan","xiao","liang","yu","tui","qi","wang","liang","wei","gan","chi","piao","bi","mo","ji","xu","chou","yan","zhan","yu","dao","ren","jie","ba","hong","tuo","diao","ji","xu","e","e","sha","hang","tun","mo","jie","shen","ban","yuan","pi","lu","wen","hu","lu","za","fang","fen","na","you","pian","mo","he","xia","qu","han","pi","ling","tuo","bo","qiu","ping","fu","bi","ci","wei","ju","diao","ba","you","gun","pi","nian","xing","tai","bao","fu","zha","ju","gu","shi","dong","dai","ta","jie","shu","hou","xiang","er","an","wei","zhao","zhu","yin","lie","luo","tong","ti","yi","bing","wei","jiao","ku","gui","xian","ge","hui","lao","fu","kao","xiu",
"duo","jun","ti","mian","shao","zha","suo","qin","yu","nei","zhe","gun","geng","su","wu","qiu","shan","pu","huan","tiao","li","sha","sha","kao","meng","cheng","li","zou","xi","yong","ni","zi","qi","zheng","xiang","nei","chun","ji","diao","qie","gu","zhou","dong","lai","fei","ni","yi","kun","lu","jiu","chang","jing","lun","ling","zou","li","meng","zong","zhi","nian","hu","yu","di","shi","shen","hun","ti","hou","xing","zhu","la","zong","zei","bian","bian","huan","quan","zei","wei","wei","yu","chun","rou","die","huang","lian","yan","qiu","qiu","jian","bi","e","yang","fu","sai","gan","xia","tuo","hu","shi","ruo","xuan","wen","qian","hao","wu","fang","sao","liu","ma","shi","shi","guan","zi","teng","ta","yao","e","yong","qian","qi","wen","ruo","shen","lian","ao","le","hui","min",
"ji","tiao","qu","jian","shen","man","xi","qiu","biao","ji","ji","zhu","jiang","xiu","zhuan","yong","zhang","kang","xue","bie","yu","qu","xiang","bo","jiao","xun","su","huang","zun","shan","shan","fan","gui","lin","xun","miao","xi","zeng","xiang","fen","guan","hou","kuai","zei","sao","zhan","gan","gui","ying","li","chang","lei","shu","ai","ru","ji","xu","hu","shu","li","lie","li","mie","zhen","xiang","e","lu","guan","li","xian","yu","dao","ji","you","tun","lu","fang","ba","he","ba","ping","nian","lu","you","zha","fu","ba","bao","hou","pi","tai","gui","jie","kao","wei","er","tong","zei","hou","kuai","ji","jiao","xian","zha","xiang","xun","geng","li","lian","jian","li","shi","tiao","gun","sha","huan","jun","ji","yong","qing","ling","qi","zou","fei","kun","chang","gu","ni","nian",
"diao","jing","shen","shi","zi","fen","die","bi","chang","ti","wen","wei","sai","e","qiu","fu","huang","quan","jiang","bian","sao","ao","qi","ta","guan","yao","pang","jian","le","biao","xue","bie","man","min","yong","wei","xi","gui","shan","lin","zun","hu","gan","li","zhan","guan","niao","yi","fu","li","jiu","bu","yan","fu","diao","ji","feng","ru","gan","shi","feng","ming","bao","yuan","zhi","hu","qin","fu","ban","wen","jian","shi","yu","fou","yao","jue","jue","pi","huan","zhen","bao","yan","ya","zheng","fang","feng","wen","ou","dai","ge","ru","ling","mie","fu","tuo","min","li","bian","zhi","ge","yuan","ci","qu","xiao","chi","dan","ju","yao","gu","dong","yu","yang","rong","ya","tie","yu","tian","ying","dui","wu","er","gua","ai","zhi","yan","heng","xiao","jia","lie",
"zhu","yang","ti","hong","luo","ru","mou","ge","ren","jiao","xiu","zhou","zhi","luo","heng","nian","e","luan","jia","ji","tu","huan","tuo","bu","wu","juan","yu","bo","jun","xun","bi","xi","jun","ju","tu","jing","ti","e","e","kuang","hu","wu","shen","lai","jiao","pan","lu","pi","shu","fu","an","zhuo","peng","qin","qian","bei","diao","lu","que","jian","ju","tu","ya","yuan","qi","li","ye","zhui","kong","duo","kun","sheng","qi","jing","yi","yi","jing","zi","lai","dong","qi","chun","geng","ju","jue","yi","zun","ji","shu","ying","chi","miao","rou","an","qiu","ti","hu","ti","e","jie","mao","fu","chun","tu","yan","he","yuan","pian","kun","mei","hu","ying","chuan","wu","ju","dong","cang","fang","he","ying","yuan","xian","weng","shi","he","chu","tang","xia","ruo",
"liu","ji","gu","jian","sun","han","ci","ci","yi","yao","yan","ji","li","tian","kou","ti","ti","yi","tu","ma","jiao","gao","tian","chen","ji","tuan","zhe","ao","yao","yi","ou","chi","zhi","liu","yong","lu","bi","shuang","zhuo","yu","wu","jue","yin","ti","si","jiao","yi","hua","bi","ying","su","huang","fan","jiao","liao","yan","gao","jiu","xian","xian","tu","mai","zun","yu","ying","lu","tuan","xian","xue","yi","pi","chu","luo","xi","yi","ji","ze","yu","zhan","ye","yang","pi","ning","hu","mi","ying","meng","di","yue","yu","lei","bao","lu","he","long","shuang","yue","ying","guan","qu","li","luan","niao","jiu","ji","yuan","ming","shi","ou","ya","cang","bao","zhen","gu","dong","lu","ya","xiao","yang","ling","chi","qu","yuan","xue","tuo","si","zhi","er","gua",
"xiu","heng","zhou","ge","luan","hong","wu","bo","li","juan","gu","e","yu","xian","ti","wu","que","miao","an","kun","bei","peng","qian","chun","geng","yuan","su","hu","he","e","gu","qiu","ci","mei","wu","yi","yao","weng","liu","ji","yi","jian","he","yi","ying","zhe","liu","liao","jiao","jiu","yu","lu","huan","zhan","ying","hu","meng","guan","shuang","lu","jin","ling","jian","xian","cuo","jian","jian","yan","cuo","lu","you","cu","ji","pao","cu","pao","zhu","jun","zhu","jian","mi","mi","yu","liu","chen","jun","lin","ni","qi","lu","jiu","jun","jing","li","xiang","xian","jia","mi","li","she","zhang","lin","jing","qi","ling","yan","cu","mai","mai","he","chao","fu","mian","mian","fu","pao","qu","qu","mou","fu","xian","lai","qu","mian","chi","feng","fu","qu","mian",
"ma","me","mo","hui","mo","zou","nun","fen","huang","huang","jin","guang","tian","tou","hong","hua","kuang","hong","shu","li","nian","chi","hei","hei","yi","qian","dan","xi","tun","mo","mo","qian","dai","chu","you","dian","yi","xia","yan","qu","mei","yan","qing","yue","li","dang","du","can","yan","yan","yan","dan","an","zhen","dai","can","yi","mei","zhan","yan","du","lu","zhi","fen","fu","fu","mian","mian","yuan","cu","qu","chao","wa","zhu","zhi","meng","ao","bie","tuo","bi","yuan","chao","tuo","ding","mi","nai","ding","zi","gu","gu","dong","fen","tao","yuan","pi","chang","gao","qi","yuan","tang","teng","shu","shu","fen","fei","wen","ba","diao","tuo","zhong","qu","sheng","shi","you","shi","ting","wu","nian","jing","hun","ju","yan","tu","si","xi","xian","yan","lei","bi",
"yao","qiu","han","wu","wu","hou","xie","e","zha","xiu","weng","zha","nong","nang","qi","zhai","ji","zi","ji","ji","qi","ji","chi","chen","chen","he","ya","yin","xie","bao","ze","xie","chai","chi","yan","ju","tiao","ling","ling","chu","quan","xie","ken","nie","jiu","yao","chuo","kun","yu","chu","yi","ni","ze","zou","qu","yun","yan","ou","e","wo","yi","ci","zou","dian","chu","jin","ya","chi","chen","he","yin","ju","ling","bao","tiao","zi","ken","yu","chuo","qu","wo","long","pang","gong","pang","yan","long","long","gong","kan","da","ling","da","long","gong","kan","gui","qiu","bie","gui","yue","chui","he","jue","xie","yu",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"shan",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"ga","gag","gakk","gags","gan","ganj","ganh","gad","gal","galg","galm","galb","gals","galt","galp","galh","gam","gab","gabs","gas","gass","gang","gaj","gach","gak","gat","gap","gah","gae","gaeg","gaekk","gaegs","gaen","gaenj","gaenh","gaed","gael","gaelg","gaelm","gaelb","gaels","gaelt","gaelp","gaelh","gaem","gaeb","gaebs","gaes","gaess","gaeng","gaej","gaech","gaek","gaet","gaep","gaeh","gya","gyag","gyakk","gyags","gyan","gyanj","gyanh","gyad","gyal","gyalg","gyalm","gyalb","gyals","gyalt","gyalp","gyalh","gyam","gyab","gyabs","gyas","gyass","gyang","gyaj","gyach","gyak","gyat","gyap","gyah","gyae","gyaeg",
"gyaekk","gyaegs","gyaen","gyaenj","gyaenh","gyaed","gyael","gyaelg","gyaelm","gyaelb","gyaels","gyaelt","gyaelp","gyaelh","gyaem","gyaeb","gyaebs","gyaes","gyaess","gyaeng","gyaej","gyaech","gyaek","gyaet","gyaep","gyaeh","geo","geog","geokk","geogs","geon","geonj","geonh","geod","geol","geolg","geolm","geolb","geols","geolt","geolp","geolh","geom","geob","geobs","geos","geoss","geong","geoj","geoch","geok","geot","geop","geoh","ge","geg","gekk","gegs","gen","genj","genh","ged","gel","gelg","gelm","gelb","gels","gelt","gelp","gelh","gem","geb","gebs","ges","gess","geng","gej","gech","gek","get","gep","geh","gyeo","gyeog","gyeokk","gyeogs","gyeon","gyeonj","gyeonh","gyeod","gyeol","gyeolg","gyeolm","gyeolb","gyeols","gyeolt","gyeolp","gyeolh","gyeom","gyeob","gyeobs","gyeos","gyeoss","gyeong","gyeoj","gyeoch","gyeok","gyeot","gyeop","gyeoh","gye","gyeg","gyekk","gyegs","gyen","gyenj","gyenh","gyed","gyel","gyelg","gyelm","gyelb","gyels","gyelt","gyelp","gyelh","gyem","gyeb","gyebs",
"gyes","gyess","gyeng","gyej","gyech","gyek","gyet","gyep","gyeh","go","gog","gokk","gogs","gon","gonj","gonh","god","gol","golg","golm","golb","gols","golt","golp","golh","gom","gob","gobs","gos","goss","gong","goj","goch","gok","got","gop","goh","gwa","gwag","gwakk","gwags","gwan","gwanj","gwanh","gwad","gwal","gwalg","gwalm","gwalb","gwals","gwalt","gwalp","gwalh","gwam","gwab","gwabs","gwas","gwass","gwang","gwaj","gwach","gwak","gwat","gwap","gwah","gwae","gwaeg","gwaekk","gwaegs","gwaen","gwaenj","gwaenh","gwaed","gwael","gwaelg","gwaelm","gwaelb","gwaels","gwaelt","gwaelp","gwaelh","gwaem","gwaeb","gwaebs","gwaes","gwaess","gwaeng","gwaej","gwaech","gwaek","gwaet","gwaep","gwaeh","goe","goeg","goekk","goegs","goen","goenj","goenh","goed","goel","goelg","goelm","goelb","goels","goelt","goelp","goelh","goem","goeb","goebs","goes","goess","goeng","goej","goech","goek","goet","goep","goeh","gyo","gyog","gyokk","gyogs","gyon","gyonj","gyonh","gyod",
"gyol","gyolg","gyolm","gyolb","gyols","gyolt","gyolp","gyolh","gyom","gyob","gyobs","gyos","gyoss","gyong","gyoj","gyoch","gyok","gyot","gyop","gyoh","gu","gug","gukk","gugs","gun","gunj","gunh","gud","gul","gulg","gulm","gulb","guls","gult","gulp","gulh","gum","gub","gubs","gus","guss","gung","guj","guch","guk","gut","gup","guh","gwo","gwog","gwokk","gwogs","gwon","gwonj","gwonh","gwod","gwol","gwolg","gwolm","gwolb","gwols","gwolt","gwolp","gwolh","gwom","gwob","gwobs","gwos","gwoss","gwong","gwoj","gwoch","gwok","gwot","gwop","gwoh","gwe","gweg","gwekk","gwegs","gwen","gwenj","gwenh","gwed","gwel","gwelg","gwelm","gwelb","gwels","gwelt","gwelp","gwelh","gwem","gweb","gwebs","gwes","gwess","gweng","gwej","gwech","gwek","gwet","gwep","gweh","gwi","gwig","gwikk","gwigs","gwin","gwinj","gwinh","gwid","gwil","gwilg","gwilm","gwilb","gwils","gwilt","gwilp","gwilh","gwim","gwib","gwibs","gwis","gwiss","gwing","gwij","gwich","gwik",
"gwit","gwip","gwih","gyu","gyug","gyukk","gyugs","gyun","gyunj","gyunh","gyud","gyul","gyulg","gyulm","gyulb","gyuls","gyult","gyulp","gyulh","gyum","gyub","gyubs","gyus","gyuss","gyung","gyuj","gyuch","gyuk","gyut","gyup","gyuh","geu","geug","geukk","geugs","geun","geunj","geunh","geud","geul","geulg","geulm","geulb","geuls","geult","geulp","geulh","geum","geub","geubs","geus","geuss","geung","geuj","geuch","geuk","geut","geup","geuh","gui","guig","guikk","guigs","guin","guinj","guinh","guid","guil","guilg","guilm","guilb","guils","guilt","guilp","guilh","guim","guib","guibs","guis","guiss","guing","guij","guich","guik","guit","guip","guih","gi","gig","gikk","gigs","gin","ginj","ginh","gid","gil","gilg","gilm","gilb","gils","gilt","gilp","gilh","gim","gib","gibs","gis","giss","ging","gij","gich","gik","git","gip","gih","kka","kkag","kkakk","kkags","kkan","kkanj","kkanh","kkad","kkal","kkalg","kkalm","kkalb","kkals","kkalt",
"kkalp","kkalh","kkam","kkab","kkabs","kkas","kkass","kkang","kkaj","kkach","kkak","kkat","kkap","kkah","kkae","kkaeg","kkaekk","kkaegs","kkaen","kkaenj","kkaenh","kkaed","kkael","kkaelg","kkaelm","kkaelb","kkaels","kkaelt","kkaelp","kkaelh","kkaem","kkaeb","kkaebs","kkaes","kkaess","kkaeng","kkaej","kkaech","kkaek","kkaet","kkaep","kkaeh","kkya","kkyag","kkyakk","kkyags","kkyan","kkyanj","kkyanh","kkyad","kkyal","kkyalg","kkyalm","kkyalb","kkyals","kkyalt","kkyalp","kkyalh","kkyam","kkyab","kkyabs","kkyas","kkyass","kkyang","kkyaj","kkyach","kkyak","kkyat","kkyap","kkyah","kkyae","kkyaeg","kkyaekk","kkyaegs","kkyaen","kkyaenj","kkyaenh","kkyaed","kkyael","kkyaelg","kkyaelm","kkyaelb","kkyaels","kkyaelt","kkyaelp","kkyaelh","kkyaem","kkyaeb","kkyaebs","kkyaes","kkyaess","kkyaeng","kkyaej","kkyaech","kkyaek","kkyaet","kkyaep","kkyaeh","kkeo","kkeog","kkeokk","kkeogs","kkeon","kkeonj","kkeonh","kkeod","kkeol","kkeolg","kkeolm","kkeolb","kkeols","kkeolt","kkeolp","kkeolh","kkeom","kkeob","kkeobs","kkeos","kkeoss","kkeong","kkeoj","kkeoch","kkeok","kkeot","kkeop","kkeoh","kke","kkeg","kkekk",
"kkegs","kken","kkenj","kkenh","kked","kkel","kkelg","kkelm","kkelb","kkels","kkelt","kkelp","kkelh","kkem","kkeb","kkebs","kkes","kkess","kkeng","kkej","kkech","kkek","kket","kkep","kkeh","kkyeo","kkyeog","kkyeokk","kkyeogs","kkyeon","kkyeonj","kkyeonh","kkyeod","kkyeol","kkyeolg","kkyeolm","kkyeolb","kkyeols","kkyeolt","kkyeolp","kkyeolh","kkyeom","kkyeob","kkyeobs","kkyeos","kkyeoss","kkyeong","kkyeoj","kkyeoch","kkyeok","kkyeot","kkyeop","kkyeoh","kkye","kkyeg","kkyekk","kkyegs","kkyen","kkyenj","kkyenh","kkyed","kkyel","kkyelg","kkyelm","kkyelb","kkyels","kkyelt","kkyelp","kkyelh","kkyem","kkyeb","kkyebs","kkyes","kkyess","kkyeng","kkyej","kkyech","kkyek","kkyet","kkyep","kkyeh","kko","kkog","kkokk","kkogs","kkon","kkonj","kkonh","kkod","kkol","kkolg","kkolm","kkolb","kkols","kkolt","kkolp","kkolh","kkom","kkob","kkobs","kkos","kkoss","kkong","kkoj","kkoch","kkok","kkot","kkop","kkoh","kkwa","kkwag","kkwakk","kkwags","kkwan","kkwanj","kkwanh","kkwad","kkwal","kkwalg","kkwalm","kkwalb","kkwals","kkwalt","kkwalp","kkwalh","kkwam","kkwab","kkwabs","kkwas",
"kkwass","kkwang","kkwaj","kkwach","kkwak","kkwat","kkwap","kkwah","kkwae","kkwaeg","kkwaekk","kkwaegs","kkwaen","kkwaenj","kkwaenh","kkwaed","kkwael","kkwaelg","kkwaelm","kkwaelb","kkwaels","kkwaelt","kkwaelp","kkwaelh","kkwaem","kkwaeb","kkwaebs","kkwaes","kkwaess","kkwaeng","kkwaej","kkwaech","kkwaek","kkwaet","kkwaep","kkwaeh","kkoe","kkoeg","kkoekk","kkoegs","kkoen","kkoenj","kkoenh","kkoed","kkoel","kkoelg","kkoelm","kkoelb","kkoels","kkoelt","kkoelp","kkoelh","kkoem","kkoeb","kkoebs","kkoes","kkoess","kkoeng","kkoej","kkoech","kkoek","kkoet","kkoep","kkoeh","kkyo","kkyog","kkyokk","kkyogs","kkyon","kkyonj","kkyonh","kkyod","kkyol","kkyolg","kkyolm","kkyolb","kkyols","kkyolt","kkyolp","kkyolh","kkyom","kkyob","kkyobs","kkyos","kkyoss","kkyong","kkyoj","kkyoch","kkyok","kkyot","kkyop","kkyoh","kku","kkug","kkukk","kkugs","kkun","kkunj","kkunh","kkud","kkul","kkulg","kkulm","kkulb","kkuls","kkult","kkulp","kkulh","kkum","kkub","kkubs","kkus","kkuss","kkung","kkuj","kkuch","kkuk","kkut","kkup","kkuh","kkwo","kkwog","kkwokk","kkwogs","kkwon","kkwonj","kkwonh","kkwod","kkwol",
"kkwolg","kkwolm","kkwolb","kkwols","kkwolt","kkwolp","kkwolh","kkwom","kkwob","kkwobs","kkwos","kkwoss","kkwong","kkwoj","kkwoch","kkwok","kkwot","kkwop","kkwoh","kkwe","kkweg","kkwekk","kkwegs","kkwen","kkwenj","kkwenh","kkwed","kkwel","kkwelg","kkwelm","kkwelb","kkwels","kkwelt","kkwelp","kkwelh","kkwem","kkweb","kkwebs","kkwes","kkwess","kkweng","kkwej","kkwech","kkwek","kkwet","kkwep","kkweh","kkwi","kkwig","kkwikk","kkwigs","kkwin","kkwinj","kkwinh","kkwid","kkwil","kkwilg","kkwilm","kkwilb","kkwils","kkwilt","kkwilp","kkwilh","kkwim","kkwib","kkwibs","kkwis","kkwiss","kkwing","kkwij","kkwich","kkwik","kkwit","kkwip","kkwih","kkyu","kkyug","kkyukk","kkyugs","kkyun","kkyunj","kkyunh","kkyud","kkyul","kkyulg","kkyulm","kkyulb","kkyuls","kkyult","kkyulp","kkyulh","kkyum","kkyub","kkyubs","kkyus","kkyuss","kkyung","kkyuj","kkyuch","kkyuk","kkyut","kkyup","kkyuh","kkeu","kkeug","kkeukk","kkeugs","kkeun","kkeunj","kkeunh","kkeud","kkeul","kkeulg","kkeulm","kkeulb","kkeuls","kkeult","kkeulp","kkeulh","kkeum","kkeub","kkeubs","kkeus","kkeuss","kkeung","kkeuj","kkeuch","kkeuk","kkeut",
"kkeup","kkeuh","kkui","kkuig","kkuikk","kkuigs","kkuin","kkuinj","kkuinh","kkuid","kkuil","kkuilg","kkuilm","kkuilb","kkuils","kkuilt","kkuilp","kkuilh","kkuim","kkuib","kkuibs","kkuis","kkuiss","kkuing","kkuij","kkuich","kkuik","kkuit","kkuip","kkuih","kki","kkig","kkikk","kkigs","kkin","kkinj","kkinh","kkid","kkil","kkilg","kkilm","kkilb","kkils","kkilt","kkilp","kkilh","kkim","kkib","kkibs","kkis","kkiss","kking","kkij","kkich","kkik","kkit","kkip","kkih","na","nag","nakk","nags","nan","nanj","nanh","nad","nal","nalg","nalm","nalb","nals","nalt","nalp","nalh","nam","nab","nabs","nas","nass","nang","naj","nach","nak","nat","nap","nah","nae","naeg","naekk","naegs","naen","naenj","naenh","naed","nael","naelg","naelm","naelb","naels","naelt","naelp","naelh","naem","naeb","naebs","naes","naess","naeng","naej","naech","naek","naet","naep","naeh","nya","nyag","nyakk","nyags","nyan","nyanj","nyanh","nyad","nyal","nyalg","nyalm","nyalb","nyals","nyalt","nyalp",
"nyalh","nyam","nyab","nyabs","nyas","nyass","nyang","nyaj","nyach","nyak","nyat","nyap","nyah","nyae","nyaeg","nyaekk","nyaegs","nyaen","nyaenj","nyaenh","nyaed","nyael","nyaelg","nyaelm","nyaelb","nyaels","nyaelt","nyaelp","nyaelh","nyaem","nyaeb","nyaebs","nyaes","nyaess","nyaeng","nyaej","nyaech","nyaek","nyaet","nyaep","nyaeh","neo","neog","neokk","neogs","neon","neonj","neonh","neod","neol","neolg","neolm","neolb","neols","neolt","neolp","neolh","neom","neob","neobs","neos","neoss","neong","neoj","neoch","neok","neot","neop","neoh","ne","neg","nekk","negs","nen","nenj","nenh","ned","nel","nelg","nelm","nelb","nels","nelt","nelp","nelh","nem","neb","nebs","nes","ness","neng","nej","nech","nek","net","nep","neh","nyeo","nyeog","nyeokk","nyeogs","nyeon","nyeonj","nyeonh","nyeod","nyeol","nyeolg","nyeolm","nyeolb","nyeols","nyeolt","nyeolp","nyeolh","nyeom","nyeob","nyeobs","nyeos","nyeoss","nyeong","nyeoj","nyeoch","nyeok","nyeot","nyeop","nyeoh","nye","nyeg","nyekk","nyegs",
"nyen","nyenj","nyenh","nyed","nyel","nyelg","nyelm","nyelb","nyels","nyelt","nyelp","nyelh","nyem","nyeb","nyebs","nyes","nyess","nyeng","nyej","nyech","nyek","nyet","nyep","nyeh","no","nog","nokk","nogs","non","nonj","nonh","nod","nol","nolg","nolm","nolb","nols","nolt","nolp","nolh","nom","nob","nobs","nos","noss","nong","noj","noch","nok","not","nop","noh","nwa","nwag","nwakk","nwags","nwan","nwanj","nwanh","nwad","nwal","nwalg","nwalm","nwalb","nwals","nwalt","nwalp","nwalh","nwam","nwab","nwabs","nwas","nwass","nwang","nwaj","nwach","nwak","nwat","nwap","nwah","nwae","nwaeg","nwaekk","nwaegs","nwaen","nwaenj","nwaenh","nwaed","nwael","nwaelg","nwaelm","nwaelb","nwaels","nwaelt","nwaelp","nwaelh","nwaem","nwaeb","nwaebs","nwaes","nwaess","nwaeng","nwaej","nwaech","nwaek","nwaet","nwaep","nwaeh","noe","noeg","noekk","noegs","noen","noenj","noenh","noed","noel","noelg","noelm","noelb","noels","noelt","noelp","noelh","noem","noeb","noebs","noes","noess",
"noeng","noej","noech","noek","noet","noep","noeh","nyo","nyog","nyokk","nyogs","nyon","nyonj","nyonh","nyod","nyol","nyolg","nyolm","nyolb","nyols","nyolt","nyolp","nyolh","nyom","nyob","nyobs","nyos","nyoss","nyong","nyoj","nyoch","nyok","nyot","nyop","nyoh","nu","nug","nukk","nugs","nun","nunj","nunh","nud","nul","nulg","nulm","nulb","nuls","nult","nulp","nulh","num","nub","nubs","nus","nuss","nung","nuj","nuch","nuk","nut","nup","nuh","nwo","nwog","nwokk","nwogs","nwon","nwonj","nwonh","nwod","nwol","nwolg","nwolm","nwolb","nwols","nwolt","nwolp","nwolh","nwom","nwob","nwobs","nwos","nwoss","nwong","nwoj","nwoch","nwok","nwot","nwop","nwoh","nwe","nweg","nwekk","nwegs","nwen","nwenj","nwenh","nwed","nwel","nwelg","nwelm","nwelb","nwels","nwelt","nwelp","nwelh","nwem","nweb","nwebs","nwes","nwess","nweng","nwej","nwech","nwek","nwet","nwep","nweh","nwi","nwig","nwikk","nwigs","nwin","nwinj","nwinh","nwid","nwil","nwilg",
"nwilm","nwilb","nwils","nwilt","nwilp","nwilh","nwim","nwib","nwibs","nwis","nwiss","nwing","nwij","nwich","nwik","nwit","nwip","nwih","nyu","nyug","nyukk","nyugs","nyun","nyunj","nyunh","nyud","nyul","nyulg","nyulm","nyulb","nyuls","nyult","nyulp","nyulh","nyum","nyub","nyubs","nyus","nyuss","nyung","nyuj","nyuch","nyuk","nyut","nyup","nyuh","neu","neug","neukk","neugs","neun","neunj","neunh","neud","neul","neulg","neulm","neulb","neuls","neult","neulp","neulh","neum","neub","neubs","neus","neuss","neung","neuj","neuch","neuk","neut","neup","neuh","nui","nuig","nuikk","nuigs","nuin","nuinj","nuinh","nuid","nuil","nuilg","nuilm","nuilb","nuils","nuilt","nuilp","nuilh","nuim","nuib","nuibs","nuis","nuiss","nuing","nuij","nuich","nuik","nuit","nuip","nuih","ni","nig","nikk","nigs","nin","ninj","ninh","nid","nil","nilg","nilm","nilb","nils","nilt","nilp","nilh","nim","nib","nibs","nis","niss","ning","nij","nich","nik","nit","nip",
"nih","da","dag","dakk","dags","dan","danj","danh","dad","dal","dalg","dalm","dalb","dals","dalt","dalp","dalh","dam","dab","dabs","das","dass","dang","daj","dach","dak","dat","dap","dah","dae","daeg","daekk","daegs","daen","daenj","daenh","daed","dael","daelg","daelm","daelb","daels","daelt","daelp","daelh","daem","daeb","daebs","daes","daess","daeng","daej","daech","daek","daet","daep","daeh","dya","dyag","dyakk","dyags","dyan","dyanj","dyanh","dyad","dyal","dyalg","dyalm","dyalb","dyals","dyalt","dyalp","dyalh","dyam","dyab","dyabs","dyas","dyass","dyang","dyaj","dyach","dyak","dyat","dyap","dyah","dyae","dyaeg","dyaekk","dyaegs","dyaen","dyaenj","dyaenh","dyaed","dyael","dyaelg","dyaelm","dyaelb","dyaels","dyaelt","dyaelp","dyaelh","dyaem","dyaeb","dyaebs","dyaes","dyaess","dyaeng","dyaej","dyaech","dyaek","dyaet","dyaep","dyaeh","deo","deog","deokk","deogs","deon","deonj","deonh","deod","deol","deolg","deolm","deolb","deols","deolt","deolp","deolh",
"deom","deob","deobs","deos","deoss","deong","deoj","deoch","deok","deot","deop","deoh","de","deg","dekk","degs","den","denj","denh","ded","del","delg","delm","delb","dels","delt","delp","delh","dem","deb","debs","des","dess","deng","dej","dech","dek","det","dep","deh","dyeo","dyeog","dyeokk","dyeogs","dyeon","dyeonj","dyeonh","dyeod","dyeol","dyeolg","dyeolm","dyeolb","dyeols","dyeolt","dyeolp","dyeolh","dyeom","dyeob","dyeobs","dyeos","dyeoss","dyeong","dyeoj","dyeoch","dyeok","dyeot","dyeop","dyeoh","dye","dyeg","dyekk","dyegs","dyen","dyenj","dyenh","dyed","dyel","dyelg","dyelm","dyelb","dyels","dyelt","dyelp","dyelh","dyem","dyeb","dyebs","dyes","dyess","dyeng","dyej","dyech","dyek","dyet","dyep","dyeh","do","dog","dokk","dogs","don","donj","donh","dod","dol","dolg","dolm","dolb","dols","dolt","dolp","dolh","dom","dob","dobs","dos","doss","dong","doj","doch","dok","dot","dop","doh","dwa","dwag","dwakk","dwags","dwan",
"dwanj","dwanh","dwad","dwal","dwalg","dwalm","dwalb","dwals","dwalt","dwalp","dwalh","dwam","dwab","dwabs","dwas","dwass","dwang","dwaj","dwach","dwak","dwat","dwap","dwah","dwae","dwaeg","dwaekk","dwaegs","dwaen","dwaenj","dwaenh","dwaed","dwael","dwaelg","dwaelm","dwaelb","dwaels","dwaelt","dwaelp","dwaelh","dwaem","dwaeb","dwaebs","dwaes","dwaess","dwaeng","dwaej","dwaech","dwaek","dwaet","dwaep","dwaeh","doe","doeg","doekk","doegs","doen","doenj","doenh","doed","doel","doelg","doelm","doelb","doels","doelt","doelp","doelh","doem","doeb","doebs","does","doess","doeng","doej","doech","doek","doet","doep","doeh","dyo","dyog","dyokk","dyogs","dyon","dyonj","dyonh","dyod","dyol","dyolg","dyolm","dyolb","dyols","dyolt","dyolp","dyolh","dyom","dyob","dyobs","dyos","dyoss","dyong","dyoj","dyoch","dyok","dyot","dyop","dyoh","du","dug","dukk","dugs","dun","dunj","dunh","dud","dul","dulg","dulm","dulb","duls","dult","dulp","dulh","dum","dub","dubs","dus","duss","dung",
"duj","duch","duk","dut","dup","duh","dwo","dwog","dwokk","dwogs","dwon","dwonj","dwonh","dwod","dwol","dwolg","dwolm","dwolb","dwols","dwolt","dwolp","dwolh","dwom","dwob","dwobs","dwos","dwoss","dwong","dwoj","dwoch","dwok","dwot","dwop","dwoh","dwe","dweg","dwekk","dwegs","dwen","dwenj","dwenh","dwed","dwel","dwelg","dwelm","dwelb","dwels","dwelt","dwelp","dwelh","dwem","dweb","dwebs","dwes","dwess","dweng","dwej","dwech","dwek","dwet","dwep","dweh","dwi","dwig","dwikk","dwigs","dwin","dwinj","dwinh","dwid","dwil","dwilg","dwilm","dwilb","dwils","dwilt","dwilp","dwilh","dwim","dwib","dwibs","dwis","dwiss","dwing","dwij","dwich","dwik","dwit","dwip","dwih","dyu","dyug","dyukk","dyugs","dyun","dyunj","dyunh","dyud","dyul","dyulg","dyulm","dyulb","dyuls","dyult","dyulp","dyulh","dyum","dyub","dyubs","dyus","dyuss","dyung","dyuj","dyuch","dyuk","dyut","dyup","dyuh","deu","deug","deukk","deugs","deun","deunj","deunh","deud","deul","deulg","deulm",
"deulb","deuls","deult","deulp","deulh","deum","deub","deubs","deus","deuss","deung","deuj","deuch","deuk","deut","deup","deuh","dui","duig","duikk","duigs","duin","duinj","duinh","duid","duil","duilg","duilm","duilb","duils","duilt","duilp","duilh","duim","duib","duibs","duis","duiss","duing","duij","duich","duik","duit","duip","duih","di","dig","dikk","digs","din","dinj","dinh","did","dil","dilg","dilm","dilb","dils","dilt","dilp","dilh","dim","dib","dibs","dis","diss","ding","dij","dich","dik","dit","dip","dih","tta","ttag","ttakk","ttags","ttan","ttanj","ttanh","ttad","ttal","ttalg","ttalm","ttalb","ttals","ttalt","ttalp","ttalh","ttam","ttab","ttabs","ttas","ttass","ttang","ttaj","ttach","ttak","ttat","ttap","ttah","ttae","ttaeg","ttaekk","ttaegs","ttaen","ttaenj","ttaenh","ttaed","ttael","ttaelg","ttaelm","ttaelb","ttaels","ttaelt","ttaelp","ttaelh","ttaem","ttaeb","ttaebs","ttaes","ttaess","ttaeng","ttaej","ttaech","ttaek","ttaet","ttaep","ttaeh",
"ttya","ttyag","ttyakk","ttyags","ttyan","ttyanj","ttyanh","ttyad","ttyal","ttyalg","ttyalm","ttyalb","ttyals","ttyalt","ttyalp","ttyalh","ttyam","ttyab","ttyabs","ttyas","ttyass","ttyang","ttyaj","ttyach","ttyak","ttyat","ttyap","ttyah","ttyae","ttyaeg","ttyaekk","ttyaegs","ttyaen","ttyaenj","ttyaenh","ttyaed","ttyael","ttyaelg","ttyaelm","ttyaelb","ttyaels","ttyaelt","ttyaelp","ttyaelh","ttyaem","ttyaeb","ttyaebs","ttyaes","ttyaess","ttyaeng","ttyaej","ttyaech","ttyaek","ttyaet","ttyaep","ttyaeh","tteo","tteog","tteokk","tteogs","tteon","tteonj","tteonh","tteod","tteol","tteolg","tteolm","tteolb","tteols","tteolt","tteolp","tteolh","tteom","tteob","tteobs","tteos","tteoss","tteong","tteoj","tteoch","tteok","tteot","tteop","tteoh","tte","tteg","ttekk","ttegs","tten","ttenj","ttenh","tted","ttel","ttelg","ttelm","ttelb","ttels","ttelt","ttelp","ttelh","ttem","tteb","ttebs","ttes","ttess","tteng","ttej","ttech","ttek","ttet","ttep","tteh","ttyeo","ttyeog","ttyeokk","ttyeogs","ttyeon","ttyeonj","ttyeonh","ttyeod","ttyeol","ttyeolg","ttyeolm","ttyeolb","ttyeols","ttyeolt","ttyeolp","ttyeolh","ttyeom",
"ttyeob","ttyeobs","ttyeos","ttyeoss","ttyeong","ttyeoj","ttyeoch","ttyeok","ttyeot","ttyeop","ttyeoh","ttye","ttyeg","ttyekk","ttyegs","ttyen","ttyenj","ttyenh","ttyed","ttyel","ttyelg","ttyelm","ttyelb","ttyels","ttyelt","ttyelp","ttyelh","ttyem","ttyeb","ttyebs","ttyes","ttyess","ttyeng","ttyej","ttyech","ttyek","ttyet","ttyep","ttyeh","tto","ttog","ttokk","ttogs","tton","ttonj","ttonh","ttod","ttol","ttolg","ttolm","ttolb","ttols","ttolt","ttolp","ttolh","ttom","ttob","ttobs","ttos","ttoss","ttong","ttoj","ttoch","ttok","ttot","ttop","ttoh","ttwa","ttwag","ttwakk","ttwags","ttwan","ttwanj","ttwanh","ttwad","ttwal","ttwalg","ttwalm","ttwalb","ttwals","ttwalt","ttwalp","ttwalh","ttwam","ttwab","ttwabs","ttwas","ttwass","ttwang","ttwaj","ttwach","ttwak","ttwat","ttwap","ttwah","ttwae","ttwaeg","ttwaekk","ttwaegs","ttwaen","ttwaenj","ttwaenh","ttwaed","ttwael","ttwaelg","ttwaelm","ttwaelb","ttwaels","ttwaelt","ttwaelp","ttwaelh","ttwaem","ttwaeb","ttwaebs","ttwaes","ttwaess","ttwaeng","ttwaej","ttwaech","ttwaek","ttwaet","ttwaep","ttwaeh","ttoe","ttoeg","ttoekk","ttoegs","ttoen","ttoenj",
"ttoenh","ttoed","ttoel","ttoelg","ttoelm","ttoelb","ttoels","ttoelt","ttoelp","ttoelh","ttoem","ttoeb","ttoebs","ttoes","ttoess","ttoeng","ttoej","ttoech","ttoek","ttoet","ttoep","ttoeh","ttyo","ttyog","ttyokk","ttyogs","ttyon","ttyonj","ttyonh","ttyod","ttyol","ttyolg","ttyolm","ttyolb","ttyols","ttyolt","ttyolp","ttyolh","ttyom","ttyob","ttyobs","ttyos","ttyoss","ttyong","ttyoj","ttyoch","ttyok","ttyot","ttyop","ttyoh","ttu","ttug","ttukk","ttugs","ttun","ttunj","ttunh","ttud","ttul","ttulg","ttulm","ttulb","ttuls","ttult","ttulp","ttulh","ttum","ttub","ttubs","ttus","ttuss","ttung","ttuj","ttuch","ttuk","ttut","ttup","ttuh","ttwo","ttwog","ttwokk","ttwogs","ttwon","ttwonj","ttwonh","ttwod","ttwol","ttwolg","ttwolm","ttwolb","ttwols","ttwolt","ttwolp","ttwolh","ttwom","ttwob","ttwobs","ttwos","ttwoss","ttwong","ttwoj","ttwoch","ttwok","ttwot","ttwop","ttwoh","ttwe","ttweg","ttwekk","ttwegs","ttwen","ttwenj","ttwenh","ttwed","ttwel","ttwelg","ttwelm","ttwelb","ttwels","ttwelt","ttwelp","ttwelh","ttwem","ttweb","ttwebs","ttwes","ttwess","ttweng","ttwej",
"ttwech","ttwek","ttwet","ttwep","ttweh","ttwi","ttwig","ttwikk","ttwigs","ttwin","ttwinj","ttwinh","ttwid","ttwil","ttwilg","ttwilm","ttwilb","ttwils","ttwilt","ttwilp","ttwilh","ttwim","ttwib","ttwibs","ttwis","ttwiss","ttwing","ttwij","ttwich","ttwik","ttwit","ttwip","ttwih","ttyu","ttyug","ttyukk","ttyugs","ttyun","ttyunj","ttyunh","ttyud","ttyul","ttyulg","ttyulm","ttyulb","ttyuls","ttyult","ttyulp","ttyulh","ttyum","ttyub","ttyubs","ttyus","ttyuss","ttyung","ttyuj","ttyuch","ttyuk","ttyut","ttyup","ttyuh","tteu","tteug","tteukk","tteugs","tteun","tteunj","tteunh","tteud","tteul","tteulg","tteulm","tteulb","tteuls","tteult","tteulp","tteulh","tteum","tteub","tteubs","tteus","tteuss","tteung","tteuj","tteuch","tteuk","tteut","tteup","tteuh","ttui","ttuig","ttuikk","ttuigs","ttuin","ttuinj","ttuinh","ttuid","ttuil","ttuilg","ttuilm","ttuilb","ttuils","ttuilt","ttuilp","ttuilh","ttuim","ttuib","ttuibs","ttuis","ttuiss","ttuing","ttuij","ttuich","ttuik","ttuit","ttuip","ttuih","tti","ttig","ttikk","ttigs","ttin","ttinj","ttinh","ttid","ttil","ttilg","ttilm","ttilb",
"ttils","ttilt","ttilp","ttilh","ttim","ttib","ttibs","ttis","ttiss","tting","ttij","ttich","ttik","ttit","ttip","ttih","la","lag","lakk","lags","lan","lanj","lanh","lad","lal","lalg","lalm","lalb","lals","lalt","lalp","lalh","lam","lab","labs","las","lass","lang","laj","lach","lak","lat","lap","lah","lae","laeg","laekk","laegs","laen","laenj","laenh","laed","lael","laelg","laelm","laelb","laels","laelt","laelp","laelh","laem","laeb","laebs","laes","laess","laeng","laej","laech","laek","laet","laep","laeh","lya","lyag","lyakk","lyags","lyan","lyanj","lyanh","lyad","lyal","lyalg","lyalm","lyalb","lyals","lyalt","lyalp","lyalh","lyam","lyab","lyabs","lyas","lyass","lyang","lyaj","lyach","lyak","lyat","lyap","lyah","lyae","lyaeg","lyaekk","lyaegs","lyaen","lyaenj","lyaenh","lyaed","lyael","lyaelg","lyaelm","lyaelb","lyaels","lyaelt","lyaelp","lyaelh","lyaem","lyaeb","lyaebs","lyaes","lyaess","lyaeng","lyaej","lyaech","lyaek","lyaet","lyaep","lyaeh","leo",
"leog","leokk","leogs","leon","leonj","leonh","leod","leol","leolg","leolm","leolb","leols","leolt","leolp","leolh","leom","leob","leobs","leos","leoss","leong","leoj","leoch","leok","leot","leop","leoh","le","leg","lekk","legs","len","lenj","lenh","led","lel","lelg","lelm","lelb","lels","lelt","lelp","lelh","lem","leb","lebs","les","less","leng","lej","lech","lek","let","lep","leh","lyeo","lyeog","lyeokk","lyeogs","lyeon","lyeonj","lyeonh","lyeod","lyeol","lyeolg","lyeolm","lyeolb","lyeols","lyeolt","lyeolp","lyeolh","lyeom","lyeob","lyeobs","lyeos","lyeoss","lyeong","lyeoj","lyeoch","lyeok","lyeot","lyeop","lyeoh","lye","lyeg","lyekk","lyegs","lyen","lyenj","lyenh","lyed","lyel","lyelg","lyelm","lyelb","lyels","lyelt","lyelp","lyelh","lyem","lyeb","lyebs","lyes","lyess","lyeng","lyej","lyech","lyek","lyet","lyep","lyeh","lo","log","lokk","logs","lon","lonj","lonh","lod","lol","lolg","lolm","lolb","lols","lolt","lolp","lolh","lom","lob",
"lobs","los","loss","long","loj","loch","lok","lot","lop","loh","lwa","lwag","lwakk","lwags","lwan","lwanj","lwanh","lwad","lwal","lwalg","lwalm","lwalb","lwals","lwalt","lwalp","lwalh","lwam","lwab","lwabs","lwas","lwass","lwang","lwaj","lwach","lwak","lwat","lwap","lwah","lwae","lwaeg","lwaekk","lwaegs","lwaen","lwaenj","lwaenh","lwaed","lwael","lwaelg","lwaelm","lwaelb","lwaels","lwaelt","lwaelp","lwaelh","lwaem","lwaeb","lwaebs","lwaes","lwaess","lwaeng","lwaej","lwaech","lwaek","lwaet","lwaep","lwaeh","loe","loeg","loekk","loegs","loen","loenj","loenh","loed","loel","loelg","loelm","loelb","loels","loelt","loelp","loelh","loem","loeb","loebs","loes","loess","loeng","loej","loech","loek","loet","loep","loeh","lyo","lyog","lyokk","lyogs","lyon","lyonj","lyonh","lyod","lyol","lyolg","lyolm","lyolb","lyols","lyolt","lyolp","lyolh","lyom","lyob","lyobs","lyos","lyoss","lyong","lyoj","lyoch","lyok","lyot","lyop","lyoh","lu","lug","lukk","lugs","lun","lunj","lunh",
"lud","lul","lulg","lulm","lulb","luls","lult","lulp","lulh","lum","lub","lubs","lus","luss","lung","luj","luch","luk","lut","lup","luh","lwo","lwog","lwokk","lwogs","lwon","lwonj","lwonh","lwod","lwol","lwolg","lwolm","lwolb","lwols","lwolt","lwolp","lwolh","lwom","lwob","lwobs","lwos","lwoss","lwong","lwoj","lwoch","lwok","lwot","lwop","lwoh","lwe","lweg","lwekk","lwegs","lwen","lwenj","lwenh","lwed","lwel","lwelg","lwelm","lwelb","lwels","lwelt","lwelp","lwelh","lwem","lweb","lwebs","lwes","lwess","lweng","lwej","lwech","lwek","lwet","lwep","lweh","lwi","lwig","lwikk","lwigs","lwin","lwinj","lwinh","lwid","lwil","lwilg","lwilm","lwilb","lwils","lwilt","lwilp","lwilh","lwim","lwib","lwibs","lwis","lwiss","lwing","lwij","lwich","lwik","lwit","lwip","lwih","lyu","lyug","lyukk","lyugs","lyun","lyunj","lyunh","lyud","lyul","lyulg","lyulm","lyulb","lyuls","lyult","lyulp","lyulh","lyum","lyub","lyubs","lyus","lyuss","lyung","lyuj","lyuch",
"lyuk","lyut","lyup","lyuh","leu","leug","leukk","leugs","leun","leunj","leunh","leud","leul","leulg","leulm","leulb","leuls","leult","leulp","leulh","leum","leub","leubs","leus","leuss","leung","leuj","leuch","leuk","leut","leup","leuh","lui","luig","luikk","luigs","luin","luinj","luinh","luid","luil","luilg","luilm","luilb","luils","luilt","luilp","luilh","luim","luib","luibs","luis","luiss","luing","luij","luich","luik","luit","luip","luih","li","lig","likk","ligs","lin","linj","linh","lid","lil","lilg","lilm","lilb","lils","lilt","lilp","lilh","lim","lib","libs","lis","liss","ling","lij","lich","lik","lit","lip","lih","ma","mag","makk","mags","man","manj","manh","mad","mal","malg","malm","malb","mals","malt","malp","malh","mam","mab","mabs","mas","mass","mang","maj","mach","mak","mat","map","mah","mae","maeg","maekk","maegs","maen","maenj","maenh","maed","mael","maelg","maelm","maelb","maels",
"maelt","maelp","maelh","maem","maeb","maebs","maes","maess","maeng","maej","maech","maek","maet","maep","maeh","mya","myag","myakk","myags","myan","myanj","myanh","myad","myal","myalg","myalm","myalb","myals","myalt","myalp","myalh","myam","myab","myabs","myas","myass","myang","myaj","myach","myak","myat","myap","myah","myae","myaeg","myaekk","myaegs","myaen","myaenj","myaenh","myaed","myael","myaelg","myaelm","myaelb","myaels","myaelt","myaelp","myaelh","myaem","myaeb","myaebs","myaes","myaess","myaeng","myaej","myaech","myaek","myaet","myaep","myaeh","meo","meog","meokk","meogs","meon","meonj","meonh","meod","meol","meolg","meolm","meolb","meols","meolt","meolp","meolh","meom","meob","meobs","meos","meoss","meong","meoj","meoch","meok","meot","meop","meoh","me","meg","mekk","megs","men","menj","menh","med","mel","melg","melm","melb","mels","melt","melp","melh","mem","meb","mebs","mes","mess","meng","mej","mech","mek","met","mep","meh","myeo","myeog",
"myeokk","myeogs","myeon","myeonj","myeonh","myeod","myeol","myeolg","myeolm","myeolb","myeols","myeolt","myeolp","myeolh","myeom","myeob","myeobs","myeos","myeoss","myeong","myeoj","myeoch","myeok","myeot","myeop","myeoh","mye","myeg","myekk","myegs","myen","myenj","myenh","myed","myel","myelg","myelm","myelb","myels","myelt","myelp","myelh","myem","myeb","myebs","myes","myess","myeng","myej","myech","myek","myet","myep","myeh","mo","mog","mokk","mogs","mon","monj","monh","mod","mol","molg","molm","molb","mols","molt","molp","molh","mom","mob","mobs","mos","moss","mong","moj","moch","mok","mot","mop","moh","mwa","mwag","mwakk","mwags","mwan","mwanj","mwanh","mwad","mwal","mwalg","mwalm","mwalb","mwals","mwalt","mwalp","mwalh","mwam","mwab","mwabs","mwas","mwass","mwang","mwaj","mwach","mwak","mwat","mwap","mwah","mwae","mwaeg","mwaekk","mwaegs","mwaen","mwaenj","mwaenh","mwaed","mwael","mwaelg","mwaelm","mwaelb","mwaels","mwaelt","mwaelp","mwaelh","mwaem","mwaeb","mwaebs",
"mwaes","mwaess","mwaeng","mwaej","mwaech","mwaek","mwaet","mwaep","mwaeh","moe","moeg","moekk","moegs","moen","moenj","moenh","moed","moel","moelg","moelm","moelb","moels","moelt","moelp","moelh","moem","moeb","moebs","moes","moess","moeng","moej","moech","moek","moet","moep","moeh","myo","myog","myokk","myogs","myon","myonj","myonh","myod","myol","myolg","myolm","myolb","myols","myolt","myolp","myolh","myom","myob","myobs","myos","myoss","myong","myoj","myoch","myok","myot","myop","myoh","mu","mug","mukk","mugs","mun","munj","munh","mud","mul","mulg","mulm","mulb","muls","mult","mulp","mulh","mum","mub","mubs","mus","muss","mung","muj","much","muk","mut","mup","muh","mwo","mwog","mwokk","mwogs","mwon","mwonj","mwonh","mwod","mwol","mwolg","mwolm","mwolb","mwols","mwolt","mwolp","mwolh","mwom","mwob","mwobs","mwos","mwoss","mwong","mwoj","mwoch","mwok","mwot","mwop","mwoh","mwe","mweg","mwekk","mwegs","mwen","mwenj","mwenh","mwed",
"mwel","mwelg","mwelm","mwelb","mwels","mwelt","mwelp","mwelh","mwem","mweb","mwebs","mwes","mwess","mweng","mwej","mwech","mwek","mwet","mwep","mweh","mwi","mwig","mwikk","mwigs","mwin","mwinj","mwinh","mwid","mwil","mwilg","mwilm","mwilb","mwils","mwilt","mwilp","mwilh","mwim","mwib","mwibs","mwis","mwiss","mwing","mwij","mwich","mwik","mwit","mwip","mwih","myu","myug","myukk","myugs","myun","myunj","myunh","myud","myul","myulg","myulm","myulb","myuls","myult","myulp","myulh","myum","myub","myubs","myus","myuss","myung","myuj","myuch","myuk","myut","myup","myuh","meu","meug","meukk","meugs","meun","meunj","meunh","meud","meul","meulg","meulm","meulb","meuls","meult","meulp","meulh","meum","meub","meubs","meus","meuss","meung","meuj","meuch","meuk","meut","meup","meuh","mui","muig","muikk","muigs","muin","muinj","muinh","muid","muil","muilg","muilm","muilb","muils","muilt","muilp","muilh","muim","muib","muibs","muis","muiss","muing","muij","muich","muik",
"muit","muip","muih","mi","mig","mikk","migs","min","minj","minh","mid","mil","milg","milm","milb","mils","milt","milp","milh","mim","mib","mibs","mis","miss","ming","mij","mich","mik","mit","mip","mih","ba","bag","bakk","bags","ban","banj","banh","bad","bal","balg","balm","balb","bals","balt","balp","balh","bam","bab","babs","bas","bass","bang","baj","bach","bak","bat","bap","bah","bae","baeg","baekk","baegs","baen","baenj","baenh","baed","bael","baelg","baelm","baelb","baels","baelt","baelp","baelh","baem","baeb","baebs","baes","baess","baeng","baej","baech","baek","baet","baep","baeh","bya","byag","byakk","byags","byan","byanj","byanh","byad","byal","byalg","byalm","byalb","byals","byalt","byalp","byalh","byam","byab","byabs","byas","byass","byang","byaj","byach","byak","byat","byap","byah","byae","byaeg","byaekk","byaegs","byaen","byaenj","byaenh","byaed","byael","byaelg","byaelm","byaelb","byaels","byaelt",
"byaelp","byaelh","byaem","byaeb","byaebs","byaes","byaess","byaeng","byaej","byaech","byaek","byaet","byaep","byaeh","beo","beog","beokk","beogs","beon","beonj","beonh","beod","beol","beolg","beolm","beolb","beols","beolt","beolp","beolh","beom","beob","beobs","beos","beoss","beong","beoj","beoch","beok","beot","beop","beoh","be","beg","bekk","begs","ben","benj","benh","bed","bel","belg","belm","belb","bels","belt","belp","belh","bem","beb","bebs","bes","bess","beng","bej","bech","bek","bet","bep","beh","byeo","byeog","byeokk","byeogs","byeon","byeonj","byeonh","byeod","byeol","byeolg","byeolm","byeolb","byeols","byeolt","byeolp","byeolh","byeom","byeob","byeobs","byeos","byeoss","byeong","byeoj","byeoch","byeok","byeot","byeop","byeoh","bye","byeg","byekk","byegs","byen","byenj","byenh","byed","byel","byelg","byelm","byelb","byels","byelt","byelp","byelh","byem","byeb","byebs","byes","byess","byeng","byej","byech","byek","byet","byep","byeh","bo","bog","bokk",
"bogs","bon","bonj","bonh","bod","bol","bolg","bolm","bolb","bols","bolt","bolp","bolh","bom","bob","bobs","bos","boss","bong","boj","boch","bok","bot","bop","boh","bwa","bwag","bwakk","bwags","bwan","bwanj","bwanh","bwad","bwal","bwalg","bwalm","bwalb","bwals","bwalt","bwalp","bwalh","bwam","bwab","bwabs","bwas","bwass","bwang","bwaj","bwach","bwak","bwat","bwap","bwah","bwae","bwaeg","bwaekk","bwaegs","bwaen","bwaenj","bwaenh","bwaed","bwael","bwaelg","bwaelm","bwaelb","bwaels","bwaelt","bwaelp","bwaelh","bwaem","bwaeb","bwaebs","bwaes","bwaess","bwaeng","bwaej","bwaech","bwaek","bwaet","bwaep","bwaeh","boe","boeg","boekk","boegs","boen","boenj","boenh","boed","boel","boelg","boelm","boelb","boels","boelt","boelp","boelh","boem","boeb","boebs","boes","boess","boeng","boej","boech","boek","boet","boep","boeh","byo","byog","byokk","byogs","byon","byonj","byonh","byod","byol","byolg","byolm","byolb","byols","byolt","byolp","byolh","byom","byob","byobs","byos",
"byoss","byong","byoj","byoch","byok","byot","byop","byoh","bu","bug","bukk","bugs","bun","bunj","bunh","bud","bul","bulg","bulm","bulb","buls","bult","bulp","bulh","bum","bub","bubs","bus","buss","bung","buj","buch","buk","but","bup","buh","bwo","bwog","bwokk","bwogs","bwon","bwonj","bwonh","bwod","bwol","bwolg","bwolm","bwolb","bwols","bwolt","bwolp","bwolh","bwom","bwob","bwobs","bwos","bwoss","bwong","bwoj","bwoch","bwok","bwot","bwop","bwoh","bwe","bweg","bwekk","bwegs","bwen","bwenj","bwenh","bwed","bwel","bwelg","bwelm","bwelb","bwels","bwelt","bwelp","bwelh","bwem","bweb","bwebs","bwes","bwess","bweng","bwej","bwech","bwek","bwet","bwep","bweh","bwi","bwig","bwikk","bwigs","bwin","bwinj","bwinh","bwid","bwil","bwilg","bwilm","bwilb","bwils","bwilt","bwilp","bwilh","bwim","bwib","bwibs","bwis","bwiss","bwing","bwij","bwich","bwik","bwit","bwip","bwih","byu","byug","byukk","byugs","byun","byunj","byunh","byud","byul",
"byulg","byulm","byulb","byuls","byult","byulp","byulh","byum","byub","byubs","byus","byuss","byung","byuj","byuch","byuk","byut","byup","byuh","beu","beug","beukk","beugs","beun","beunj","beunh","beud","beul","beulg","beulm","beulb","beuls","beult","beulp","beulh","beum","beub","beubs","beus","beuss","beung","beuj","beuch","beuk","beut","beup","beuh","bui","buig","buikk","buigs","buin","buinj","buinh","buid","buil","builg","builm","builb","buils","built","builp","builh","buim","buib","buibs","buis","buiss","buing","buij","buich","buik","buit","buip","buih","bi","big","bikk","bigs","bin","binj","binh","bid","bil","bilg","bilm","bilb","bils","bilt","bilp","bilh","bim","bib","bibs","bis","biss","bing","bij","bich","bik","bit","bip","bih","ppa","ppag","ppakk","ppags","ppan","ppanj","ppanh","ppad","ppal","ppalg","ppalm","ppalb","ppals","ppalt","ppalp","ppalh","ppam","ppab","ppabs","ppas","ppass","ppang","ppaj","ppach","ppak","ppat",
"ppap","ppah","ppae","ppaeg","ppaekk","ppaegs","ppaen","ppaenj","ppaenh","ppaed","ppael","ppaelg","ppaelm","ppaelb","ppaels","ppaelt","ppaelp","ppaelh","ppaem","ppaeb","ppaebs","ppaes","ppaess","ppaeng","ppaej","ppaech","ppaek","ppaet","ppaep","ppaeh","ppya","ppyag","ppyakk","ppyags","ppyan","ppyanj","ppyanh","ppyad","ppyal","ppyalg","ppyalm","ppyalb","ppyals","ppyalt","ppyalp","ppyalh","ppyam","ppyab","ppyabs","ppyas","ppyass","ppyang","ppyaj","ppyach","ppyak","ppyat","ppyap","ppyah","ppyae","ppyaeg","ppyaekk","ppyaegs","ppyaen","ppyaenj","ppyaenh","ppyaed","ppyael","ppyaelg","ppyaelm","ppyaelb","ppyaels","ppyaelt","ppyaelp","ppyaelh","ppyaem","ppyaeb","ppyaebs","ppyaes","ppyaess","ppyaeng","ppyaej","ppyaech","ppyaek","ppyaet","ppyaep","ppyaeh","ppeo","ppeog","ppeokk","ppeogs","ppeon","ppeonj","ppeonh","ppeod","ppeol","ppeolg","ppeolm","ppeolb","ppeols","ppeolt","ppeolp","ppeolh","ppeom","ppeob","ppeobs","ppeos","ppeoss","ppeong","ppeoj","ppeoch","ppeok","ppeot","ppeop","ppeoh","ppe","ppeg","ppekk","ppegs","ppen","ppenj","ppenh","pped","ppel","ppelg","ppelm","ppelb","ppels","ppelt","ppelp",
"ppelh","ppem","ppeb","ppebs","ppes","ppess","ppeng","ppej","ppech","ppek","ppet","ppep","ppeh","ppyeo","ppyeog","ppyeokk","ppyeogs","ppyeon","ppyeonj","ppyeonh","ppyeod","ppyeol","ppyeolg","ppyeolm","ppyeolb","ppyeols","ppyeolt","ppyeolp","ppyeolh","ppyeom","ppyeob","ppyeobs","ppyeos","ppyeoss","ppyeong","ppyeoj","ppyeoch","ppyeok","ppyeot","ppyeop","ppyeoh","ppye","ppyeg","ppyekk","ppyegs","ppyen","ppyenj","ppyenh","ppyed","ppyel","ppyelg","ppyelm","ppyelb","ppyels","ppyelt","ppyelp","ppyelh","ppyem","ppyeb","ppyebs","ppyes","ppyess","ppyeng","ppyej","ppyech","ppyek","ppyet","ppyep","ppyeh","ppo","ppog","ppokk","ppogs","ppon","pponj","pponh","ppod","ppol","ppolg","ppolm","ppolb","ppols","ppolt","ppolp","ppolh","ppom","ppob","ppobs","ppos","pposs","ppong","ppoj","ppoch","ppok","ppot","ppop","ppoh","ppwa","ppwag","ppwakk","ppwags","ppwan","ppwanj","ppwanh","ppwad","ppwal","ppwalg","ppwalm","ppwalb","ppwals","ppwalt","ppwalp","ppwalh","ppwam","ppwab","ppwabs","ppwas","ppwass","ppwang","ppwaj","ppwach","ppwak","ppwat","ppwap","ppwah","ppwae","ppwaeg","ppwaekk","ppwaegs",
"ppwaen","ppwaenj","ppwaenh","ppwaed","ppwael","ppwaelg","ppwaelm","ppwaelb","ppwaels","ppwaelt","ppwaelp","ppwaelh","ppwaem","ppwaeb","ppwaebs","ppwaes","ppwaess","ppwaeng","ppwaej","ppwaech","ppwaek","ppwaet","ppwaep","ppwaeh","ppoe","ppoeg","ppoekk","ppoegs","ppoen","ppoenj","ppoenh","ppoed","ppoel","ppoelg","ppoelm","ppoelb","ppoels","ppoelt","ppoelp","ppoelh","ppoem","ppoeb","ppoebs","ppoes","ppoess","ppoeng","ppoej","ppoech","ppoek","ppoet","ppoep","ppoeh","ppyo","ppyog","ppyokk","ppyogs","ppyon","ppyonj","ppyonh","ppyod","ppyol","ppyolg","ppyolm","ppyolb","ppyols","ppyolt","ppyolp","ppyolh","ppyom","ppyob","ppyobs","ppyos","ppyoss","ppyong","ppyoj","ppyoch","ppyok","ppyot","ppyop","ppyoh","ppu","ppug","ppukk","ppugs","ppun","ppunj","ppunh","ppud","ppul","ppulg","ppulm","ppulb","ppuls","ppult","ppulp","ppulh","ppum","ppub","ppubs","ppus","ppuss","ppung","ppuj","ppuch","ppuk","pput","ppup","ppuh","ppwo","ppwog","ppwokk","ppwogs","ppwon","ppwonj","ppwonh","ppwod","ppwol","ppwolg","ppwolm","ppwolb","ppwols","ppwolt","ppwolp","ppwolh","ppwom","ppwob","ppwobs","ppwos","ppwoss",
"ppwong","ppwoj","ppwoch","ppwok","ppwot","ppwop","ppwoh","ppwe","ppweg","ppwekk","ppwegs","ppwen","ppwenj","ppwenh","ppwed","ppwel","ppwelg","ppwelm","ppwelb","ppwels","ppwelt","ppwelp","ppwelh","ppwem","ppweb","ppwebs","ppwes","ppwess","ppweng","ppwej","ppwech","ppwek","ppwet","ppwep","ppweh","ppwi","ppwig","ppwikk","ppwigs","ppwin","ppwinj","ppwinh","ppwid","ppwil","ppwilg","ppwilm","ppwilb","ppwils","ppwilt","ppwilp","ppwilh","ppwim","ppwib","ppwibs","ppwis","ppwiss","ppwing","ppwij","ppwich","ppwik","ppwit","ppwip","ppwih","ppyu","ppyug","ppyukk","ppyugs","ppyun","ppyunj","ppyunh","ppyud","ppyul","ppyulg","ppyulm","ppyulb","ppyuls","ppyult","ppyulp","ppyulh","ppyum","ppyub","ppyubs","ppyus","ppyuss","ppyung","ppyuj","ppyuch","ppyuk","ppyut","ppyup","ppyuh","ppeu","ppeug","ppeukk","ppeugs","ppeun","ppeunj","ppeunh","ppeud","ppeul","ppeulg","ppeulm","ppeulb","ppeuls","ppeult","ppeulp","ppeulh","ppeum","ppeub","ppeubs","ppeus","ppeuss","ppeung","ppeuj","ppeuch","ppeuk","ppeut","ppeup","ppeuh","ppui","ppuig","ppuikk","ppuigs","ppuin","ppuinj","ppuinh","ppuid","ppuil","ppuilg",
"ppuilm","ppuilb","ppuils","ppuilt","ppuilp","ppuilh","ppuim","ppuib","ppuibs","ppuis","ppuiss","ppuing","ppuij","ppuich","ppuik","ppuit","ppuip","ppuih","ppi","ppig","ppikk","ppigs","ppin","ppinj","ppinh","ppid","ppil","ppilg","ppilm","ppilb","ppils","ppilt","ppilp","ppilh","ppim","ppib","ppibs","ppis","ppiss","pping","ppij","ppich","ppik","ppit","ppip","ppih","sa","sag","sakk","sags","san","sanj","sanh","sad","sal","salg","salm","salb","sals","salt","salp","salh","sam","sab","sabs","sas","sass","sang","saj","sach","sak","sat","sap","sah","sae","saeg","saekk","saegs","saen","saenj","saenh","saed","sael","saelg","saelm","saelb","saels","saelt","saelp","saelh","saem","saeb","saebs","saes","saess","saeng","saej","saech","saek","saet","saep","saeh","sya","syag","syakk","syags","syan","syanj","syanh","syad","syal","syalg","syalm","syalb","syals","syalt","syalp","syalh","syam","syab","syabs","syas","syass","syang","syaj","syach","syak","syat","syap",
"syah","syae","syaeg","syaekk","syaegs","syaen","syaenj","syaenh","syaed","syael","syaelg","syaelm","syaelb","syaels","syaelt","syaelp","syaelh","syaem","syaeb","syaebs","syaes","syaess","syaeng","syaej","syaech","syaek","syaet","syaep","syaeh","seo","seog","seokk","seogs","seon","seonj","seonh","seod","seol","seolg","seolm","seolb","seols","seolt","seolp","seolh","seom","seob","seobs","seos","seoss","seong","seoj","seoch","seok","seot","seop","seoh","se","seg","sekk","segs","sen","senj","senh","sed","sel","selg","selm","selb","sels","selt","selp","selh","sem","seb","sebs","ses","sess","seng","sej","sech","sek","set","sep","seh","syeo","syeog","syeokk","syeogs","syeon","syeonj","syeonh","syeod","syeol","syeolg","syeolm","syeolb","syeols","syeolt","syeolp","syeolh","syeom","syeob","syeobs","syeos","syeoss","syeong","syeoj","syeoch","syeok","syeot","syeop","syeoh","sye","syeg","syekk","syegs","syen","syenj","syenh","syed","syel","syelg","syelm","syelb","syels","syelt","syelp","syelh",
"syem","syeb","syebs","syes","syess","syeng","syej","syech","syek","syet","syep","syeh","so","sog","sokk","sogs","son","sonj","sonh","sod","sol","solg","solm","solb","sols","solt","solp","solh","som","sob","sobs","sos","soss","song","soj","soch","sok","sot","sop","soh","swa","swag","swakk","swags","swan","swanj","swanh","swad","swal","swalg","swalm","swalb","swals","swalt","swalp","swalh","swam","swab","swabs","swas","swass","swang","swaj","swach","swak","swat","swap","swah","swae","swaeg","swaekk","swaegs","swaen","swaenj","swaenh","swaed","swael","swaelg","swaelm","swaelb","swaels","swaelt","swaelp","swaelh","swaem","swaeb","swaebs","swaes","swaess","swaeng","swaej","swaech","swaek","swaet","swaep","swaeh","soe","soeg","soekk","soegs","soen","soenj","soenh","soed","soel","soelg","soelm","soelb","soels","soelt","soelp","soelh","soem","soeb","soebs","soes","soess","soeng","soej","soech","soek","soet","soep","soeh","syo","syog","syokk","syogs","syon",
"syonj","syonh","syod","syol","syolg","syolm","syolb","syols","syolt","syolp","syolh","syom","syob","syobs","syos","syoss","syong","syoj","syoch","syok","syot","syop","syoh","su","sug","sukk","sugs","sun","sunj","sunh","sud","sul","sulg","sulm","sulb","suls","sult","sulp","sulh","sum","sub","subs","sus","suss","sung","suj","such","suk","sut","sup","suh","swo","swog","swokk","swogs","swon","swonj","swonh","swod","swol","swolg","swolm","swolb","swols","swolt","swolp","swolh","swom","swob","swobs","swos","swoss","swong","swoj","swoch","swok","swot","swop","swoh","swe","sweg","swekk","swegs","swen","swenj","swenh","swed","swel","swelg","swelm","swelb","swels","swelt","swelp","swelh","swem","sweb","swebs","swes","swess","sweng","swej","swech","swek","swet","swep","sweh","swi","swig","swikk","swigs","swin","swinj","swinh","swid","swil","swilg","swilm","swilb","swils","swilt","swilp","swilh","swim","swib","swibs","swis","swiss","swing",
"swij","swich","swik","swit","swip","swih","syu","syug","syukk","syugs","syun","syunj","syunh","syud","syul","syulg","syulm","syulb","syuls","syult","syulp","syulh","syum","syub","syubs","syus","syuss","syung","syuj","syuch","syuk","syut","syup","syuh","seu","seug","seukk","seugs","seun","seunj","seunh","seud","seul","seulg","seulm","seulb","seuls","seult","seulp","seulh","seum","seub","seubs","seus","seuss","seung","seuj","seuch","seuk","seut","seup","seuh","sui","suig","suikk","suigs","suin","suinj","suinh","suid","suil","suilg","suilm","suilb","suils","suilt","suilp","suilh","suim","suib","suibs","suis","suiss","suing","suij","suich","suik","suit","suip","suih","si","sig","sikk","sigs","sin","sinj","sinh","sid","sil","silg","silm","silb","sils","silt","silp","silh","sim","sib","sibs","sis","siss","sing","sij","sich","sik","sit","sip","sih","ssa","ssag","ssakk","ssags","ssan","ssanj","ssanh","ssad","ssal","ssalg","ssalm",
"ssalb","ssals","ssalt","ssalp","ssalh","ssam","ssab","ssabs","ssas","ssass","ssang","ssaj","ssach","ssak","ssat","ssap","ssah","ssae","ssaeg","ssaekk","ssaegs","ssaen","ssaenj","ssaenh","ssaed","ssael","ssaelg","ssaelm","ssaelb","ssaels","ssaelt","ssaelp","ssaelh","ssaem","ssaeb","ssaebs","ssaes","ssaess","ssaeng","ssaej","ssaech","ssaek","ssaet","ssaep","ssaeh","ssya","ssyag","ssyakk","ssyags","ssyan","ssyanj","ssyanh","ssyad","ssyal","ssyalg","ssyalm","ssyalb","ssyals","ssyalt","ssyalp","ssyalh","ssyam","ssyab","ssyabs","ssyas","ssyass","ssyang","ssyaj","ssyach","ssyak","ssyat","ssyap","ssyah","ssyae","ssyaeg","ssyaekk","ssyaegs","ssyaen","ssyaenj","ssyaenh","ssyaed","ssyael","ssyaelg","ssyaelm","ssyaelb","ssyaels","ssyaelt","ssyaelp","ssyaelh","ssyaem","ssyaeb","ssyaebs","ssyaes","ssyaess","ssyaeng","ssyaej","ssyaech","ssyaek","ssyaet","ssyaep","ssyaeh","sseo","sseog","sseokk","sseogs","sseon","sseonj","sseonh","sseod","sseol","sseolg","sseolm","sseolb","sseols","sseolt","sseolp","sseolh","sseom","sseob","sseobs","sseos","sseoss","sseong","sseoj","sseoch","sseok","sseot","sseop","sseoh",
"sse","sseg","ssekk","ssegs","ssen","ssenj","ssenh","ssed","ssel","sselg","sselm","sselb","ssels","sselt","sselp","sselh","ssem","sseb","ssebs","sses","ssess","sseng","ssej","ssech","ssek","sset","ssep","sseh","ssyeo","ssyeog","ssyeokk","ssyeogs","ssyeon","ssyeonj","ssyeonh","ssyeod","ssyeol","ssyeolg","ssyeolm","ssyeolb","ssyeols","ssyeolt","ssyeolp","ssyeolh","ssyeom","ssyeob","ssyeobs","ssyeos","ssyeoss","ssyeong","ssyeoj","ssyeoch","ssyeok","ssyeot","ssyeop","ssyeoh","ssye","ssyeg","ssyekk","ssyegs","ssyen","ssyenj","ssyenh","ssyed","ssyel","ssyelg","ssyelm","ssyelb","ssyels","ssyelt","ssyelp","ssyelh","ssyem","ssyeb","ssyebs","ssyes","ssyess","ssyeng","ssyej","ssyech","ssyek","ssyet","ssyep","ssyeh","sso","ssog","ssokk","ssogs","sson","ssonj","ssonh","ssod","ssol","ssolg","ssolm","ssolb","ssols","ssolt","ssolp","ssolh","ssom","ssob","ssobs","ssos","ssoss","ssong","ssoj","ssoch","ssok","ssot","ssop","ssoh","sswa","sswag","sswakk","sswags","sswan","sswanj","sswanh","sswad","sswal","sswalg","sswalm","sswalb","sswals","sswalt","sswalp","sswalh","sswam",
"sswab","sswabs","sswas","sswass","sswang","sswaj","sswach","sswak","sswat","sswap","sswah","sswae","sswaeg","sswaekk","sswaegs","sswaen","sswaenj","sswaenh","sswaed","sswael","sswaelg","sswaelm","sswaelb","sswaels","sswaelt","sswaelp","sswaelh","sswaem","sswaeb","sswaebs","sswaes","sswaess","sswaeng","sswaej","sswaech","sswaek","sswaet","sswaep","sswaeh","ssoe","ssoeg","ssoekk","ssoegs","ssoen","ssoenj","ssoenh","ssoed","ssoel","ssoelg","ssoelm","ssoelb","ssoels","ssoelt","ssoelp","ssoelh","ssoem","ssoeb","ssoebs","ssoes","ssoess","ssoeng","ssoej","ssoech","ssoek","ssoet","ssoep","ssoeh","ssyo","ssyog","ssyokk","ssyogs","ssyon","ssyonj","ssyonh","ssyod","ssyol","ssyolg","ssyolm","ssyolb","ssyols","ssyolt","ssyolp","ssyolh","ssyom","ssyob","ssyobs","ssyos","ssyoss","ssyong","ssyoj","ssyoch","ssyok","ssyot","ssyop","ssyoh","ssu","ssug","ssukk","ssugs","ssun","ssunj","ssunh","ssud","ssul","ssulg","ssulm","ssulb","ssuls","ssult","ssulp","ssulh","ssum","ssub","ssubs","ssus","ssuss","ssung","ssuj","ssuch","ssuk","ssut","ssup","ssuh","sswo","sswog","sswokk","sswogs","sswon","sswonj",
"sswonh","sswod","sswol","sswolg","sswolm","sswolb","sswols","sswolt","sswolp","sswolh","sswom","sswob","sswobs","sswos","sswoss","sswong","sswoj","sswoch","sswok","sswot","sswop","sswoh","sswe","ssweg","sswekk","sswegs","sswen","sswenj","sswenh","sswed","sswel","sswelg","sswelm","sswelb","sswels","sswelt","sswelp","sswelh","sswem","ssweb","sswebs","sswes","sswess","ssweng","sswej","sswech","sswek","sswet","sswep","ssweh","sswi","sswig","sswikk","sswigs","sswin","sswinj","sswinh","sswid","sswil","sswilg","sswilm","sswilb","sswils","sswilt","sswilp","sswilh","sswim","sswib","sswibs","sswis","sswiss","sswing","sswij","sswich","sswik","sswit","sswip","sswih","ssyu","ssyug","ssyukk","ssyugs","ssyun","ssyunj","ssyunh","ssyud","ssyul","ssyulg","ssyulm","ssyulb","ssyuls","ssyult","ssyulp","ssyulh","ssyum","ssyub","ssyubs","ssyus","ssyuss","ssyung","ssyuj","ssyuch","ssyuk","ssyut","ssyup","ssyuh","sseu","sseug","sseukk","sseugs","sseun","sseunj","sseunh","sseud","sseul","sseulg","sseulm","sseulb","sseuls","sseult","sseulp","sseulh","sseum","sseub","sseubs","sseus","sseuss","sseung","sseuj",
"sseuch","sseuk","sseut","sseup","sseuh","ssui","ssuig","ssuikk","ssuigs","ssuin","ssuinj","ssuinh","ssuid","ssuil","ssuilg","ssuilm","ssuilb","ssuils","ssuilt","ssuilp","ssuilh","ssuim","ssuib","ssuibs","ssuis","ssuiss","ssuing","ssuij","ssuich","ssuik","ssuit","ssuip","ssuih","ssi","ssig","ssikk","ssigs","ssin","ssinj","ssinh","ssid","ssil","ssilg","ssilm","ssilb","ssils","ssilt","ssilp","ssilh","ssim","ssib","ssibs","ssis","ssiss","ssing","ssij","ssich","ssik","ssit","ssip","ssih","a","ag","akk","ags","an","anj","anh","ad","al","alg","alm","alb","als","alt","alp","alh","am","ab","abs","as","ass","ang","aj","ach","ak","at","ap","ah","ae","aeg","aekk","aegs","aen","aenj","aenh","aed","ael","aelg","aelm","aelb","aels","aelt","aelp","aelh","aem","aeb","aebs","aes","aess","aeng","aej","aech","aek","aet","aep","aeh","ya","yag","yakk","yags","yan","yanj","yanh","yad","yal","yalg","yalm","yalb",
"yals","yalt","yalp","yalh","yam","yab","yabs","yas","yass","yang","yaj","yach","yak","yat","yap","yah","yae","yaeg","yaekk","yaegs","yaen","yaenj","yaenh","yaed","yael","yaelg","yaelm","yaelb","yaels","yaelt","yaelp","yaelh","yaem","yaeb","yaebs","yaes","yaess","yaeng","yaej","yaech","yaek","yaet","yaep","yaeh","eo","eog","eokk","eogs","eon","eonj","eonh","eod","eol","eolg","eolm","eolb","eols","eolt","eolp","eolh","eom","eob","eobs","eos","eoss","eong","eoj","eoch","eok","eot","eop","eoh","e","eg","ekk","egs","en","enj","enh","ed","el","elg","elm","elb","els","elt","elp","elh","em","eb","ebs","es","ess","eng","ej","ech","ek","et","ep","eh","yeo","yeog","yeokk","yeogs","yeon","yeonj","yeonh","yeod","yeol","yeolg","yeolm","yeolb","yeols","yeolt","yeolp","yeolh","yeom","yeob","yeobs","yeos","yeoss","yeong","yeoj","yeoch","yeok","yeot","yeop","yeoh","ye",
"yeg","yekk","yegs","yen","yenj","yenh","yed","yel","yelg","yelm","yelb","yels","yelt","yelp","yelh","yem","yeb","yebs","yes","yess","yeng","yej","yech","yek","yet","yep","yeh","o","og","okk","ogs","on","onj","onh","od","ol","olg","olm","olb","ols","olt","olp","olh","om","ob","obs","os","oss","ong","oj","och","ok","ot","op","oh","wa","wag","wakk","wags","wan","wanj","wanh","wad","wal","walg","walm","walb","wals","walt","walp","walh","wam","wab","wabs","was","wass","wang","waj","wach","wak","wat","wap","wah","wae","waeg","waekk","waegs","waen","waenj","waenh","waed","wael","waelg","waelm","waelb","waels","waelt","waelp","waelh","waem","waeb","waebs","waes","waess","waeng","waej","waech","waek","waet","waep","waeh","oe","oeg","oekk","oegs","oen","oenj","oenh","oed","oel","oelg","oelm","oelb","oels","oelt","oelp","oelh","oem","oeb",
"oebs","oes","oess","oeng","oej","oech","oek","oet","oep","oeh","yo","yog","yokk","yogs","yon","yonj","yonh","yod","yol","yolg","yolm","yolb","yols","yolt","yolp","yolh","yom","yob","yobs","yos","yoss","yong","yoj","yoch","yok","yot","yop","yoh","u","ug","ukk","ugs","un","unj","unh","ud","ul","ulg","ulm","ulb","uls","ult","ulp","ulh","um","ub","ubs","us","uss","ung","uj","uch","uk","ut","up","uh","wo","wog","wokk","wogs","won","wonj","wonh","wod","wol","wolg","wolm","wolb","wols","wolt","wolp","wolh","wom","wob","wobs","wos","woss","wong","woj","woch","wok","wot","wop","woh","we","weg","wekk","wegs","wen","wenj","wenh","wed","wel","welg","welm","welb","wels","welt","welp","welh","wem","web","webs","wes","wess","weng","wej","wech","wek","wet","wep","weh","wi","wig","wikk","wigs","win","winj","winh",
"wid","wil","wilg","wilm","wilb","wils","wilt","wilp","wilh","wim","wib","wibs","wis","wiss","wing","wij","wich","wik","wit","wip","wih","yu","yug","yukk","yugs","yun","yunj","yunh","yud","yul","yulg","yulm","yulb","yuls","yult","yulp","yulh","yum","yub","yubs","yus","yuss","yung","yuj","yuch","yuk","yut","yup","yuh","eu","eug","eukk","eugs","eun","eunj","eunh","eud","eul","eulg","eulm","eulb","euls","eult","eulp","eulh","eum","eub","eubs","eus","euss","eung","euj","euch","euk","eut","eup","euh","ui","uig","uikk","uigs","uin","uinj","uinh","uid","uil","uilg","uilm","uilb","uils","uilt","uilp","uilh","uim","uib","uibs","uis","uiss","uing","uij","uich","uik","uit","uip","uih","i","ig","ikk","igs","in","inj","inh","id","il","ilg","ilm","ilb","ils","ilt","ilp","ilh","im","ib","ibs","is","iss","ing","ij","ich",
"ik","it","ip","ih","ja","jag","jakk","jags","jan","janj","janh","jad","jal","jalg","jalm","jalb","jals","jalt","jalp","jalh","jam","jab","jabs","jas","jass","jang","jaj","jach","jak","jat","jap","jah","jae","jaeg","jaekk","jaegs","jaen","jaenj","jaenh","jaed","jael","jaelg","jaelm","jaelb","jaels","jaelt","jaelp","jaelh","jaem","jaeb","jaebs","jaes","jaess","jaeng","jaej","jaech","jaek","jaet","jaep","jaeh","jya","jyag","jyakk","jyags","jyan","jyanj","jyanh","jyad","jyal","jyalg","jyalm","jyalb","jyals","jyalt","jyalp","jyalh","jyam","jyab","jyabs","jyas","jyass","jyang","jyaj","jyach","jyak","jyat","jyap","jyah","jyae","jyaeg","jyaekk","jyaegs","jyaen","jyaenj","jyaenh","jyaed","jyael","jyaelg","jyaelm","jyaelb","jyaels","jyaelt","jyaelp","jyaelh","jyaem","jyaeb","jyaebs","jyaes","jyaess","jyaeng","jyaej","jyaech","jyaek","jyaet","jyaep","jyaeh","jeo","jeog","jeokk","jeogs","jeon","jeonj","jeonh","jeod","jeol","jeolg","jeolm","jeolb","jeols",
"jeolt","jeolp","jeolh","jeom","jeob","jeobs","jeos","jeoss","jeong","jeoj","jeoch","jeok","jeot","jeop","jeoh","je","jeg","jekk","jegs","jen","jenj","jenh","jed","jel","jelg","jelm","jelb","jels","jelt","jelp","jelh","jem","jeb","jebs","jes","jess","jeng","jej","jech","jek","jet","jep","jeh","jyeo","jyeog","jyeokk","jyeogs","jyeon","jyeonj","jyeonh","jyeod","jyeol","jyeolg","jyeolm","jyeolb","jyeols","jyeolt","jyeolp","jyeolh","jyeom","jyeob","jyeobs","jyeos","jyeoss","jyeong","jyeoj","jyeoch","jyeok","jyeot","jyeop","jyeoh","jye","jyeg","jyekk","jyegs","jyen","jyenj","jyenh","jyed","jyel","jyelg","jyelm","jyelb","jyels","jyelt","jyelp","jyelh","jyem","jyeb","jyebs","jyes","jyess","jyeng","jyej","jyech","jyek","jyet","jyep","jyeh","jo","jog","jokk","jogs","jon","jonj","jonh","jod","jol","jolg","jolm","jolb","jols","jolt","jolp","jolh","jom","job","jobs","jos","joss","jong","joj","joch","jok","jot","jop","joh","jwa","jwag",
"jwakk","jwags","jwan","jwanj","jwanh","jwad","jwal","jwalg","jwalm","jwalb","jwals","jwalt","jwalp","jwalh","jwam","jwab","jwabs","jwas","jwass","jwang","jwaj","jwach","jwak","jwat","jwap","jwah","jwae","jwaeg","jwaekk","jwaegs","jwaen","jwaenj","jwaenh","jwaed","jwael","jwaelg","jwaelm","jwaelb","jwaels","jwaelt","jwaelp","jwaelh","jwaem","jwaeb","jwaebs","jwaes","jwaess","jwaeng","jwaej","jwaech","jwaek","jwaet","jwaep","jwaeh","joe","joeg","joekk","joegs","joen","joenj","joenh","joed","joel","joelg","joelm","joelb","joels","joelt","joelp","joelh","joem","joeb","joebs","joes","joess","joeng","joej","joech","joek","joet","joep","joeh","jyo","jyog","jyokk","jyogs","jyon","jyonj","jyonh","jyod","jyol","jyolg","jyolm","jyolb","jyols","jyolt","jyolp","jyolh","jyom","jyob","jyobs","jyos","jyoss","jyong","jyoj","jyoch","jyok","jyot","jyop","jyoh","ju","jug","jukk","jugs","jun","junj","junh","jud","jul","julg","julm","julb","juls","jult","julp","julh","jum","jub","jubs",
"jus","juss","jung","juj","juch","juk","jut","jup","juh","jwo","jwog","jwokk","jwogs","jwon","jwonj","jwonh","jwod","jwol","jwolg","jwolm","jwolb","jwols","jwolt","jwolp","jwolh","jwom","jwob","jwobs","jwos","jwoss","jwong","jwoj","jwoch","jwok","jwot","jwop","jwoh","jwe","jweg","jwekk","jwegs","jwen","jwenj","jwenh","jwed","jwel","jwelg","jwelm","jwelb","jwels","jwelt","jwelp","jwelh","jwem","jweb","jwebs","jwes","jwess","jweng","jwej","jwech","jwek","jwet","jwep","jweh","jwi","jwig","jwikk","jwigs","jwin","jwinj","jwinh","jwid","jwil","jwilg","jwilm","jwilb","jwils","jwilt","jwilp","jwilh","jwim","jwib","jwibs","jwis","jwiss","jwing","jwij","jwich","jwik","jwit","jwip","jwih","jyu","jyug","jyukk","jyugs","jyun","jyunj","jyunh","jyud","jyul","jyulg","jyulm","jyulb","jyuls","jyult","jyulp","jyulh","jyum","jyub","jyubs","jyus","jyuss","jyung","jyuj","jyuch","jyuk","jyut","jyup","jyuh","jeu","jeug","jeukk","jeugs","jeun","jeunj","jeunh","jeud",
"jeul","jeulg","jeulm","jeulb","jeuls","jeult","jeulp","jeulh","jeum","jeub","jeubs","jeus","jeuss","jeung","jeuj","jeuch","jeuk","jeut","jeup","jeuh","jui","juig","juikk","juigs","juin","juinj","juinh","juid","juil","juilg","juilm","juilb","juils","juilt","juilp","juilh","juim","juib","juibs","juis","juiss","juing","juij","juich","juik","juit","juip","juih","ji","jig","jikk","jigs","jin","jinj","jinh","jid","jil","jilg","jilm","jilb","jils","jilt","jilp","jilh","jim","jib","jibs","jis","jiss","jing","jij","jich","jik","jit","jip","jih","jja","jjag","jjakk","jjags","jjan","jjanj","jjanh","jjad","jjal","jjalg","jjalm","jjalb","jjals","jjalt","jjalp","jjalh","jjam","jjab","jjabs","jjas","jjass","jjang","jjaj","jjach","jjak","jjat","jjap","jjah","jjae","jjaeg","jjaekk","jjaegs","jjaen","jjaenj","jjaenh","jjaed","jjael","jjaelg","jjaelm","jjaelb","jjaels","jjaelt","jjaelp","jjaelh","jjaem","jjaeb","jjaebs","jjaes","jjaess","jjaeng","jjaej","jjaech","jjaek",
"jjaet","jjaep","jjaeh","jjya","jjyag","jjyakk","jjyags","jjyan","jjyanj","jjyanh","jjyad","jjyal","jjyalg","jjyalm","jjyalb","jjyals","jjyalt","jjyalp","jjyalh","jjyam","jjyab","jjyabs","jjyas","jjyass","jjyang","jjyaj","jjyach","jjyak","jjyat","jjyap","jjyah","jjyae","jjyaeg","jjyaekk","jjyaegs","jjyaen","jjyaenj","jjyaenh","jjyaed","jjyael","jjyaelg","jjyaelm","jjyaelb","jjyaels","jjyaelt","jjyaelp","jjyaelh","jjyaem","jjyaeb","jjyaebs","jjyaes","jjyaess","jjyaeng","jjyaej","jjyaech","jjyaek","jjyaet","jjyaep","jjyaeh","jjeo","jjeog","jjeokk","jjeogs","jjeon","jjeonj","jjeonh","jjeod","jjeol","jjeolg","jjeolm","jjeolb","jjeols","jjeolt","jjeolp","jjeolh","jjeom","jjeob","jjeobs","jjeos","jjeoss","jjeong","jjeoj","jjeoch","jjeok","jjeot","jjeop","jjeoh","jje","jjeg","jjekk","jjegs","jjen","jjenj","jjenh","jjed","jjel","jjelg","jjelm","jjelb","jjels","jjelt","jjelp","jjelh","jjem","jjeb","jjebs","jjes","jjess","jjeng","jjej","jjech","jjek","jjet","jjep","jjeh","jjyeo","jjyeog","jjyeokk","jjyeogs","jjyeon","jjyeonj","jjyeonh","jjyeod","jjyeol","jjyeolg","jjyeolm","jjyeolb","jjyeols","jjyeolt",
"jjyeolp","jjyeolh","jjyeom","jjyeob","jjyeobs","jjyeos","jjyeoss","jjyeong","jjyeoj","jjyeoch","jjyeok","jjyeot","jjyeop","jjyeoh","jjye","jjyeg","jjyekk","jjyegs","jjyen","jjyenj","jjyenh","jjyed","jjyel","jjyelg","jjyelm","jjyelb","jjyels","jjyelt","jjyelp","jjyelh","jjyem","jjyeb","jjyebs","jjyes","jjyess","jjyeng","jjyej","jjyech","jjyek","jjyet","jjyep","jjyeh","jjo","jjog","jjokk","jjogs","jjon","jjonj","jjonh","jjod","jjol","jjolg","jjolm","jjolb","jjols","jjolt","jjolp","jjolh","jjom","jjob","jjobs","jjos","jjoss","jjong","jjoj","jjoch","jjok","jjot","jjop","jjoh","jjwa","jjwag","jjwakk","jjwags","jjwan","jjwanj","jjwanh","jjwad","jjwal","jjwalg","jjwalm","jjwalb","jjwals","jjwalt","jjwalp","jjwalh","jjwam","jjwab","jjwabs","jjwas","jjwass","jjwang","jjwaj","jjwach","jjwak","jjwat","jjwap","jjwah","jjwae","jjwaeg","jjwaekk","jjwaegs","jjwaen","jjwaenj","jjwaenh","jjwaed","jjwael","jjwaelg","jjwaelm","jjwaelb","jjwaels","jjwaelt","jjwaelp","jjwaelh","jjwaem","jjwaeb","jjwaebs","jjwaes","jjwaess","jjwaeng","jjwaej","jjwaech","jjwaek","jjwaet","jjwaep","jjwaeh","jjoe","jjoeg","jjoekk",
"jjoegs","jjoen","jjoenj","jjoenh","jjoed","jjoel","jjoelg","jjoelm","jjoelb","jjoels","jjoelt","jjoelp","jjoelh","jjoem","jjoeb","jjoebs","jjoes","jjoess","jjoeng","jjoej","jjoech","jjoek","jjoet","jjoep","jjoeh","jjyo","jjyog","jjyokk","jjyogs","jjyon","jjyonj","jjyonh","jjyod","jjyol","jjyolg","jjyolm","jjyolb","jjyols","jjyolt","jjyolp","jjyolh","jjyom","jjyob","jjyobs","jjyos","jjyoss","jjyong","jjyoj","jjyoch","jjyok","jjyot","jjyop","jjyoh","jju","jjug","jjukk","jjugs","jjun","jjunj","jjunh","jjud","jjul","jjulg","jjulm","jjulb","jjuls","jjult","jjulp","jjulh","jjum","jjub","jjubs","jjus","jjuss","jjung","jjuj","jjuch","jjuk","jjut","jjup","jjuh","jjwo","jjwog","jjwokk","jjwogs","jjwon","jjwonj","jjwonh","jjwod","jjwol","jjwolg","jjwolm","jjwolb","jjwols","jjwolt","jjwolp","jjwolh","jjwom","jjwob","jjwobs","jjwos","jjwoss","jjwong","jjwoj","jjwoch","jjwok","jjwot","jjwop","jjwoh","jjwe","jjweg","jjwekk","jjwegs","jjwen","jjwenj","jjwenh","jjwed","jjwel","jjwelg","jjwelm","jjwelb","jjwels","jjwelt","jjwelp","jjwelh","jjwem","jjweb","jjwebs","jjwes",
"jjwess","jjweng","jjwej","jjwech","jjwek","jjwet","jjwep","jjweh","jjwi","jjwig","jjwikk","jjwigs","jjwin","jjwinj","jjwinh","jjwid","jjwil","jjwilg","jjwilm","jjwilb","jjwils","jjwilt","jjwilp","jjwilh","jjwim","jjwib","jjwibs","jjwis","jjwiss","jjwing","jjwij","jjwich","jjwik","jjwit","jjwip","jjwih","jjyu","jjyug","jjyukk","jjyugs","jjyun","jjyunj","jjyunh","jjyud","jjyul","jjyulg","jjyulm","jjyulb","jjyuls","jjyult","jjyulp","jjyulh","jjyum","jjyub","jjyubs","jjyus","jjyuss","jjyung","jjyuj","jjyuch","jjyuk","jjyut","jjyup","jjyuh","jjeu","jjeug","jjeukk","jjeugs","jjeun","jjeunj","jjeunh","jjeud","jjeul","jjeulg","jjeulm","jjeulb","jjeuls","jjeult","jjeulp","jjeulh","jjeum","jjeub","jjeubs","jjeus","jjeuss","jjeung","jjeuj","jjeuch","jjeuk","jjeut","jjeup","jjeuh","jjui","jjuig","jjuikk","jjuigs","jjuin","jjuinj","jjuinh","jjuid","jjuil","jjuilg","jjuilm","jjuilb","jjuils","jjuilt","jjuilp","jjuilh","jjuim","jjuib","jjuibs","jjuis","jjuiss","jjuing","jjuij","jjuich","jjuik","jjuit","jjuip","jjuih","jji","jjig","jjikk","jjigs","jjin","jjinj","jjinh","jjid","jjil",
"jjilg","jjilm","jjilb","jjils","jjilt","jjilp","jjilh","jjim","jjib","jjibs","jjis","jjiss","jjing","jjij","jjich","jjik","jjit","jjip","jjih","cha","chag","chakk","chags","chan","chanj","chanh","chad","chal","chalg","chalm","chalb","chals","chalt","chalp","chalh","cham","chab","chabs","chas","chass","chang","chaj","chach","chak","chat","chap","chah","chae","chaeg","chaekk","chaegs","chaen","chaenj","chaenh","chaed","chael","chaelg","chaelm","chaelb","chaels","chaelt","chaelp","chaelh","chaem","chaeb","chaebs","chaes","chaess","chaeng","chaej","chaech","chaek","chaet","chaep","chaeh","chya","chyag","chyakk","chyags","chyan","chyanj","chyanh","chyad","chyal","chyalg","chyalm","chyalb","chyals","chyalt","chyalp","chyalh","chyam","chyab","chyabs","chyas","chyass","chyang","chyaj","chyach","chyak","chyat","chyap","chyah","chyae","chyaeg","chyaekk","chyaegs","chyaen","chyaenj","chyaenh","chyaed","chyael","chyaelg","chyaelm","chyaelb","chyaels","chyaelt","chyaelp","chyaelh","chyaem","chyaeb","chyaebs","chyaes","chyaess","chyaeng","chyaej","chyaech","chyaek","chyaet",
"chyaep","chyaeh","cheo","cheog","cheokk","cheogs","cheon","cheonj","cheonh","cheod","cheol","cheolg","cheolm","cheolb","cheols","cheolt","cheolp","cheolh","cheom","cheob","cheobs","cheos","cheoss","cheong","cheoj","cheoch","cheok","cheot","cheop","cheoh","che","cheg","chekk","chegs","chen","chenj","chenh","ched","chel","chelg","chelm","chelb","chels","chelt","chelp","chelh","chem","cheb","chebs","ches","chess","cheng","chej","chech","chek","chet","chep","cheh","chyeo","chyeog","chyeokk","chyeogs","chyeon","chyeonj","chyeonh","chyeod","chyeol","chyeolg","chyeolm","chyeolb","chyeols","chyeolt","chyeolp","chyeolh","chyeom","chyeob","chyeobs","chyeos","chyeoss","chyeong","chyeoj","chyeoch","chyeok","chyeot","chyeop","chyeoh","chye","chyeg","chyekk","chyegs","chyen","chyenj","chyenh","chyed","chyel","chyelg","chyelm","chyelb","chyels","chyelt","chyelp","chyelh","chyem","chyeb","chyebs","chyes","chyess","chyeng","chyej","chyech","chyek","chyet","chyep","chyeh","cho","chog","chokk","chogs","chon","chonj","chonh","chod","chol","cholg","cholm","cholb","chols","cholt","cholp",
"cholh","chom","chob","chobs","chos","choss","chong","choj","choch","chok","chot","chop","choh","chwa","chwag","chwakk","chwags","chwan","chwanj","chwanh","chwad","chwal","chwalg","chwalm","chwalb","chwals","chwalt","chwalp","chwalh","chwam","chwab","chwabs","chwas","chwass","chwang","chwaj","chwach","chwak","chwat","chwap","chwah","chwae","chwaeg","chwaekk","chwaegs","chwaen","chwaenj","chwaenh","chwaed","chwael","chwaelg","chwaelm","chwaelb","chwaels","chwaelt","chwaelp","chwaelh","chwaem","chwaeb","chwaebs","chwaes","chwaess","chwaeng","chwaej","chwaech","chwaek","chwaet","chwaep","chwaeh","choe","choeg","choekk","choegs","choen","choenj","choenh","choed","choel","choelg","choelm","choelb","choels","choelt","choelp","choelh","choem","choeb","choebs","choes","choess","choeng","choej","choech","choek","choet","choep","choeh","chyo","chyog","chyokk","chyogs","chyon","chyonj","chyonh","chyod","chyol","chyolg","chyolm","chyolb","chyols","chyolt","chyolp","chyolh","chyom","chyob","chyobs","chyos","chyoss","chyong","chyoj","chyoch","chyok","chyot","chyop","chyoh","chu","chug","chukk","chugs",
"chun","chunj","chunh","chud","chul","chulg","chulm","chulb","chuls","chult","chulp","chulh","chum","chub","chubs","chus","chuss","chung","chuj","chuch","chuk","chut","chup","chuh","chwo","chwog","chwokk","chwogs","chwon","chwonj","chwonh","chwod","chwol","chwolg","chwolm","chwolb","chwols","chwolt","chwolp","chwolh","chwom","chwob","chwobs","chwos","chwoss","chwong","chwoj","chwoch","chwok","chwot","chwop","chwoh","chwe","chweg","chwekk","chwegs","chwen","chwenj","chwenh","chwed","chwel","chwelg","chwelm","chwelb","chwels","chwelt","chwelp","chwelh","chwem","chweb","chwebs","chwes","chwess","chweng","chwej","chwech","chwek","chwet","chwep","chweh","chwi","chwig","chwikk","chwigs","chwin","chwinj","chwinh","chwid","chwil","chwilg","chwilm","chwilb","chwils","chwilt","chwilp","chwilh","chwim","chwib","chwibs","chwis","chwiss","chwing","chwij","chwich","chwik","chwit","chwip","chwih","chyu","chyug","chyukk","chyugs","chyun","chyunj","chyunh","chyud","chyul","chyulg","chyulm","chyulb","chyuls","chyult","chyulp","chyulh","chyum","chyub","chyubs","chyus","chyuss",
"chyung","chyuj","chyuch","chyuk","chyut","chyup","chyuh","cheu","cheug","cheukk","cheugs","cheun","cheunj","cheunh","cheud","cheul","cheulg","cheulm","cheulb","cheuls","cheult","cheulp","cheulh","cheum","cheub","cheubs","cheus","cheuss","cheung","cheuj","cheuch","cheuk","cheut","cheup","cheuh","chui","chuig","chuikk","chuigs","chuin","chuinj","chuinh","chuid","chuil","chuilg","chuilm","chuilb","chuils","chuilt","chuilp","chuilh","chuim","chuib","chuibs","chuis","chuiss","chuing","chuij","chuich","chuik","chuit","chuip","chuih","chi","chig","chikk","chigs","chin","chinj","chinh","chid","chil","chilg","chilm","chilb","chils","chilt","chilp","chilh","chim","chib","chibs","chis","chiss","ching","chij","chich","chik","chit","chip","chih","ka","kag","kakk","kags","kan","kanj","kanh","kad","kal","kalg","kalm","kalb","kals","kalt","kalp","kalh","kam","kab","kabs","kas","kass","kang","kaj","kach","kak","kat","kap","kah","kae","kaeg","kaekk","kaegs","kaen","kaenj","kaenh","kaed","kael","kaelg",
"kaelm","kaelb","kaels","kaelt","kaelp","kaelh","kaem","kaeb","kaebs","kaes","kaess","kaeng","kaej","kaech","kaek","kaet","kaep","kaeh","kya","kyag","kyakk","kyags","kyan","kyanj","kyanh","kyad","kyal","kyalg","kyalm","kyalb","kyals","kyalt","kyalp","kyalh","kyam","kyab","kyabs","kyas","kyass","kyang","kyaj","kyach","kyak","kyat","kyap","kyah","kyae","kyaeg","kyaekk","kyaegs","kyaen","kyaenj","kyaenh","kyaed","kyael","kyaelg","kyaelm","kyaelb","kyaels","kyaelt","kyaelp","kyaelh","kyaem","kyaeb","kyaebs","kyaes","kyaess","kyaeng","kyaej","kyaech","kyaek","kyaet","kyaep","kyaeh","keo","keog","keokk","keogs","keon","keonj","keonh","keod","keol","keolg","keolm","keolb","keols","keolt","keolp","keolh","keom","keob","keobs","keos","keoss","keong","keoj","keoch","keok","keot","keop","keoh","ke","keg","kekk","kegs","ken","kenj","kenh","ked","kel","kelg","kelm","kelb","kels","kelt","kelp","kelh","kem","keb","kebs","kes","kess","keng","kej","kech","kek","ket","kep",
"keh","kyeo","kyeog","kyeokk","kyeogs","kyeon","kyeonj","kyeonh","kyeod","kyeol","kyeolg","kyeolm","kyeolb","kyeols","kyeolt","kyeolp","kyeolh","kyeom","kyeob","kyeobs","kyeos","kyeoss","kyeong","kyeoj","kyeoch","kyeok","kyeot","kyeop","kyeoh","kye","kyeg","kyekk","kyegs","kyen","kyenj","kyenh","kyed","kyel","kyelg","kyelm","kyelb","kyels","kyelt","kyelp","kyelh","kyem","kyeb","kyebs","kyes","kyess","kyeng","kyej","kyech","kyek","kyet","kyep","kyeh","ko","kog","kokk","kogs","kon","konj","konh","kod","kol","kolg","kolm","kolb","kols","kolt","kolp","kolh","kom","kob","kobs","kos","koss","kong","koj","koch","kok","kot","kop","koh","kwa","kwag","kwakk","kwags","kwan","kwanj","kwanh","kwad","kwal","kwalg","kwalm","kwalb","kwals","kwalt","kwalp","kwalh","kwam","kwab","kwabs","kwas","kwass","kwang","kwaj","kwach","kwak","kwat","kwap","kwah","kwae","kwaeg","kwaekk","kwaegs","kwaen","kwaenj","kwaenh","kwaed","kwael","kwaelg","kwaelm","kwaelb","kwaels","kwaelt","kwaelp","kwaelh",
"kwaem","kwaeb","kwaebs","kwaes","kwaess","kwaeng","kwaej","kwaech","kwaek","kwaet","kwaep","kwaeh","koe","koeg","koekk","koegs","koen","koenj","koenh","koed","koel","koelg","koelm","koelb","koels","koelt","koelp","koelh","koem","koeb","koebs","koes","koess","koeng","koej","koech","koek","koet","koep","koeh","kyo","kyog","kyokk","kyogs","kyon","kyonj","kyonh","kyod","kyol","kyolg","kyolm","kyolb","kyols","kyolt","kyolp","kyolh","kyom","kyob","kyobs","kyos","kyoss","kyong","kyoj","kyoch","kyok","kyot","kyop","kyoh","ku","kug","kukk","kugs","kun","kunj","kunh","kud","kul","kulg","kulm","kulb","kuls","kult","kulp","kulh","kum","kub","kubs","kus","kuss","kung","kuj","kuch","kuk","kut","kup","kuh","kwo","kwog","kwokk","kwogs","kwon","kwonj","kwonh","kwod","kwol","kwolg","kwolm","kwolb","kwols","kwolt","kwolp","kwolh","kwom","kwob","kwobs","kwos","kwoss","kwong","kwoj","kwoch","kwok","kwot","kwop","kwoh","kwe","kweg","kwekk","kwegs","kwen",
"kwenj","kwenh","kwed","kwel","kwelg","kwelm","kwelb","kwels","kwelt","kwelp","kwelh","kwem","kweb","kwebs","kwes","kwess","kweng","kwej","kwech","kwek","kwet","kwep","kweh","kwi","kwig","kwikk","kwigs","kwin","kwinj","kwinh","kwid","kwil","kwilg","kwilm","kwilb","kwils","kwilt","kwilp","kwilh","kwim","kwib","kwibs","kwis","kwiss","kwing","kwij","kwich","kwik","kwit","kwip","kwih","kyu","kyug","kyukk","kyugs","kyun","kyunj","kyunh","kyud","kyul","kyulg","kyulm","kyulb","kyuls","kyult","kyulp","kyulh","kyum","kyub","kyubs","kyus","kyuss","kyung","kyuj","kyuch","kyuk","kyut","kyup","kyuh","keu","keug","keukk","keugs","keun","keunj","keunh","keud","keul","keulg","keulm","keulb","keuls","keult","keulp","keulh","keum","keub","keubs","keus","keuss","keung","keuj","keuch","keuk","keut","keup","keuh","kui","kuig","kuikk","kuigs","kuin","kuinj","kuinh","kuid","kuil","kuilg","kuilm","kuilb","kuils","kuilt","kuilp","kuilh","kuim","kuib","kuibs","kuis","kuiss","kuing",
"kuij","kuich","kuik","kuit","kuip","kuih","ki","kig","kikk","kigs","kin","kinj","kinh","kid","kil","kilg","kilm","kilb","kils","kilt","kilp","kilh","kim","kib","kibs","kis","kiss","king","kij","kich","kik","kit","kip","kih","ta","tag","takk","tags","tan","tanj","tanh","tad","tal","talg","talm","talb","tals","talt","talp","talh","tam","tab","tabs","tas","tass","tang","taj","tach","tak","tat","tap","tah","tae","taeg","taekk","taegs","taen","taenj","taenh","taed","tael","taelg","taelm","taelb","taels","taelt","taelp","taelh","taem","taeb","taebs","taes","taess","taeng","taej","taech","taek","taet","taep","taeh","tya","tyag","tyakk","tyags","tyan","tyanj","tyanh","tyad","tyal","tyalg","tyalm","tyalb","tyals","tyalt","tyalp","tyalh","tyam","tyab","tyabs","tyas","tyass","tyang","tyaj","tyach","tyak","tyat","tyap","tyah","tyae","tyaeg","tyaekk","tyaegs","tyaen","tyaenj","tyaenh","tyaed","tyael","tyaelg","tyaelm",
"tyaelb","tyaels","tyaelt","tyaelp","tyaelh","tyaem","tyaeb","tyaebs","tyaes","tyaess","tyaeng","tyaej","tyaech","tyaek","tyaet","tyaep","tyaeh","teo","teog","teokk","teogs","teon","teonj","teonh","teod","teol","teolg","teolm","teolb","teols","teolt","teolp","teolh","teom","teob","teobs","teos","teoss","teong","teoj","teoch","teok","teot","teop","teoh","te","teg","tekk","tegs","ten","tenj","tenh","ted","tel","telg","telm","telb","tels","telt","telp","telh","tem","teb","tebs","tes","tess","teng","tej","tech","tek","tet","tep","teh","tyeo","tyeog","tyeokk","tyeogs","tyeon","tyeonj","tyeonh","tyeod","tyeol","tyeolg","tyeolm","tyeolb","tyeols","tyeolt","tyeolp","tyeolh","tyeom","tyeob","tyeobs","tyeos","tyeoss","tyeong","tyeoj","tyeoch","tyeok","tyeot","tyeop","tyeoh","tye","tyeg","tyekk","tyegs","tyen","tyenj","tyenh","tyed","tyel","tyelg","tyelm","tyelb","tyels","tyelt","tyelp","tyelh","tyem","tyeb","tyebs","tyes","tyess","tyeng","tyej","tyech","tyek","tyet","tyep","tyeh",
"to","tog","tokk","togs","ton","tonj","tonh","tod","tol","tolg","tolm","tolb","tols","tolt","tolp","tolh","tom","tob","tobs","tos","toss","tong","toj","toch","tok","tot","top","toh","twa","twag","twakk","twags","twan","twanj","twanh","twad","twal","twalg","twalm","twalb","twals","twalt","twalp","twalh","twam","twab","twabs","twas","twass","twang","twaj","twach","twak","twat","twap","twah","twae","twaeg","twaekk","twaegs","twaen","twaenj","twaenh","twaed","twael","twaelg","twaelm","twaelb","twaels","twaelt","twaelp","twaelh","twaem","twaeb","twaebs","twaes","twaess","twaeng","twaej","twaech","twaek","twaet","twaep","twaeh","toe","toeg","toekk","toegs","toen","toenj","toenh","toed","toel","toelg","toelm","toelb","toels","toelt","toelp","toelh","toem","toeb","toebs","toes","toess","toeng","toej","toech","toek","toet","toep","toeh","tyo","tyog","tyokk","tyogs","tyon","tyonj","tyonh","tyod","tyol","tyolg","tyolm","tyolb","tyols","tyolt","tyolp","tyolh","tyom",
"tyob","tyobs","tyos","tyoss","tyong","tyoj","tyoch","tyok","tyot","tyop","tyoh","tu","tug","tukk","tugs","tun","tunj","tunh","tud","tul","tulg","tulm","tulb","tuls","tult","tulp","tulh","tum","tub","tubs","tus","tuss","tung","tuj","tuch","tuk","tut","tup","tuh","two","twog","twokk","twogs","twon","twonj","twonh","twod","twol","twolg","twolm","twolb","twols","twolt","twolp","twolh","twom","twob","twobs","twos","twoss","twong","twoj","twoch","twok","twot","twop","twoh","twe","tweg","twekk","twegs","twen","twenj","twenh","twed","twel","twelg","twelm","twelb","twels","twelt","twelp","twelh","twem","tweb","twebs","twes","twess","tweng","twej","twech","twek","twet","twep","tweh","twi","twig","twikk","twigs","twin","twinj","twinh","twid","twil","twilg","twilm","twilb","twils","twilt","twilp","twilh","twim","twib","twibs","twis","twiss","twing","twij","twich","twik","twit","twip","twih","tyu","tyug","tyukk","tyugs","tyun","tyunj",
"tyunh","tyud","tyul","tyulg","tyulm","tyulb","tyuls","tyult","tyulp","tyulh","tyum","tyub","tyubs","tyus","tyuss","tyung","tyuj","tyuch","tyuk","tyut","tyup","tyuh","teu","teug","teukk","teugs","teun","teunj","teunh","teud","teul","teulg","teulm","teulb","teuls","teult","teulp","teulh","teum","teub","teubs","teus","teuss","teung","teuj","teuch","teuk","teut","teup","teuh","tui","tuig","tuikk","tuigs","tuin","tuinj","tuinh","tuid","tuil","tuilg","tuilm","tuilb","tuils","tuilt","tuilp","tuilh","tuim","tuib","tuibs","tuis","tuiss","tuing","tuij","tuich","tuik","tuit","tuip","tuih","ti","tig","tikk","tigs","tin","tinj","tinh","tid","til","tilg","tilm","tilb","tils","tilt","tilp","tilh","tim","tib","tibs","tis","tiss","ting","tij","tich","tik","tit","tip","tih","pa","pag","pakk","pags","pan","panj","panh","pad","pal","palg","palm","palb","pals","palt","palp","palh","pam","pab","pabs","pas","pass","pang","paj",
"pach","pak","pat","pap","pah","pae","paeg","paekk","paegs","paen","paenj","paenh","paed","pael","paelg","paelm","paelb","paels","paelt","paelp","paelh","paem","paeb","paebs","paes","paess","paeng","paej","paech","paek","paet","paep","paeh","pya","pyag","pyakk","pyags","pyan","pyanj","pyanh","pyad","pyal","pyalg","pyalm","pyalb","pyals","pyalt","pyalp","pyalh","pyam","pyab","pyabs","pyas","pyass","pyang","pyaj","pyach","pyak","pyat","pyap","pyah","pyae","pyaeg","pyaekk","pyaegs","pyaen","pyaenj","pyaenh","pyaed","pyael","pyaelg","pyaelm","pyaelb","pyaels","pyaelt","pyaelp","pyaelh","pyaem","pyaeb","pyaebs","pyaes","pyaess","pyaeng","pyaej","pyaech","pyaek","pyaet","pyaep","pyaeh","peo","peog","peokk","peogs","peon","peonj","peonh","peod","peol","peolg","peolm","peolb","peols","peolt","peolp","peolh","peom","peob","peobs","peos","peoss","peong","peoj","peoch","peok","peot","peop","peoh","pe","peg","pekk","pegs","pen","penj","penh","ped","pel","pelg","pelm","pelb",
"pels","pelt","pelp","pelh","pem","peb","pebs","pes","pess","peng","pej","pech","pek","pet","pep","peh","pyeo","pyeog","pyeokk","pyeogs","pyeon","pyeonj","pyeonh","pyeod","pyeol","pyeolg","pyeolm","pyeolb","pyeols","pyeolt","pyeolp","pyeolh","pyeom","pyeob","pyeobs","pyeos","pyeoss","pyeong","pyeoj","pyeoch","pyeok","pyeot","pyeop","pyeoh","pye","pyeg","pyekk","pyegs","pyen","pyenj","pyenh","pyed","pyel","pyelg","pyelm","pyelb","pyels","pyelt","pyelp","pyelh","pyem","pyeb","pyebs","pyes","pyess","pyeng","pyej","pyech","pyek","pyet","pyep","pyeh","po","pog","pokk","pogs","pon","ponj","ponh","pod","pol","polg","polm","polb","pols","polt","polp","polh","pom","pob","pobs","pos","poss","pong","poj","poch","pok","pot","pop","poh","pwa","pwag","pwakk","pwags","pwan","pwanj","pwanh","pwad","pwal","pwalg","pwalm","pwalb","pwals","pwalt","pwalp","pwalh","pwam","pwab","pwabs","pwas","pwass","pwang","pwaj","pwach","pwak","pwat","pwap","pwah","pwae",
"pwaeg","pwaekk","pwaegs","pwaen","pwaenj","pwaenh","pwaed","pwael","pwaelg","pwaelm","pwaelb","pwaels","pwaelt","pwaelp","pwaelh","pwaem","pwaeb","pwaebs","pwaes","pwaess","pwaeng","pwaej","pwaech","pwaek","pwaet","pwaep","pwaeh","poe","poeg","poekk","poegs","poen","poenj","poenh","poed","poel","poelg","poelm","poelb","poels","poelt","poelp","poelh","poem","poeb","poebs","poes","poess","poeng","poej","poech","poek","poet","poep","poeh","pyo","pyog","pyokk","pyogs","pyon","pyonj","pyonh","pyod","pyol","pyolg","pyolm","pyolb","pyols","pyolt","pyolp","pyolh","pyom","pyob","pyobs","pyos","pyoss","pyong","pyoj","pyoch","pyok","pyot","pyop","pyoh","pu","pug","pukk","pugs","pun","punj","punh","pud","pul","pulg","pulm","pulb","puls","pult","pulp","pulh","pum","pub","pubs","pus","puss","pung","puj","puch","puk","put","pup","puh","pwo","pwog","pwokk","pwogs","pwon","pwonj","pwonh","pwod","pwol","pwolg","pwolm","pwolb","pwols","pwolt","pwolp","pwolh","pwom","pwob",
"pwobs","pwos","pwoss","pwong","pwoj","pwoch","pwok","pwot","pwop","pwoh","pwe","pweg","pwekk","pwegs","pwen","pwenj","pwenh","pwed","pwel","pwelg","pwelm","pwelb","pwels","pwelt","pwelp","pwelh","pwem","pweb","pwebs","pwes","pwess","pweng","pwej","pwech","pwek","pwet","pwep","pweh","pwi","pwig","pwikk","pwigs","pwin","pwinj","pwinh","pwid","pwil","pwilg","pwilm","pwilb","pwils","pwilt","pwilp","pwilh","pwim","pwib","pwibs","pwis","pwiss","pwing","pwij","pwich","pwik","pwit","pwip","pwih","pyu","pyug","pyukk","pyugs","pyun","pyunj","pyunh","pyud","pyul","pyulg","pyulm","pyulb","pyuls","pyult","pyulp","pyulh","pyum","pyub","pyubs","pyus","pyuss","pyung","pyuj","pyuch","pyuk","pyut","pyup","pyuh","peu","peug","peukk","peugs","peun","peunj","peunh","peud","peul","peulg","peulm","peulb","peuls","peult","peulp","peulh","peum","peub","peubs","peus","peuss","peung","peuj","peuch","peuk","peut","peup","peuh","pui","puig","puikk","puigs","puin","puinj","puinh",
"puid","puil","puilg","puilm","puilb","puils","puilt","puilp","puilh","puim","puib","puibs","puis","puiss","puing","puij","puich","puik","puit","puip","puih","pi","pig","pikk","pigs","pin","pinj","pinh","pid","pil","pilg","pilm","pilb","pils","pilt","pilp","pilh","pim","pib","pibs","pis","piss","ping","pij","pich","pik","pit","pip","pih","ha","hag","hakk","hags","han","hanj","hanh","had","hal","halg","halm","halb","hals","halt","halp","halh","ham","hab","habs","has","hass","hang","haj","hach","hak","hat","hap","hah","hae","haeg","haekk","haegs","haen","haenj","haenh","haed","hael","haelg","haelm","haelb","haels","haelt","haelp","haelh","haem","haeb","haebs","haes","haess","haeng","haej","haech","haek","haet","haep","haeh","hya","hyag","hyakk","hyags","hyan","hyanj","hyanh","hyad","hyal","hyalg","hyalm","hyalb","hyals","hyalt","hyalp","hyalh","hyam","hyab","hyabs","hyas","hyass","hyang","hyaj","hyach",
"hyak","hyat","hyap","hyah","hyae","hyaeg","hyaekk","hyaegs","hyaen","hyaenj","hyaenh","hyaed","hyael","hyaelg","hyaelm","hyaelb","hyaels","hyaelt","hyaelp","hyaelh","hyaem","hyaeb","hyaebs","hyaes","hyaess","hyaeng","hyaej","hyaech","hyaek","hyaet","hyaep","hyaeh","heo","heog","heokk","heogs","heon","heonj","heonh","heod","heol","heolg","heolm","heolb","heols","heolt","heolp","heolh","heom","heob","heobs","heos","heoss","heong","heoj","heoch","heok","heot","heop","heoh","he","heg","hekk","hegs","hen","henj","henh","hed","hel","helg","helm","helb","hels","helt","help","helh","hem","heb","hebs","hes","hess","heng","hej","hech","hek","het","hep","heh","hyeo","hyeog","hyeokk","hyeogs","hyeon","hyeonj","hyeonh","hyeod","hyeol","hyeolg","hyeolm","hyeolb","hyeols","hyeolt","hyeolp","hyeolh","hyeom","hyeob","hyeobs","hyeos","hyeoss","hyeong","hyeoj","hyeoch","hyeok","hyeot","hyeop","hyeoh","hye","hyeg","hyekk","hyegs","hyen","hyenj","hyenh","hyed","hyel","hyelg","hyelm","hyelb","hyels",
"hyelt","hyelp","hyelh","hyem","hyeb","hyebs","hyes","hyess","hyeng","hyej","hyech","hyek","hyet","hyep","hyeh","ho","hog","hokk","hogs","hon","honj","honh","hod","hol","holg","holm","holb","hols","holt","holp","holh","hom","hob","hobs","hos","hoss","hong","hoj","hoch","hok","hot","hop","hoh","hwa","hwag","hwakk","hwags","hwan","hwanj","hwanh","hwad","hwal","hwalg","hwalm","hwalb","hwals","hwalt","hwalp","hwalh","hwam","hwab","hwabs","hwas","hwass","hwang","hwaj","hwach","hwak","hwat","hwap","hwah","hwae","hwaeg","hwaekk","hwaegs","hwaen","hwaenj","hwaenh","hwaed","hwael","hwaelg","hwaelm","hwaelb","hwaels","hwaelt","hwaelp","hwaelh","hwaem","hwaeb","hwaebs","hwaes","hwaess","hwaeng","hwaej","hwaech","hwaek","hwaet","hwaep","hwaeh","hoe","hoeg","hoekk","hoegs","hoen","hoenj","hoenh","hoed","hoel","hoelg","hoelm","hoelb","hoels","hoelt","hoelp","hoelh","hoem","hoeb","hoebs","hoes","hoess","hoeng","hoej","hoech","hoek","hoet","hoep","hoeh","hyo","hyog",
"hyokk","hyogs","hyon","hyonj","hyonh","hyod","hyol","hyolg","hyolm","hyolb","hyols","hyolt","hyolp","hyolh","hyom","hyob","hyobs","hyos","hyoss","hyong","hyoj","hyoch","hyok","hyot","hyop","hyoh","hu","hug","hukk","hugs","hun","hunj","hunh","hud","hul","hulg","hulm","hulb","huls","hult","hulp","hulh","hum","hub","hubs","hus","huss","hung","huj","huch","huk","hut","hup","huh","hwo","hwog","hwokk","hwogs","hwon","hwonj","hwonh","hwod","hwol","hwolg","hwolm","hwolb","hwols","hwolt","hwolp","hwolh","hwom","hwob","hwobs","hwos","hwoss","hwong","hwoj","hwoch","hwok","hwot","hwop","hwoh","hwe","hweg","hwekk","hwegs","hwen","hwenj","hwenh","hwed","hwel","hwelg","hwelm","hwelb","hwels","hwelt","hwelp","hwelh","hwem","hweb","hwebs","hwes","hwess","hweng","hwej","hwech","hwek","hwet","hwep","hweh","hwi","hwig","hwikk","hwigs","hwin","hwinj","hwinh","hwid","hwil","hwilg","hwilm","hwilb","hwils","hwilt","hwilp","hwilh","hwim","hwib","hwibs",
"hwis","hwiss","hwing","hwij","hwich","hwik","hwit","hwip","hwih","hyu","hyug","hyukk","hyugs","hyun","hyunj","hyunh","hyud","hyul","hyulg","hyulm","hyulb","hyuls","hyult","hyulp","hyulh","hyum","hyub","hyubs","hyus","hyuss","hyung","hyuj","hyuch","hyuk","hyut","hyup","hyuh","heu","heug","heukk","heugs","heun","heunj","heunh","heud","heul","heulg","heulm","heulb","heuls","heult","heulp","heulh","heum","heub","heubs","heus","heuss","heung","heuj","heuch","heuk","heut","heup","heuh","hui","huig","huikk","huigs","huin","huinj","huinh","huid","huil","huilg","huilm","huilb","huils","huilt","huilp","huilh","huim","huib","huibs","huis","huiss","huing","huij","huich","huik","huit","huip","huih","hi","hig","hikk","higs","hin","hinj","hinh","hid","hil","hilg","hilm","hilb","hils","hilt","hilp","hilh","him","hib","hibs","his","hiss","hing","hij","hich","hik","hit","hip","hih",0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"qi","geng","che","jia","hua","chuan","ju","gui","gui","qi","jin","la","nai","lan","lai","luo","luo","luo","luo","luo","le","luo","lao","luo","luo","lao","luo","luan","luan","lan","lan","lan","luan","lan","lan","lan","lan","la","la","la","lang","lang","lang","lang","lang","lai","leng","lao","lu","lu","lu","lu","lao","lu","lu","lu","lu","lu","lu","lu","lu","lu","lu","lu","lu","lun","long","nong","long","long","lao","lei","lu","lei","lei","lu","lou","lei","lou","lei","lu","lou","lei","le","lin","ling","leng","ling","ling","ling","du","na","le","nuo","dan","ning","nu","lu","yi","bei","pan","bian","fu","bu","mi","shu","suo","can","sai","sheng","ye",
"shuo","sha","chen","chen","shi","ruo","e","e","liang","liang","liang","liang","liang","liang","liang","liang","li","lu","nu","lu","lu","lu","li","lu","li","li","li","li","li","li","li","nian","lian","lian","nian","lian","lian","lian","nian","lian","lian","nian","lian","lian","lian","lie","lie","yan","lie","lie","shuo","lian","nian","nian","lian","lian","lie","ling","ling","ning","ling","lian","ling","ying","ling","ling","ling","ling","ling","ling","li","li","li","li","e","le","liao","liao","niao","liao","le","liao","liao","liao","liao","long","yun","ruan","liu","chou","liu","liu","liu","liu","liu","liu","niu","lei","liu","lu","lu","lun","lun","lun","lun","lu","li","li","lu","long","li","li","lu","yi","li","li","ni","li","li","li","li","li","li","li","ni","ni","lin","lin","lin",
"lin","lin","lin","lin","lin","lin","lin","li","li","li","zhuang","zhi","shi","shen","cha","ci","qie","du","ta","tang","zhai","dong","bao","fu","xing","jiang","jian","kuo","wu","hu",0,0,"zhong",0,"qing",0,0,"xi","zhu","yi","li","shen","xiang","fu","jing","jing","yu",0,"qiu",0,"zhu",0,0,"yi","dou",0,0,0,"fan","si","guan","he","lang","li","wu","seng","mian","mian","qin","bei","he","tan","qi","ping","mo","ceng","che","hui","kai","zeng","cheng","min","ji","shu","mei","hai","zhu","han","zhu","zhao","zuo","bei","she","zhi","qi","you","zu","zhu","huo","zhen","gu","tu","jie","lian","jin","fan","shu","zhe","chou","cao","cao","zhe","he","shi","ye","jin","bin","zeng","chuo","yi","nan","xiang","pin","hui",0,"guan",0,0,"bing",
"kuang","quan","xing","chong","ji","yong","shao","he","tao","hui","wa","zhong","fen","yan","ben","bi","ci","ao","yi","cai","yao","wang","shen","yu","zeng","ao","cheng","dai","yu","sou","bing","ao","qing","lang","wang","zhang","dai","sha","liu","yin","zi","han","jing","zhu","qiao","jue","fan","zhu","zhen","ci","hua","guan","wen","yi","sheng","zhi","juan","zhe","tian","tiao","jie","lei","tao","lian","ping","zhe","huang","hua","yun","qiang","fu","shi","diao","zhu","qing","ye","nuo","yu","jin","bian","zeng","shu","chi","sou","xing","zhu","nan","jing","bai","xiang","e","pin","zhen","gui",0,0,0,"he","xie","jie",0,"qian","beng","e","pang",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,"ff","fi","fl","ffi","ffl","st","st",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"yi",0,"yya",0,0,"d","h","k","l","m","r","t",0,"s","s","s","s",0,0,0,"b","g","d","h","w","z",0,"t","y","k","k","l",0,"m",0,"n","s",0,"p","p",0,"z","q","r","s","t","wo","b","k","p",0,0,0,0,0,0,0,"p","p","p","p",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"v","v","v","v",0,0,0,0,0,
0,0,0,0,0,0,0,"ch","ch","ch","ch",0,0,0,0,0,0,0,0,0,0,0,0,"zh","zh",0,0,"k","k","k","k","g","g","g","g",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"ng","ng","ng","ng",0,0,0,0,0,0,0,"v","v",0,0,0,0,0,0,0,0,"y","y","ya","ya",0,0,"yw","yw",0,0,0,0,
0,0,0,0,0,"yy","yy","yy","y","y","y","y","yj","yh","ym","yy","yy","bj","bh","bkh","bm","by","by","tj","th","tkh","tm","ty","ty","thj","thm","thy","thy","jh","jm","hj","hm","khj","khh","khm","sj","sh","skh","sm","sh","sm","dj","dh","dkh","dm","th","tm","zm",0,0,"ghj","ghm","fj","fh","fkh","fm","fy","fy","qh","qm","qy","qy","ka","kj","kh","kkh","kl","km","ky","ky","lj","lh","lkh","lm","ly","ly","mj","mh","mkh","mm","my","my","nj","nh","nkh","nm","ny","ny","hj","hm","hy","hy","yj","yh","ykh","ym","yy","yy","dh","r","y",0,0,0,0,0,0,"yr","yz","ym","yn","yy","yy","br","bz","bm","bn","by","by","tr","tz","tm","tn","ty",
"ty","thr","thz","thm","thn","thy","thy","fy","fy","qy","qy","ka","kl","km","ky","ky","lm","ly","ly","ma","mm","nr","nz","nm","nn","ny","ny","y","yr","yz","ym","yn","yy","yy","yj","yh","ykh","ym","yh","bj","bh","bkh","bm","bh","tj","th","tkh","tm","th","thm","jh","jm","hj","hm","khj","khm","sj","sh","skh","sm","sh","skh","sm","dj","dh","dkh","dm","th","zm",0,0,"ghj","ghm","fj","fh","fkh","fm","qh","qm","kj","kh","kkh","kl","km","lj","lh","lkh","lm","lh","mj","mh","mkh","mm","nj","nh","nkh","nm","nh","hj","hm","h","yj","yh","ykh","ym","yh","ym","yh","bm","bh","tm","th","thm","thh","sm","sh","shm","shh","kl","km","lm","nm","nh","ym","yh","a","u","i","ty",
"ty",0,0,"ghy","ghy","sy","sy","shy","shy","hy","hy","jy","jy","khy","khy","sy","sy","dy","dy","shj","shh","shkh","shm","shr","sr","sr","dr","ty","ty",0,0,"ghy","ghy","sy","sy","shy","shy","hy","hy","jy","jy","khy","khy","sy","sy","dy","dy","shj","shh","shkh","shm","shr","sr","sr","dr","shj","shh","shkh","shm","sh","shh","tm","sj","sh","skh","shj","shh","shkh","tm","zm",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"tjm","thj","thj","thm","tkhm","tmj","tmh","tmkh","jmh","jmh","hmy","hmy","shj","sjh","sjy","smh","smh","smj","smm","smm","shh","shh","smm","shhm","shhm","shjy","shmkh","shmkh","shmm","shmm","dhy","dkhm","dkhm","tmh","tmh","tmm","tmy",0,0,
0,0,"ghmm","ghmy","ghmy","fkhm","fkhm","qmh","qmm","lhm","lhy","lhy","ljj","ljj","lkhm","lkhm","lmh","lmh","mhj","mhm","mhy","mjh","mjm","mkhj","mkhm",0,0,"mjkh","hmj","hmm","nhm","nhy","njm","njm","njy","nmy","nmy","ymm","ymm","bkhy","tjy","tjy","tkhy","tkhy","tmy","tmy","jmy","jhy","jmy","skhy","shy","shhy","dhy","ljy","lmy","yhy","yjy","ymy","mmy","qmy","nhy","qmh","lhm",0,"kmy","njh","mkhy","ljm","kmm","ljm","njh","jhy","hjy","mjy","fmy","bhy","kmm",0,"smm","skhy","njy",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"allh","akbr","mhmd",0,"rswl",0,
"wslm","sly",0,0,"ryal",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"a",0,
"u",0,"i",0,0,0,0,0,"a","a","a","a","w","w","a","a","y","y","y","y","a","a","b","b","b","b","t","t","t","t","t","t","th","th","th","th","j","j","j","j","h","h","h","h","kh","kh","kh","kh","d","d","dh","dh","r","r","z","z","s","s","s","s","sh","sh","sh","sh","s","s","s","s","d","d","d","d","t","t","t","t","z","z","z","z",0,0,0,0,"gh","gh","gh","gh","f","f","f","f","q","q","q","q","k","k","k","k","l","l","l","l","m","m","m","m","n","n","n","n","h","h","h","h","w","w","y","y","y","y","y","y","la","la","la","la","la",
"la","la","la",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"0","1","2","3","4","5","6","7","8","9",0,0,0,0,0,0,0,"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z",0,0,0,0,0,0,"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z",0,0,0,0,0,0,0,0,0,0,0,"wo",0,0,0,0,0,0,0,0,0,0,"a","i","u","e","o","ka","ki","ku","ke","ko",
"sa","shi","su","se","so","ta","chi","tsu","te","to","na","ni","nu","ne","no","ha","hi","fu","he","ho","ma","mi","mu","me","mo","ya","yu","yo","ra","ri","ru","re","ro","wa","n",0,0,0,"g","kk","gs","n","nj","nh","d","tt","l","lg","lm","lb","ls","lt","lp",0,"m","b","pp",0,"s","ss","","j","jj","ch","k","t","p","h",0,0,0,"a","ae","ya","yae","eo","e",0,0,"yeo","ye","o","wa","wae","oe",0,0,"yo","u","wo","we","wi","yu",0,0,"eu","ui","i",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,};

char * transform(int code) {
	return (code >=0 && code <=65535) ? transChars[code] : 0;
}
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'

Global _trans:TTranslator

Type TTranslator

	Field _app:TAppDecl

	Field outputFiles:TMap = New TMap

	Field indent$
	Field LINES:TStringList'=New TStringList
	Field unreachable:Int,broken:Int
	
	Field contLabelId:Int
	Field exitLabelId:Int
	
	'Munging needs a big cleanup!
	
	Field mungScope:TMap=New TMap'<TDecl>
	Field mungStack:TStack=New TStack'< StringMap<TDecl> >
	Field funcMungs:TMap=New TMap'<FuncDeclList>
	Field customVarStack:TStack = New TStack
	Field varStack:TStack = New TStack

	Field tryStack:TStack = New TStack
	Field loopTryStack:TStack = New TStack

	Field mungedScopes:TMap=New TMap'<StringSet>
	'Field funcMungs:TFuncDeclList=New TFuncDeclList
	'Field mungedFuncs:TMap=New Map
	Field localScopeStack:TStack = New TStack
	Field localScope:TStack = New TStack
	Field ind:Int
	Field debugOut:String
	
	Field processingReturnStatement:Int

	Method PushVarScope()
		varStack.Push customVarStack
		customVarStack = New TStack
	End Method
	
	Method PopVarScope()
		customVarStack=TStack(varStack.Pop())
	End Method
	
	Method PushLoopLocalStack(stmt:Object)
		ind :+ 1
		If DEBUG Then
			Emit "// --> STACK = " + ind
		End If
		localScope.Push stmt
	End Method

	Method PopLoopLocalStack()
		If DEBUG Then
			Emit "// <-- STACK = " + ind
		End If
		ind :- 1
		If ind < 0 Then
			InternalErr
		End If
		localScope.Pop
	End Method

	Method LoopLocalScopeDepth:Int(findStmt:TStmt)
		Local count:Int = 0

		For Local stmt:Object = EachIn localScope
			If TBlockDecl(stmt) = Null Then
				If findStmt And TTryBreakCheck(stmt) And findStmt <> TTryBreakCheck(stmt).stmt Then
					Continue
				End If
				Exit
			End If

			count :+ 1
		Next
		
		Return count
	End Method

	Method GetTopLocalLoop:TTryBreakCheck(findStmt:TStmt)
		For Local tbc:TTryBreakCheck = EachIn localScope
			If findStmt And findStmt <> tbc.stmt Then
				Continue
			End If
			Return tbc
		Next
	End Method

	Method PushLoopTryStack(stmt:Object)
		If loopTryStack.Length() = 0 Then
			' Try statements can only be applied here to loops
			If TTryStmt(stmt) = Null Then
				loopTryStack.Push stmt
			End If
		Else
			loopTryStack.Push stmt
		End If
	End Method

	Method PopLoopTryStack()
		loopTryStack.Pop
	End Method
	
	Method LoopTryDepth:Int(findStmt:TStmt)
		Local count:Int = 0
		
		For Local stmt:Object = EachIn loopTryStack
			If TTryStmt(stmt) = Null Then
				If findStmt And findStmt <> stmt Then
					Continue
				End If
				
				Exit
			End If

			count :+ 1
		Next
		
		Return count
	End Method

	Method GetTopLoop:TTryBreakCheck(findStmt:TStmt)
		For Local tbc:TTryBreakCheck = EachIn loopTryStack
			If findStmt And findStmt <> tbc.stmt Then
				Continue
			End If
			Return tbc
		Next
	End Method

	Method TransManglePointer$( ty:TType )
		Local p:String
		
		If ty

			If ty._flags & TType.T_VAR Then
				p:+ "v"
			End If

			If ty._flags & TType.T_PTR Then
				p:+ "p"
			Else If ty._flags & TType.T_PTRPTR Then
				p:+ "pp"
			Else If ty._flags & TType.T_PTRPTRPTR Then
				p:+ "ppp"
			End If

		End If
		
		Return p
	End Method

	Method TransMangleType:String(ty:TType)
		Local p:String = TransManglePointer(ty)

		If TVoidType( ty ) Return "v"
		If TByteType( ty ) Return p + "b"
		If TShortType( ty ) Return p + "s"
		If TIntType( ty ) Return p + "i"
		If TUIntType( ty ) Return p + "u"
		If TFloatType( ty ) Return p + "f"
		If TDoubleType( ty ) Return p + "d"
		If TLongType( ty ) Return p + "l"
		If TULongType( ty ) Return p + "y"
		If TSizeTType( ty ) Return p + "z"
		If TFloat64Type( ty ) Return p + "h"
		If TFloat128Type( ty ) Return p + "k"
		If TInt128Type( ty ) Return p + "j"
		If TDouble128Type( ty ) Return p + "m"
		If TStringType( ty ) Return p + "S"
		If TWParamType( ty ) Return p + "W"
		If TLParamType( ty ) Return p + "L"
		If TArrayType( ty ) Then
			Return p + "a" + TransMangleType(TArrayType( ty ).elemType)
		End If
		If TObjectType( ty ) Then
			If Not TObjectType( ty ).classdecl.IsExtern()
				Return p + "T" + TObjectType( ty ).classDecl.ident
			Else
				If TObjectType( ty ).classdecl.IsInterface() Then
					Return p + "I" + TObjectType(ty).classDecl.ident
				ElseIf TObjectType( ty ).classdecl.IsStruct() Then
					Return p + "R" + TObjectType(ty).classDecl.ident
				Else
					Return p + "E" + TObjectType(ty).classDecl.ident
				End If
			End If
		End If
		If TFunctionPtrType( ty ) Then
			Local func:TFuncDecl = TFunctionPtrType( ty ).func
			Local s:String = "F" + MangleMethodArgs(func)
'			For Local i:Int = 0 Until func.argDecls.length
'				s :+ TransMangleType(func.argDecls[i].ty)
'			Next
			Return s + "_" + TransMangleType(func.retType) + "_"
		End If
		
		Err "Unsupported type for name mangling : " + ty.ToString()
	End Method

	Method MangleMethod:String(fdecl:TFuncDecl)
		If (fdecl.IsMethod() And Not fdecl.ClassScope().IsStruct())Or fdecl.IsCtor() Then
			Return MangleMethodArgs(fdecl)
		Else
			Return MangleMethodRetType(fdecl) + MangleMethodArgs(fdecl)
		End If
	End Method
	
	Method MangleMethodRetType:String(fdecl:TFuncDecl)
		If fdecl.retType Then
			Return "_" + TransMangleType(fdecl.retType)
		Else
			Return "_v"
		End If
	End Method
	
	Method MangleMethodArgs:String(fdecl:TFuncDecl)
		Local s:String
		For Local arg:TArgDecl = EachIn fdecl.argDecls
			If Not s Then
				s = "_"
			End If
			s :+ TransMangleType(arg.ty)
		Next
		Return s
	End Method

	Method equalsTorFunc:Int(classDecl:TClassDecl, func:TFuncDecl)
		If func.IdentLower() = "new" Or func.IdentLower() = "delete" Then
			Return True
		End If
		Return False
	End Method

	Method equalsBuiltInFunc:Int(classDecl:TClassDecl, func:TFuncDecl, checked:Int = False)
		If func.equalsBuiltIn > -1 Then
			Return func.equalsBuiltIn
		End If
	
		If checked Or func.IdentLower() = "tostring" Or func.IdentLower() = "compare" Or func.IdentLower() = "sendmessage" Or func.IdentLower() = "new" Or func.IdentLower() = "delete" Then
			If classDecl.munged = "bbObjectClass" Then
				For Local decl:TFuncDecl = EachIn classDecl.Decls()
					If Not decl.IsSemanted() Then
						decl.Semant
					End If
					If decl.IdentLower() = func.IdentLower() Then
						Local res:Int = decl.EqualsFunc(func)
						If res Then
							func.equalsBuiltIn = True
						End If
						Return res
					End If
				Next
			End If
			If classDecl.superClass Then
				Return equalsBuiltInFunc(classDecl.superClass, func, True)
			End If
		End If
		func.equalsBuiltIn = False
		Return False
	End Method

	Method equalsIfcBuiltInFunc:Int(classDecl:TClassDecl, func:TFuncDecl, checked:Int = False)
		If checked Or func.IdentLower() = "new" Or func.IdentLower() = "delete" Then
			If classDecl.munged = "bbObjectClass" Then
				For Local decl:TFuncDecl = EachIn classDecl.Decls()
					If Not decl.IsSemanted() Then
						decl.Semant
					End If
					If decl.IdentLower() = func.IdentLower() Then
						Return decl.EqualsFunc(func)
					End If
				Next
			End If
			If classDecl.superClass Then
				Return equalsIfcBuiltInFunc(classDecl.superClass, func, True)
			End If
		End If
		Return False
	End Method

	Method MungFuncDecl( fdecl:TFuncDecl )

		If fdecl.munged Return
		
		Local funcs:TFuncDeclList=TFuncDeclList(funcMungs.ValueForKey( fdecl.ident ))
		If funcs
			For Local tdecl:TFuncDecl=EachIn funcs
				If fdecl.EqualsArgs( tdecl )
					fdecl.munged=tdecl.munged
					Return
				EndIf
			Next
		Else
			funcs=New TFuncDeclList
			funcMungs.Insert fdecl.ident,funcs
		EndIf

		If fdecl.scope Then
			Local id:String = fdecl.ident

			If fdecl.attrs & FUNC_OPERATOR Then
				id = MungSymbol(id)
			End If
			
			fdecl.munged = fdecl.scope.munged + "_" + id
			
			If Not equalsBuiltInFunc(fdecl.classScope(), fdecl) And Not fdecl.noMangle Then
				fdecl.munged :+ MangleMethod(fdecl)
			End If
			
			' fields are lowercase with underscore prefix.
			' a function pointer with FUNC_METHOD is a field function pointer.
			'If TFieldDecl(fdecl) Or (TFuncDecl(decl) And (decl.attrs & FUNC_METHOD) And (decl.attrs & FUNC_PTR)) Then
			'	munged = "_" + munged.ToLower()
			'End If
		Else
			fdecl.munged="bb_"+fdecl.ident
		End If
		
		funcs.AddLast fdecl
	End Method
	
	Method MungSymbol:String(sym:String)
		Select sym
			Case "*"
				Return "_mul"
			Case "/"
				Return "_div"
			Case "+"
				Return "_add"
			Case "-"
				Return "_sub"
			Case "&"
				Return "_and"
			Case "|"
				Return "_or"
			Case "~~"
				Return "_xor"
			Case ":*"
				Return "_muleq"
			Case ":/"
				Return "_diveq"
			Case ":+"
				Return "_addeq"
			Case ":-"
				Return "_subeq"
			Case ":&"
				Return "_andeq"
			Case ":|"
				Return "_oreq"
			Case ":~~"
				Return "_xoreq"
			Case "<"
				Return "_lt"
			Case "<="
				Return "_le"
			Case ">"
				Return "_gt"
			Case ">="
				Return "_ge"
			Case "="
				Return "_eq"
			Case "<>"
				Return "_ne"
			Case "mod"
				Return "_mod"
			Case "shl"
				Return "_shl"
			Case "shr"
				Return "_shr"
		End Select
		Return "?? unknown symbol ?? : " + sym
	End Method
	
	Method MungDecl( decl:TDecl, addIfNotInScope:Int = False )

		If decl.munged Then
			' ensure function args get into local scope correctly.
			If addIfNotInScope Then
				If Not mungScope.Contains( decl.munged ) Then
					mungScope.Insert(decl.munged, decl)
				End If
			End If
			Return
		End If

		Local fdecl:TFuncDecl=TFuncDecl( decl )
		
		' apply mangling to methods and New (ctors)
		' but don't apply mangling to function pointers
		If fdecl And fdecl.ClassScope() And Not (fdecl.attrs & FUNC_PTR)
			MungFuncDecl( fdecl )
			Return
		End If
		
		Local id$=decl.ident,munged$
		
		'this lot just makes output a bit more readable...
'		Select ENV_LANG
'		Case "js"
'			If TModuleDecl( decl.scope ) Or TGlobalDecl( decl ) Or (fdecl And Not fdecl.IsMethod())
'				munged=decl.ModuleScope().munged+"_"+id
'			EndIf
'		Case "as"
'			If TModuleDecl( decl.scope )
'				munged=decl.ModuleScope().munged+"_"+id
'			EndIf
'		Case "cs"
'			If TClassDecl( decl )
'				munged=decl.ModuleScope().munged+"_"+id
'			EndIf
'		Case "java"
'			If TClassDecl( decl )
'				munged=decl.ModuleScope().munged+"_"+id
'			EndIf
'		Case "cpp"
			If TModuleDecl( decl.scope )
				munged=decl.ModuleScope().munged+"_"+id
			EndIf

			If TModuleDecl( decl )
				munged=decl.ModuleScope().munged+"_"+id
			EndIf

'		End Select
'DebugStop

		If Not munged
			If TLocalDecl( decl )
				munged="bbt_"+id
			Else
				If decl.scope Then
					munged = decl.scope.munged + "_" + id
					
					' fields are lowercase with underscore prefix.
					' a function pointer with FUNC_METHOD is a field function pointer.
					If TFieldDecl(decl) Or (TFuncDecl(decl) And (decl.attrs & FUNC_METHOD) And (decl.attrs & FUNC_PTR)) Then
						munged = "_" + munged.ToLower()
					End If
				Else
					munged="bb_"+id
				End If
			EndIf
		EndIf

		'sanitize non-mung-able characters
		munged = TStringHelper.Sanitize(munged)


		'add an increasing number to identifier if already used  
		If mungScope.Contains( munged )
			Local i:Int=1
			Repeat
				i:+1
			Until Not mungScope.Contains( munged + i )
			munged :+ i
		EndIf

		mungScope.Insert(munged, decl)
		decl.munged=munged
		
		' a function pointers' real function is stored in "func" - need to set its munged to match the parent.
		If TValDecl(decl) Then
			If TFunctionPtrType(TValDecl(decl).ty) Then
				TFunctionPtrType(TValDecl(decl).ty).func.munged = munged
			End If
		End If
		
	End Method

Rem
	Method MungDecl( decl:TDecl )

		If decl.munged Return

		Local fdecl:TFuncDecl=TFuncDecl( decl )
		If fdecl And fdecl.IsMethod() Then
'			DebugStop
			MungFuncDecl( fdecl )
			Return
		End If
		
		Local id:String=decl.ident,munged$,scope$
		
		If TLocalDecl( decl )
			scope="$"
			munged="t_"+id
		Else If TClassDecl( decl )
			scope=""
			munged="c_"+id
		Else If TModuleDecl( decl )
			scope=""
			munged="bb_"+id
		Else If TClassDecl( decl.scope )
			scope=decl.scope.munged
			munged="m_"+id
		Else If TModuleDecl( decl.scope )
			'If ENV_LANG="cs" Or ENV_LANG="java"
			'	scope=decl.scope.munged
			'	munged="g_"+id
			'Else
				scope=""
				munged=decl.scope.munged+"_"+id
			'EndIf
		Else
			InternalErr
		EndIf
		
		Local set:TMap=TMap(mungedScopes.ValueForKey( scope ))
		If set
			If set.Contains( munged.ToLower() )
				Local id:Int=1
				Repeat
					id :+ 1
					Local t$=munged+id
					If set.Contains( t.ToLower() ) Continue
					munged=t
					Exit
				Forever
			End If
		Else
			If scope="$"
				Print "OOPS2"
				InternalErr
			EndIf
			set=New TMap
			mungedScopes.Insert scope,set
		End If
		set.Insert munged.ToLower(), ""
		decl.munged=munged
	End Method
End Rem



	
	Method Bra$( str$ )
		If str.StartsWith( "(" ) And str.EndsWith( ")" )
			Local n:Int=1
			For Local i:Int=1 Until str.Length-1
				Select str[i..i+1]
				Case "("
					n:+1
				Case ")"
					n:-1
					If Not n Return "("+str+")"
				End Select
			Next
			If n=1 Return str
'			If str.FindLast("(")<str.Find(")") Return str
		EndIf
		Return "("+str+")"
	End Method
	
	'Utility C/C++ style...
	Method Enquote$( str$ )
		Return LangEnquote( str )
	End Method
	
	Method EscapeChars:String(str:String)
		If str Then
			Local found:Int = False
			For Local i:Int = 0 Until str.length
				If str[i] > 127 Then
					found = True
					Exit
				End If
			Next
			
			If Not found Then
				Return str
			End If
		
			Local s:String
			
			For Local i:Int = 0 Until str.length
				Local char:Int = str[i]
				
				If char < 128 Then
					s :+ Chr(char)
				Else
					s :+ "~~" + char + "~~"
				End If
			Next
			
			Return s
		End If
	End Method

	Method TransUnaryOp$( op$ )
		Select op
		Case "+" Return "+"
		Case "-" Return "-"
		Case "~~" Return op
		Case "not" Return "!"
		End Select
		InternalErr
	End Method
	
	Method TransBinaryOp$( op$,rhs$ )
'DebugLog "TransBinaryOp '" + op + "' : '" + rhs + "'"
op = mapSymbol(op)
		Select op
		Case "+","-"
			If rhs.StartsWith( op ) Return op+" "
			Return op
		Case "*","/" Return op
		Case "shl" Return "<<"
		Case "shr" Return ">>"
		Case "sar" Return ">>"
		Case "mod" Return " % "
		Case "and" Return " && "
		Case "or" Return " || "
		Case "=" Return "=="
		Case "<>" Return "!="
		Case "<","<=",">",">=" Return op
		Case "=<" Return "<="
		Case "=>" Return ">="
		Case "&","|" Return op
		Case "~~" Return "^"
		Case "<<", ">>" Return Op
		Case "%" Return Op
		End Select
		InternalErr
	End Method
	
	Method TransAssignOp$( op$ )
op = mapSymbol(op)
		Select op
		Case ":mod" Return "%="
		Case ":shl" Return "<<="
		Case ":shr" Return ">>="
		Case ":sar" Return ">>="
		End Select
		Return op
	End Method
	
	Method ExprPri:Int( expr:TExpr )
		'
		'1=primary,
		'2=postfix
		'3=prefix
		'
		If TNewObjectExpr( expr )
			Return 3
		Else If TUnaryExpr( expr )
			Select TUnaryExpr( expr ).op
			Case "+","-","~~","not" Return 3
			End Select
			InternalErr
		Else If TBinaryExpr( expr )
			Select TBinaryExpr( expr ).op
			Case "^" Return 4
			Case "*","/","mod","%" Return 5
			Case "+","-" Return 6
			Case "shl","shr", "sar","<<", ">>" Return 7
			Case "<","<=",">",">=", "=<", "=>" Return 8
			Case "=","<>" Return 9
			Case "&" Return 10
			Case "~~" Return 11
			Case "|" Return 12
			Case "and" Return 13
			Case "or" Return 14
			End Select
			InternalErr
		EndIf
		Return 2
	End Method
	
	Method TransSubExpr$( expr:TExpr,pri:Int=2 )
		Local t_expr$=expr.Trans()
		'If expr.exprType._flags & TTYPE.T_VAR Then
		'	t_expr = Bra("*" + t_expr)
		'End If
		If ExprPri( expr )>pri t_expr=Bra( t_expr )
		Return t_expr
	End Method
	
	Method TransExprNS$( expr:TExpr )
		If TVarExpr( expr ) Return expr.Trans()
		If TConstExpr( expr ) Return expr.Trans()
		Return CreateLocal( expr )
	End Method
	
	Method CreateLocal$( expr:TExpr, init:Int = True, vol:Int = True )
		Local tmp:TLocalDecl=New TLocalDecl.Create( "",expr.exprType,expr, True, , vol )
		MungDecl tmp
		Emit TransLocalDecl( tmp,expr, True, init )+";"

		EmitGDBDebug(_errInfo)
		
		Return tmp.munged
	End Method

	'***** Utility *****

	Method TransLocalDecl$( decl:TLocalDecl,init:TExpr, declare:Int = False, outputInit:Int = True ) Abstract

	Method TransGlobalDecl$( gdecl:TGlobalDecl ) Abstract
	
	Method EmitPushErr()
	End Method
	
	Method EmitSetErr( errInfo$ )
	End Method
	
	Method EmitPopErr()
	End Method
	
	'***** Declarations *****
	
	Method TransGlobal$( decl:TGlobalDecl ) Abstract
	
	Method TransField$( decl:TFieldDecl,lhs:TExpr ) Abstract
	
	Method TransFunc$( decl:TFuncDecl,args:TExpr[],lhs:TExpr, sup:Int = False, scope:TScopeDecl = Null ) Abstract
	
	Method TransSuperFunc$( decl:TFuncDecl,args:TExpr[], scope:TScopeDecl ) Abstract
	
	
	'***** Expressions *****
	
	Method TransConstExpr$( expr:TConstExpr ) Abstract
	
	Method TransNewObjectExpr$( expr:TNewObjectExpr ) Abstract
	
	Method TransNewArrayExpr$( expr:TNewArrayExpr ) Abstract
	
	Method TransSelfExpr$( expr:TSelfExpr ) Abstract
	
	Method TransCastExpr$( expr:TCastExpr ) Abstract
	
	Method TransUnaryExpr$( expr:TUnaryExpr ) Abstract
	
	Method TransBinaryExpr$( expr:TBinaryExpr ) Abstract
	
	Method TransIndexExpr$( expr:TIndexExpr ) Abstract
	
	Method TransSliceExpr$( expr:TSliceExpr ) Abstract
	
	Method TransArrayExpr$( expr:TArrayExpr ) Abstract
	
	Method TransArraySizeExpr$ ( expr:TArraySizeExpr ) Abstract
	
	Method TransIntrinsicExpr$( decl:TDecl,expr:TExpr,args:TExpr[]=Null ) Abstract
	
	Method TransArgs$( args:TExpr[],decl:TFuncDecl, objParam:String = Null ) Abstract

	Method EmitDebugEnterScope(block:TBlockDecl) Abstract
	
	Method EmitLocalDeclarations(decl:TScopeDecl, v:TValDecl = Null) Abstract
	
	Method TransType$( ty:TType, ident:String, fpReturnTypeFunctionArgs:String = Null, fpReturnTypeClassFunc:Int = False) Abstract
	
	Method BeginLocalScope()
		mungStack.Push mungScope
		mungScope:TMap=New TMap'<TDecl>
'		mungedScopes.Insert "$",New TMap
		
		If opt_debug Then
			localScopeStack.Push localScope
			localScope = New TStack
		End If
	End Method
	
	Method EndLocalScope()
		mungScope=TMap(mungStack.Pop())
'		mungedScopes.Insert "$",Null

		If opt_debug Then
			localScope = TStack(localScopeStack.Pop())
		End If
	End Method

Rem	
	Method MungMethodDecl( fdecl:TFuncDecl )

		If fdecl.munged Return
		
		If fdecl.overrides
			MungMethodDecl fdecl.overrides
			fdecl.munged=fdecl.overrides.munged
			Return
		EndIf
		
		Local funcs:=funcMungs.Get( fdecl.ident )
		If funcs
			For Local tdecl:=EachIn funcs
				If fdecl.EqualsArgs( tdecl )
					fdecl.munged=tdecl.munged
					Return
				EndIf
			Next
		Else
			funcs=New FuncDeclList
			funcMungs.Set fdecl.ident,funcs
		EndIf
		
		Local id:=fdecl.ident
		If mungedFuncs.Contains( id )
			Local n:=1
			Repeat
				n+=1
				id=fdecl.ident+String(n)
			Until Not mungedFuncs.Contains( id )
		EndIf
		
		mungedFuncs.Set id,fdecl
		fdecl.munged="p_"+id
		funcs.AddLast fdecl
	End
End Rem	
	'***** Simple statements *****
	
	'Expressions
	Method TransStmtExpr$( expr:TStmtExpr )
		Local t$=expr.stmt.Trans()
		If t Emit t+";"
		Return expr.expr.Trans()
	End Method
	
	Method TransTemplateCast$( ty:TType,src:TType,expr$ )
		Return expr
	End Method
	
	Method TransVarExpr$( expr:TVarExpr )
		Local decl:TVarDecl=TVarDecl( expr.decl.actual )

		If decl.munged.StartsWith( "$" ) Return TransIntrinsicExpr( decl,Null )
		
		If TLocalDecl( decl ) Then
			If decl.ty._flags & TType.T_VAR Then
				Return "*" + decl.munged
			Else
				Return decl.munged
			End If
		End If
		
		If TFieldDecl( decl ) Return TransField( TFieldDecl( decl ),Null )
		
		If TGlobalDecl( decl ) Return TransGlobal( TGlobalDecl( decl ) )
		
		InternalErr
	End Method
	
	Method TransMemberVarExpr$( expr:TMemberVarExpr )
		Local decl:TVarDecl=TVarDecl( expr.decl.actual )
		
		If decl.munged.StartsWith( "$" ) Return TransIntrinsicExpr( decl,expr.expr )
		
		If TFieldDecl( decl ) Return TransField( TFieldDecl( decl ),expr.expr )

		InternalErr
	End Method
	
	Method TransInvokeExpr$( expr:TInvokeExpr )
		Local decl:TFuncDecl=TFuncDecl( expr.decl.actual ),t$
'If decl.ident = "OnDebugStop" DebugStop	
		If Not decl.munged Then
			MungDecl decl
		End If

		If (decl.attrs & FUNC_PTR) And (decl.attrs & FUNC_INIT) And Not expr.InvokedWithBraces Return decl.munged
		
		If ((decl.attrs & FUNC_PTR) Or (expr.decl.attrs & FUNC_PTR)) And Not expr.InvokedWithBraces Return decl.munged
		
		If Not expr.InvokedWithBraces And expr.IsRhs Return decl.munged
		
		If decl.munged.StartsWith( "$" ) Return TransIntrinsicExpr( decl,Null,expr.args )
		
		If processingReturnStatement = 1 Then
			If decl Then
				processingReturnStatement :+ 1
				Return CreateLocal(expr)
			End If
		Else
			If decl Return TransFunc( TFuncDecl(decl),expr.args,Null )
		End If
		
		InternalErr
	End Method
	
	Method TransInvokeMemberExpr$( expr:TInvokeMemberExpr )
		Local decl:TFuncDecl=TFuncDecl( expr.decl.actual ),t$

		If decl.munged.StartsWith( "$" ) Return TransIntrinsicExpr( decl,expr.expr,expr.args )
		
		If processingReturnStatement = 1 Then
			If decl Then
				processingReturnStatement :+ 1
				Return CreateLocal(expr)
			End If
		Else
			If decl Return TransFunc( TFuncDecl(decl),expr.args,expr.expr )	
		End If
		
		InternalErr
	End Method
	
	Method TransInvokeSuperExpr$( expr:TInvokeSuperExpr )
		Local decl:TFuncDecl=TFuncDecl( expr.origFuncDecl.actual ),t$

		If decl.munged.StartsWith( "$" ) Return TransIntrinsicExpr( decl,expr )
		
		If processingReturnStatement = 1 Then
			If decl Then
				processingReturnStatement :+ 1
				Return CreateLocal(expr)
			End If
		Else
			If decl Return TransSuperFunc( TFuncDecl( expr.funcDecl ),expr.args, expr.classScope )
		End If
		
		InternalErr
	End Method
	
	Method TransFuncCallExpr:String( expr:TFuncCallExpr )

		If TIndexExpr(expr.expr) And TArrayType(TIndexExpr(expr.expr).expr.exprType) And TFunctionPtrType(TArrayType(TIndexExpr(expr.expr).expr.exprType).elemType) Then
			Local decl:TDecl = TFunctionPtrType(TArrayType(TIndexExpr(expr.expr).expr.exprType).elemType).func.actual
			decl.Semant()
			expr.args=expr.CastArgs( expr.args,TFuncDecl(decl) )
			Return expr.expr.Trans() + TransArgs(expr.args, TFuncDecl(decl))
		End If

		' hmmm, complicated - a function returning and invoking a function pointer...		
		If TInvokeExpr(expr.expr) And TFunctionPtrType(TInvokeExpr(expr.expr).exprType) Then
			Local decl:TDecl = TFunctionPtrType(TInvokeExpr(expr.expr).exprType).func.actual
			decl.Semant()
			expr.args=expr.CastArgs( expr.args,TFuncDecl(decl) )
			Return expr.expr.Trans() + TransArgs(expr.args, TFuncDecl(decl))
		End If
		
		InternalErr
	End Method
	
	Method TransExprStmt$( stmt:TExprStmt )
		Return stmt.expr.TransStmt()
	End Method
	
	Method TransAssignStmt$( stmt:TAssignStmt )
		If stmt.rhs Return stmt.lhs.TransVar()+TransAssignOp(stmt.op)+stmt.rhs.Trans()
		Return stmt.lhs.Trans()
	End Method
	
	Method TransReturnStmt$( stmt:TReturnStmt )

		Local t$="return"
		unreachable=True
		If stmt.expr Then

			If TObjectType(stmt.expr.exprType) And TNullDecl(TObjectType(stmt.expr.exprType).classDecl) Then
				If IsPointerType(stmt.fRetType, 0, TType.T_POINTER) Or IsNumericType(stmt.fRetType) Then
					t:+ " 0"
				End If
				If TStringType(stmt.fRetType) Then
					t:+ " &bbEmptyString"
				End If
				If TArrayType(stmt.fRetType) Then
					t:+ " &bbEmptyArray"
				End If

			Else
				
				If TSelfExpr(stmt.expr) And TObjectType(TSelfExpr(stmt.expr).exprType).classDecl And TObjectType(TSelfExpr(stmt.expr).exprType).classDecl.IsStruct() Then
					t :+ Bra("*" + stmt.expr.Trans())
				Else If TObjectType(stmt.expr.exprType) And TObjectType(stmt.expr.exprType).classDecl.IsStruct() And TConstExpr(stmt.expr) And Not TConstExpr(stmt.expr).value Then
					Local lvar:String = CreateLocal(stmt.expr)
					t :+ " " + lvar
				Else
					Local s:String = stmt.expr.Trans()
					
					' we have some temp variables that need to be freed before we can return
					' put the results into a new variable, and return that.
					If customVarStack.Count() > 0 Then
						If Not TFunctionPtrType( stmt.expr.exprType ) Then
							Emit TransType(stmt.expr.exprType, "rt_") + " rt_ = " + s + ";"
						Else
							Emit TransType(stmt.expr.exprType, "rt_") + " = " + s + ";"
						End If
						t:+ " rt_"
					Else
						t:+" " + s
					End If
				End If
			End If
			
		End If

		FreeVarsIfRequired()
		
		' if this is a Delete() method, we need to call the dtor first
		Local funcScope:TFuncDecl = _env.FuncScope()
		If funcScope And funcScope.IdentLower() = "delete" Then
			Local classScope:TClassDecl = funcScope.ClassScope()
			If classScope Then
				EmitClassDeclDeleteDtor(classScope)
			End If
		End If
		
		Return t
	End Method
	
	Method NextExitId:Int(bc:TTryBreakCheck)
		If Not bc.exitId Then
			exitLabelId :+ 1
			bc.exitId = exitLabelId
		End If
		
		Return bc.exitId
	End Method

	Method NextContId:Int(bc:TTryBreakCheck)
		If Not bc.contId Then
			contLabelId :+ 1
			bc.contId = contLabelId
		End If
		
		Return bc.contId
	End Method

	Method TransContinueStmt$( stmt:TContinueStmt )
		unreachable=True

		Local contLoop:TStmt
		' if we are continuing with a loop label, we'll need to find it in the stack
		If stmt.label And TLoopLabelExpr(stmt.label) Then
			contLoop = TLoopLabelExpr(stmt.label).loop
		End If
		' get count of Try statements in the stack in this loop
		Local count:Int = LoopTryDepth(contLoop)
		If count > 0 Then
			Local bc:TTryBreakCheck = GetTopLoop(contLoop)
			If bc Then
				NextContId(bc)
				For Local i:Int = 0 Until count
					Emit "bbExLeave();"
					If opt_debug Then
						Emit "bbOnDebugPopExState();"
					End If
				Next
				Emit "goto " + TransLabelCont(bc, False)
			Else
				InternalErr
			End If
		Else
		 	' For debug builds, we need to rollback the local scope stack correctly
			count = 0
			
			If opt_debug And TLoopStmt(contLoop) And Not TLoopStmt(contLoop).block.IsNoDebug() Then
				count = LoopLocalScopeDepth(contLoop)
			End If
			
			If count > 0 Then
				Local bc:TTryBreakCheck = GetTopLocalLoop(contLoop)
				If bc Then
					NextContId(bc)
					For Local i:Int = 0 Until count
						Emit "bbOnDebugLeaveScope();"
					Next
					Emit "goto " + TransLabelCont(bc, False)
				Else
					InternalErr
				End If
			Else

				If opt_debug And stmt.loop And Not stmt.loop.block.IsNoDebug() Then
					count = LoopLocalScopeDepth(Null)
				End If
				For Local i:Int = 0 Until count
					Emit "bbOnDebugLeaveScope();"
				Next

				' No Try statements in the stack here..
				If stmt.label And TLoopLabelExpr(stmt.label) Then
					Emit "goto " + TransLoopLabelCont(TLoopLabelExpr(stmt.label).loop.loopLabel.realIdent, False)
				Else
					Return "continue"
				End If
			End If
		End If
	End Method
	
	Method TransBreakStmt$( stmt:TBreakStmt )
		unreachable=True
		broken:+1

		Local brkLoop:TStmt
		' if we are exiting with a loop label, we'll need to find it in the stack
		If stmt.label And TLoopLabelExpr(stmt.label) Then
			brkLoop = TLoopLabelExpr(stmt.label).loop
		End If
		' get count of Try statements in the stack in this loop
		Local count:Int = LoopTryDepth(brkLoop)
		If count > 0 Then
			Local bc:TTryBreakCheck = GetTopLoop(brkLoop)
			If bc Then
				NextExitId(bc)
				For Local i:Int = 0 Until count
					Emit "bbExLeave();"
					If opt_debug Then
						Emit "bbOnDebugPopExState();"
					End If
				Next
				Emit "goto " + TransLabelExit(bc, False)
			Else
				InternalErr
			End If
		Else
		 	' For debug builds, we need to rollback the local scope stack correctly
			count = 0
			
			If opt_debug And TLoopStmt(brkLoop) And Not TLoopStmt(brkLoop).block.IsNoDebug() Then
				count = LoopLocalScopeDepth(brkLoop)
			End If
			
			If count > 0 Then
				Local bc:TTryBreakCheck = GetTopLocalLoop(brkLoop)
				If bc Then
					NextExitId(bc)
					For Local i:Int = 0 Until count
						Emit "bbOnDebugLeaveScope();"
					Next
					Emit "goto " + TransLabelExit(bc, False)
				Else
					InternalErr
				End If
			Else

				If opt_debug And stmt.loop And Not stmt.loop.block.IsNoDebug() Then
					count = LoopLocalScopeDepth(Null)
				End If
				For Local i:Int = 0 Until count
					Emit "bbOnDebugLeaveScope();"
				Next
				
				' No Try statements in the stack here..
				If stmt.label And TLoopLabelExpr(stmt.label) Then
					Emit "goto " + TransLoopLabelExit(TLoopLabelExpr(stmt.label).loop.loopLabel.realIdent, False)
				Else
					Return "break"
				End If
			End If
		End If
	End Method
	
	Method TransTryStmt$( stmt:TTryStmt )
	End Method
	
	Method EmitTryStack() Abstract

	Method TransThrowStmt$( stmt:TThrowStmt )
	End Method
	

	Method TransBuiltinExpr$( expr:TBuiltinExpr )
		If TMinExpr(expr) Return TransMinExpr(TMinExpr(expr))
		If TMaxExpr(expr) Return TransMaxExpr(TMaxExpr(expr))
		If TAbsExpr(expr) Return TransAbsExpr(TAbsExpr(expr))
		If TAscExpr(expr) Return TransAscExpr(TAscExpr(expr))
		If TChrExpr(expr) Return TransChrExpr(TChrExpr(expr))
		If TSgnExpr(expr) Return TransSgnExpr(TSgnExpr(expr))
		If TLenExpr(expr) Return TransLenExpr(TLenExpr(expr))
		If TSizeOfExpr(expr) Return TransSizeOfExpr(TSizeOfExpr(expr))
		Err "TODO : TransBuiltinExpr()"
	End Method
	
	Method TransMinExpr:String(expr:TMinExpr)
	End Method

	Method TransMaxExpr:String(expr:TMaxExpr)
	End Method

	Method TransAbsExpr:String(expr:TAbsExpr)
	End Method

	Method TransAscExpr:String(expr:TAscExpr)
	End Method

	Method TransChrExpr:String(expr:TChrExpr)
	End Method

	Method TransSgnExpr:String(expr:TSgnExpr)
	End Method

	Method TransLenExpr:String(expr:TLenExpr)
	End Method

	Method TransSizeOfExpr:String(expr:TSizeOfExpr)
	End Method
	
	Method TransIdentTypeExpr:String(expr:TIdentTypeExpr) Abstract
	
	Method TransLabelCont:String(bc:TTryBreakCheck, jmp:Int = True)
		If jmp Then
			Return "_contjmp" + bc.contId + ": ;"
		Else
			Return "_contjmp" + bc.contId + ";"
		End If
	End Method
	
	Method TransLabelExit:String(bc:TTryBreakCheck, jmp:Int = True)
		If jmp Then
			Return "_exitjmp" + bc.exitId + ": ;"
		Else
			Return "_exitjmp" + bc.exitId + ";"
		End If
	End Method

	Method TransLoopLabelCont:String(id:String, jmp:Int = True)
		If jmp Then
			Return "_loopcont_" + id.ToLower() + ": ;"
		Else
			Return "_loopcont_" + id.ToLower() + ";"
		End If
	End Method

	Method TransLoopLabelExit:String(id:String, jmp:Int = True)
		If jmp Then
			Return "_loopexit_" + id.ToLower() + ": ;"
		Else
			Return "_loopexit_" + id.ToLower() + ";"
		End If
	End Method

	'***** Block statements - all very C like! *****
	
	Method Emit( t$, useIndent:Int = True )
		If Not t Return
		If useIndent
			If t.StartsWith( "}" )
				indent=indent[..indent.Length-1]
			EndIf
		End If
		LINES.AddLast indent+t
		'code+=indent+t+"~n"
		If useIndent
			If t.EndsWith( "{" )
				indent:+"~t"
			EndIf
		End If
	End Method
	
	Method JoinLines$( file:String )
		Local _lines:TStringList = TStringList(outputFiles.ValueForKey(file))
		
		Local code$=_lines.Join( "~n" )
		_lines.Clear
		Return code
	End Method
	
	'returns unreachable status!
	Method EmitBlock:Int( block:TBlockDecl )
		Local stmtCount:Int
'DebugStop
		'If ENV_CONFIG="debug"
		'	If TFuncDecl( block ) EmitPushErr
		'EndIf


		PushEnv block
		
		' enter scope
		If opt_debug And Not block.IsNoDebug() And Not block.generated Then
			PushLoopLocalStack(block)
			EmitDebugEnterScope(block)
		End If

		For Local stmt:TStmt=EachIn block.stmts
		
			_errInfo=stmt.errInfo
			
			If unreachable
				' Statements following cannot be reached - maybe we have Returned, etc
				' So don't process any more for this block - they won't be generated now!
				Exit
			EndIf

Rem
			If ENV_CONFIG="debug"
				Local rs:TReturnStmt=TReturnStmt( stmt )
				If rs
					If rs.expr
						EmitSetErr stmt.errInfo
						Local t_expr$=TransExprNS( rs.expr )
						EmitPopErr
						Emit "return "+t_expr+";"
					Else
						EmitPopErr
						Emit "return;"
					EndIf
					unreachable=True
					Continue
				EndIf
				EmitSetErr stmt.errInfo
			EndIf
End Rem
			If opt_debug And Not block.IsNoDebug() Then
				' only for user-made code
				If Not stmt.generated Then
					EmitDebugStmtErrInfo(stmt.errInfo, stmtCount)
					stmtCount :+ 1
				End If
			
			End If

			EmitGDBDebug(stmt)
			
			If TReturnStmt(stmt) And Not tryStack.IsEmpty() Then
				processingReturnStatement = True
			End If
			
			Local t$=stmt.Trans()
			
			processingReturnStatement = False
			
			If opt_debug And Not block.IsNoDebug() Then
				If TReturnStmt(stmt) Then
					For Local b:TBlockDecl = EachIn localScope
						Emit "bbOnDebugLeaveScope();"
					Next
				End If
			End If

			If TReturnStmt(stmt) Then
				EmitTryStack()
			End If
			
			If t Emit t+";"

			If DEBUG And debugOut Then
				Emit debugOut
				debugOut = Null
			End If
			
			Local v:String = String(customVarStack.Pop())
			While v
				Emit "bbMemFree" + Bra(v) + ";"
				v = String(customVarStack.Pop())
			Wend
			
		Next

		If opt_debug And Not block.IsNoDebug() And Not block.generated Then
			PopLoopLocalStack()
			If Not unreachable Then
				Emit "bbOnDebugLeaveScope();"
			End If
		End If

		Local r:Int=unreachable
		unreachable=False
		PopEnv
		Return r
	End Method
	
	Method TransDeclStmt$( stmt:TDeclStmt, declare:Int = False )
		Local decl:TLocalDecl=TLocalDecl( stmt.decl )
		If decl
			MungDecl decl
			' only generate local declarations once.
			If decl.generated Then
				If Not decl.done Then
					decl.done = True
				Else
					Return ""
				End If
			End If
			Return TransLocalDecl( decl,decl.init, decl.generated Or declare )
		EndIf
		Local cdecl:TConstDecl=TConstDecl( stmt.decl )
		If cdecl
			Return Null
		EndIf
		Local gdecl:TGlobalDecl=TGlobalDecl( stmt.decl )
		If gdecl Then
			MungDecl gdecl
			If gdecl.inited Return Null
			Return TransGlobalDecl( gdecl )
		End If
		InternalErr
	End Method
	
	Method TransIfStmt$( stmt:TIfStmt )
		If TConstExpr( stmt.expr )
			If TConstExpr( stmt.expr ).value
				Emit "{"
				EmitLocalDeclarations(stmt.thenBlock)
				If EmitBlock( stmt.thenBlock ) unreachable=True
				Emit "}"
			Else If stmt.elseBlock.stmts.First()
				Emit "{"
				EmitLocalDeclarations(stmt.elseBlock)
				If EmitBlock( stmt.elseBlock ) unreachable=True
				Emit "}"
			EndIf
		Else If stmt.elseBlock.stmts.First()
			Emit "if"+Bra( stmt.expr.Trans() )+"{"
			EmitLocalDeclarations(stmt.thenBlock)
			FreeVarsIfRequired(False)
			PushVarScope
			Local unr:Int=EmitBlock( stmt.thenBlock )
			PopVarScope
			Emit "}else{"
			EmitLocalDeclarations(stmt.elseBlock)
			FreeVarsIfRequired
			Local unr2:Int=EmitBlock( stmt.elseBlock )
			Emit "}"
			If unr And unr2 unreachable=True
		Else

'			Emit "if"+ Bra(TransCondition(stmt.expr)) + "{"
'			If TVarExpr(stmt.expr) Then
'				If TObjectType(TVarExpr(stmt.expr).exprType) Then
'					Emit "if"+Bra( stmt.expr.Trans() + "!= &bbNullObject") + "{"
'				Else If TStringType(TVarExpr(stmt.expr).exprType)  Then
'					Emit "if"+Bra( stmt.expr.Trans() + "!= &bbEmptyString") + "{"
'				Else
'					Emit "if"+Bra( stmt.expr.Trans() )+"{"
'				End If
'			Else
				Emit "if"+Bra( stmt.expr.Trans() )+"{"
				FreeVarsIfRequired(False)
'			End If
			EmitLocalDeclarations(stmt.thenBlock)
			PushVarScope
			Local unr:Int=EmitBlock( stmt.thenBlock )
			PopVarScope
			Emit "}"
			FreeVarsIfRequired
		EndIf
	End Method
	
	Method FreeVarsIfRequired(removeFromStack:Int = True)
		If removeFromStack
			Local v:String = String(customVarStack.Pop())
			While v
				Emit "bbMemFree" + Bra(v) + ";"
				v = String(customVarStack.Pop())
			Wend
		Else
			For Local v:String = EachIn customVarStack
				Emit "bbMemFree" + Bra(v) + ";"
			Next
		End If
	End Method
	
'	Method TransCondition:String(expr:TExpr)
'		If TVarExpr(expr) Then
'			If TObjectType(TVarExpr(expr).exprType) Then
'				Return Bra( expr.Trans() + "!= &bbNullObject")
'			Else If TStringType(TVarExpr(expr).exprType)  Then
'				Return Bra( expr.Trans() + "!= &bbEmptyString")
'			Else
'				Return Bra( expr.Trans() )
'			End If
'		Else
'			Return Bra( expr.Trans() )
'		End If
'	End Method
	
	Method TransWhileStmt$( stmt:TWhileStmt )
		Local nbroken:Int=broken

		Emit "while"+Bra( stmt.expr.Trans() )+"{"
		
		Local check:TTryBreakCheck = New TTryBreakCheck
		check.stmt = stmt
		PushLoopTryStack(check)
		If opt_debug And Not stmt.block.IsNoDebug() And Not stmt.block.generated Then
			PushLoopLocalStack(check)
		End If
		EmitLocalDeclarations(stmt.block)
		Local unr:Int=EmitBlock( stmt.block )
		If opt_debug And Not stmt.block.IsNoDebug() And Not stmt.block.generated Then
			PopLoopLocalStack
		End If
		PopLoopTryStack
		
		If check.contId Then
			Emit TransLabelCont(check)
		End If

		If stmt.loopLabel Then
			Emit TransLoopLabelCont(stmt.loopLabel.realIdent, True)
		End If
		
		Emit "}"

		If check.exitId Then
			Emit TransLabelExit(check)
		End If

		If stmt.loopLabel Then
			Emit TransLoopLabelExit(stmt.loopLabel.realIdent, True)
		End If
		
		If broken=nbroken And TConstExpr( stmt.expr ) And TConstExpr( stmt.expr ).value unreachable=True
		broken=nbroken
	End Method

	Method TransRepeatStmt$( stmt:TRepeatStmt )
		Local nbroken:Int=broken

		SetOutputTemp()

		Emit "do{"
		
		Local check:TTryBreakCheck = New TTryBreakCheck
		check.stmt = stmt
		PushLoopTryStack(check)
		If opt_debug And Not stmt.block.IsNoDebug() And Not stmt.block.generated Then
			PushLoopLocalStack(check)
		End If
		EmitLocalDeclarations(stmt.block)
		Local unr:Int=EmitBlock( stmt.block )
		If opt_debug And Not stmt.block.IsNoDebug() And Not stmt.block.generated Then
			PopLoopLocalStack
		End If
		PopLoopTryStack

		If check.contId Then
			Emit TransLabelCont(check)
		End If

		If stmt.loopLabel Then
			Emit TransLoopLabelCont(stmt.loopLabel.realIdent, True)
		End If
		
		SetOutput("source")

		Local s:String = "}while(!"+Bra( stmt.expr.Trans() )+");"
		
		SetOutputTemp(True)
		
		Emit s

		If check.exitId Then
			Emit TransLabelExit(check)
		End If

		If stmt.loopLabel Then
			Emit TransLoopLabelExit(stmt.loopLabel.realIdent, True)
		End If

		If broken=nbroken And TConstExpr( stmt.expr ) And Not TConstExpr( stmt.expr ).value unreachable=True
		broken=nbroken
	End Method

	Method TransForStmt$( stmt:TForStmt )
		Local nbroken:Int=broken

		Local init$

		Local decl:Int
		Local vdecl:TValDecl
		If TDeclStmt(stmt.init) Then
			decl = True
			Emit "{"
			Emit TransDeclStmt(TDeclStmt(stmt.init), True) + ";"
			init = TDeclStmt(stmt.init).decl.munged
			vdecl = TValDecl(TDeclStmt(stmt.init).decl)
		Else
			init=stmt.init.Trans()
		End If
		Local expr$=stmt.expr.Trans()
		Local incr$=stmt.incr.Trans()

		Emit "for("+init+";"+expr+";"+incr+"){"

		Local check:TTryBreakCheck = New TTryBreakCheck
		check.stmt = stmt
		PushLoopTryStack(check)
		If opt_debug And Not stmt.block.IsNoDebug() And Not stmt.block.generated Then
			PushLoopLocalStack(check)
		End If
		EmitLocalDeclarations(stmt.block, vdecl)
		Local unr:Int=EmitBlock( stmt.block )
		If opt_debug And Not stmt.block.IsNoDebug() And Not stmt.block.generated Then
			PopLoopLocalStack
		End If
		PopLoopTryStack
		
		If check.contId Then
			Emit TransLabelCont(check)
		End If

		If stmt.loopLabel Then
			Emit TransLoopLabelCont(stmt.loopLabel.realIdent, True)
		End If
		
		Emit "}"
		
		If decl Then
			Emit "}"
		End If

		If check.exitId Then
			Emit TransLabelExit(check)
		End If

		If stmt.loopLabel Then
			Emit TransLoopLabelExit(stmt.loopLabel.realIdent, True)
		End If
		
		If broken=nbroken And TConstExpr( stmt.expr ) And TConstExpr( stmt.expr ).value unreachable=True
		broken=nbroken
	End Method

	Method TransAssertStmt$( stmt:TAssertStmt ) Abstract

	Method TransEndStmt$( stmt:TEndStmt ) Abstract

	Method TransReleaseStmt$( stmt:TReleaseStmt ) Abstract

	Method TransRestoreDataStmt$( stmt:TRestoreDataStmt ) Abstract

	Method TransReadDataStmt$( stmt:TReadDataStmt ) Abstract
	
	Method TransNativeStmt$( stmt:TNativeStmt) Abstract

	'module
	Method TransApp( app:TAppDecl ) Abstract

Rem	
	Method MungOverrides( cdecl:TClassDecl )
		For Local decl:=Eachin cdecl.Semanted
			Local fdecl:=TFuncDecl( decl )
			If fdecl And fdecl.overrides
				If Not fdecl.overrides.munged InternalErr
				fdecl.munged=fdecl.overrides.munged
				mungScope.Insert fdecl.munged,fdecl
			Endif
		Next
	End
End Rem
	
	Method PostProcess$( source$ ) 
		Return source
	End Method
	
	Method SetOutput( file:String )
		Local _lines:TStringList = TStringList(outputFiles.ValueForKey(file))
		
		If Not _lines Then
			_lines = New TStringList
			outputFiles.Insert(file, _lines)
		End If
		
		LINES = _lines
		
	End Method

	Method SetOutputTemp( fin:Int = False )
		Global tmpLevel:Int = 0
	
		If Not fin Then
			tmpLevel :+ 1

			Local _lines:TStringList = New TStringList
			outputFiles.Insert("tmp" + tmpLevel, _lines)
	
			LINES = _lines
		Else
			Local _lines:TStringList = TStringList(outputFiles.ValueForKey("tmp" + tmpLevel))
			
			tmpLevel :- 1
		
			If Not tmpLevel Then
				SetOutput("source")
			Else
				LINES = TStringList(outputFiles.ValueForKey("tmp" + tmpLevel))
			End If
			
			If _lines Then
				For Local line:String = EachIn _lines
					LINES.AddLast(line)
				Next
			End If
			
		End If
	End Method

	Method DebugPrint(text:String, func:String = Null, trans:Int = False)
		Global count:Int
		Global lastFunc:String
		
		If func Then
			lastFunc = func
		End If
		
		Local s:String = "fprintf(stderr," + "~q" + lastFunc + " : " + count + " :: " + text + "\n~q)" + ";fflush(stderr);"
		
		If trans Then
			debugOut :+ indent + s + "~n"
		Else
			Emit s
		End If
		count :+ 1
	End Method
	
	Method DebugString(s:String, func:String = Null, trans:Int = False)
		' bbNullObject test
		If trans Then
			debugOut :+ indent + "if (" + s + "==&bbNullObject) {~n"
		Else
			Emit "if (" + s + "==&bbNullObject) {"
		End If
		DebugPrint("Invalid Null String : " + s, func, trans)
		If trans Then
			debugOut :+ indent + "}~n"
		Else
			Emit "}"
		End If
	End Method

	Method DebugArray(s:String, func:String = Null, trans:Int = False)
		' bbNullObject test
		If trans Then
			debugOut :+ indent + "if (" + s + "==&bbNullObject) {~n"
		Else
			Emit "if (" + s + "==&bbNullObject) {"
		End If
		DebugPrint("Invalid Null Array : " + s, func, trans)
		If trans Then
			debugOut :+ indent + "}~n"
		Else
			Emit "}"
		End If
	End Method

	Method DebugObject(ty:TType, id:String, func:String = Null, trans:Int = False)
		If TObjectType(ty) Or TStringType(ty) Or TArrayType(ty) Then
			' null test
			If trans Then
				debugOut :+ indent + "if (" + id + "==NULL) {~n"
			Else
				Emit "if (" + id + "==NULL) {"
			End If
			DebugPrint("Null Pointer : " + id, func, trans)
			If trans Then
				If ABORT_ON_NULL Then
					debugOut :+ indent + "abort();~n"
				End If
				debugOut :+ indent + "}~n"
			Else
				If ABORT_ON_NULL Then
					Emit "abort();~n"
				End If
				Emit "}"
			End If
		End If
		
		If TStringType(ty) Then
			DebugString(id, func, trans)
		Else If TArrayType(ty) Then
			DebugArray(id, func, trans)
		End If
	End Method
	
	Method EmitDebugStmtErrInfo(info:String, count:Int)
		' extract from info
		info = info[1..info.length-1]
		Local infoArray:String[] = info.Split(";")

		Local dbg:String = "struct BBDebugStm __stmt_" + count + " = {"
		dbg :+ Enquote(infoArray[0]) + ", "
		dbg :+ infoArray[1] + ", "
		dbg :+ infoArray[2] + "};"
		Emit dbg
		Emit "bbOnDebugEnterStm(&__stmt_" + count + ");" 
	End Method
	
	Method EmitGDBDebug(obj:Object)
		If opt_gdbdebug Then
			If TStmt(obj) Then
				Local stmt:TStmt = TStmt(obj)
				Local infoArray:String[] = stmt.errInfo[1..stmt.errInfo.length-1].Split(";")
				If Not stmt.generated Then
					Emit "#line " + infoArray[1] + " " + Enquote(infoArray[0])
				End If
			Else If TDecl(obj) Then
				Local decl:TDecl = TDecl(obj)
				Local infoArray:String[] = decl.errInfo[1..decl.errInfo.length-1].Split(";")
				Emit "#line " + infoArray[1] + " " + Enquote(infoArray[0])
			Else If String(obj) Then
				Local errInfo:String = String(obj)
				Local infoArray:String[] = errInfo[1..errInfo.length-1].Split(";")
				Emit "#line " + infoArray[1] + " " + Enquote(infoArray[0])
			End If
		End If
	End Method
	
	Method EmitClassDeclDeleteDtor( classDecl:TClassDecl )
	End Method
	
End Type

Type TTryBreakCheck

	Field contId:Int
	Field exitId:Int

	Field stmt:TStmt
	
End Type
' Copyright (c) 2013-2016 Bruce A Henderson
'
' Based on the public domain Monkey "trans" by Mark Sibly
'
' This software is provided 'as-is', without any express or implied
' warranty. In no event will the authors be held liable for any damages
' arising from the use of this software.
'
' Permission is granted to anyone to use this software for any purpose,
' including commercial applications, and to alter it and redistribute it
' freely, subject to the following restrictions:
'
'    1. The origin of this software must not be misrepresented; you must not
'    claim that you wrote the original software. If you use this software
'    in a product, an acknowledgment in the product documentation would be
'    appreciated but is not required.
'
'    2. Altered source versions must be plainly marked as such, and must not be
'    misrepresented as being the original software.
'
'    3. This notice may not be removed or altered from any source
'    distribution.
'
SuperStrict

Import "config.bmx"

Include "translator.bmx"
Include "decl.bmx"
Include "expr.bmx"
Include "stmt.bmx"

Type TType

	Method ActualType:TType()
		Return Self
	End Method

	Method EqualsType:Int( ty:TType )
		Return False
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		Return EqualsType( ty )
	End Method
	
	Method WidensToType:Int( ty:TType )
		Return False
	End Method
	
	Method DistanceToType:Int(ty:TType)
		Return T_MAX_DISTANCE
	End Method
	
	Method Semant:TType(option:Int = False)
		Return Self
	End Method

	Method GetClass:TClassDecl()
		Return Null
	End Method
	
	Method ToString$()
		Return "??Type??"
	End Method
	
	Method GetSize:Int()
		Return WORD_SIZE
	End Method

	Method ArrayOf:TArrayType()
		If Not _arrayOf Then
			_arrayOf=New TArrayType.Create( Self )
		End If
		Return _arrayOf
	End Method

	Method OnCopy:TType() Abstract
	
	Global voidType:TVoidType=New TVoidType
	Global emptyArrayType:TArrayType=New TArrayType.Create( voidType )
	Global objectType:TIdentType=New TIdentType.Create( "brl.classes.object" )
	Global nullObjectType:TNullType=New TNullType
	Global stringType:TStringType=New TStringType

	Rem
	bbdoc: map to a pointer type
	End Rem
	Function MapToPointerType:TType(ty:TType)
		If ty = stringType Then
			ty = ty.Copy()
		End If
		
		Local flag:Int = T_POINTER & ty._flags
		
		If flag & T_PTR Then
			ty._flags :~ T_PTR
			ty._flags :| T_PTRPTR
			Return ty
		End If

		If flag & T_PTRPTR Then
			ty._flags :~ T_PTRPTR
			ty._flags :| T_PTRPTRPTR
			Return ty
		End If

		ty._flags :| T_PTR
		Return ty
		
	End Function

	Function MapToVarType:TType(ty:TType)
		If ty = stringType Then
			ty = ty.Copy()
		End If
		
		If Not (ty._flags & T_VAR) Then
			ty._flags :| T_VAR
			Return ty
		End If
		
		' TODO : error if already mapped?
		
		Return ty
	End Function

	Rem
	bbdoc: map to a var pointer type
	End Rem
	Function MapToVarPointerType:TType(ty:TType)
		If ty = stringType Then
			ty = ty.Copy()
		End If

		If Not (ty._flags & T_VARPTR) Then
			ty._flags :| T_VARPTR
			Return ty
		End If

		Return Null
	End Function

	Rem
	bbdoc: map a var pointer to it's pointer equivalent (strip out var)
	End Rem
	Function MapVarPointerToPointerType:TType(ty:TType)
		If ty = stringType Then
			ty = ty.Copy()
		End If

		If (ty._flags & T_VARPTR) Then
			ty._flags :~ T_VARPTR
			
			Return MapToPointerType(ty)
		End If

		Return ty
	End Function
	
	Function MapPointerToPrim:TType(ty:TNumericType)
		Local nty:TType = ty.Copy()

		If ty._flags & T_PTRPTRPTR Then
			nty._flags :~ T_PTRPTRPTR
			nty._flags :| T_PTRPTR
		Else If ty._flags & T_PTRPTR Then
			nty._flags :~ T_PTRPTR
			nty._flags :| T_PTR
		Else If ty._flags & T_PTR Then
			nty._flags :~ T_PTR
		End If

		Return nty
	End Function

	Field _arrayOf:TArrayType
	
	' one or more of
	' T_VAR, T_VARPTR, T_PTR, T_PTRPTR, T_PTRPTRPTR
	Field _flags:Int
	
	Const T_VAR:Int = $01
	Const T_VARPTR:Int = $02
	Const T_PTR:Int = $04
	Const T_PTRPTR:Int = $08
	Const T_PTRPTRPTR:Int = $10

	' for strings
	Const T_CHAR_PTR:Int  = $1000
	Const T_SHORT_PTR:Int = $2000

	Const T_POINTER:Int = T_PTR | T_PTRPTR | T_PTRPTRPTR

	Const T_BYTE:Int        =  $001
	Const T_SHORT:Int       =  $002
	Const T_INT:Int         =  $004
	Const T_LONG:Int        =  $008
	Const T_FLOAT:Int       =  $010
	Const T_DOUBLE:Int      =  $020
	Const T_STRING:Int      =  $040
	Const T_ARRAY:Int       =  $080
	Const T_FUNCTIONPTR:Int =  $100
	Const T_SIZET:Int       =  $200
	Const T_UINT:Int        =  $400
	Const T_ULONG:Int       =  $800
	Const T_FLOAT64:Int     = $1000
	Const T_INT128:Int      = $2000
	Const T_FLOAT128:Int    = $4000
	Const T_DOUBLE128:Int   = $8000
	Const T_LPARAM:Int      =$10000
	Const T_WPARAM:Int      =$20000

	Const T_MAX_DISTANCE:Int = $FFFF

	Method Copy:TType()
		Local ty:TType = OnCopy()
		ty._flags = _flags
		ty._arrayOf = _arrayOf
		Return ty
	End Method
	
	Method ToStringParts:String()
		Local s:String

		If _flags & T_PTR Then
			s:+ " Ptr"
		Else If _flags & T_PTRPTR Then
			s:+ " Ptr Ptr"
		Else If _flags & T_PTRPTRPTR Then
			s:+ " Ptr Ptr Ptr"
		End If

		If _flags & T_VAR Then
			s:+ " Var"
		End If
		
		Return s
	End Method
	
End Type

Function NewType:TType(kind:Int = 0)
	Local ty:TType
	
	Select kind
		Case TType.T_BYTE
			ty = New TByteType
		Case TType.T_SHORT
			ty = New TShortType
		Case TType.T_INT
			ty = New TIntType
		Case TType.T_UINT
			ty = New TUIntType
		Case TType.T_LONG
			ty = New TLongType
		Case TType.T_ULONG
			ty = New TULongType
		Case TType.T_SIZET
			ty = New TSizeTType
		Case TType.T_INT128
			ty = New TInt128Type
		Case TType.T_FLOAT
			ty = New TFloatType
		Case TType.T_DOUBLE
			ty = New TDoubleType
		Case TType.T_FLOAT64
			ty = New TFloat64Type
		Case TType.T_FLOAT128
			ty = New TFloat128Type
		Case TType.T_DOUBLE128
			ty = New TDouble128Type
		Case TType.T_STRING
			ty = New TStringType
		Case TType.T_ARRAY
			ty = New TArrayType
		Case TType.T_FUNCTIONPTR
			ty = New TFunctionPtrType
		Default
			Err "Don't have a pointer type for " + kind
	End Select

	Return ty
End Function

Function NewPointerType:TType(kind:Int = 0)
	Local ty:TType = NewType(kind)

	Return TType.MapToPointerType(ty)
End Function

Function IsPointerType:Int(ty:TType, kind:Int = 0, pType:Int = TType.T_PTR)
' TODO : 
	If kind Then
		If IsType(ty, kind) Then
			Return ty._flags & pType
		Else
			Return False
		End If
	Else
		Return ty._flags & pType
	End If
	
End Function

Function IsNumericType:Int(ty:TType)
	Return (TNumericType(ty) <> Null) And Not IsPointerType(ty, 0, TType.T_POINTER)
End Function

Function IsType:Int(ty:TType, kind:Int)
	Select kind
		Case TType.T_BYTE
			Return TByteType(ty) <> Null
		Case TType.T_SHORT
			Return TShortType(ty) <> Null
		Case TType.T_INT
			Return TIntType(ty) <> Null
		Case TType.T_UINT
			Return TUIntType(ty) <> Null
		Case TType.T_LONG
			Return TLongType(ty) <> Null
		Case TType.T_ULONG
			Return TULongType(ty) <> Null
		Case TType.T_SIZET
			Return TSizeTType(ty) <> Null
		Case TType.T_INT128
			Return TInt128Type(ty) <> Null
		Case TType.T_FLOAT
			Return TFloatType(ty) <> Null
		Case TType.T_DOUBLE
			Return TDoubleType(ty) <> Null
		Case TType.T_FLOAT64
			Return TFloat64Type(ty) <> Null
		Case TType.T_FLOAT128
			Return TFloat128Type(ty) <> Null
		Case TType.T_DOUBLE128
			Return TDouble128Type(ty) <> Null
		Case TType.T_STRING
			Return TStringType(ty) <> Null
		Case TType.T_ARRAY
			Return TArrayType(ty) <> Null
		Case TType.T_FUNCTIONPTR
			Return TFunctionPtrType(ty) <> Null
	End Select

	Return False
End Function

Type TVoidType Extends TType

	Method EqualsType:Int( ty:TType )
		If opt_issuperstrict Then
			Return TVoidType( ty )<>Null
		Else
			Return TVoidType( ty )<>Null Or TIntType( ty) <> Null
		End If
	End Method
	
	Method ToString$()
		Return "Void"
	End Method

	Method OnCopy:TType()
		Return New TVoidType
	End Method

End Type

Type TNullType Extends TType

	Method EqualsType:Int( ty:TType )
		Return False
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		Return True
	End Method
	
	Method ToString$()
		Return "NULL"
	End Method

	Method OnCopy:TType()
		Return New TNullType
	End Method

End Type

Type TBoolType Extends TType

	Method EqualsType:Int( ty:TType )
		Return TBoolType( ty )<>Null
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or TBoolType( ty )<>Null Or (Not noExtendString And TStringType( ty )<>Null)
	End Method

	Method WidensToType:Int( ty:TType )
		Return IsNumericType(ty)
	End Method
	
	Method ToString$()
		Return "Bool"
	End Method

	Method GetSize:Int()
		Return 4
	End Method

	Method OnCopy:TType()
		Return New TBoolType
	End Method

End Type

Type TNumericType Extends TType

	Method ToPointer:TType()
		Local ty:TType = Copy()
		Return MapToPointerType(ty)
	End Method
	
End Type

Type TIntegralType Extends TNumericType
End Type

Type TIntType Extends TIntegralType
	
	Method EqualsType:Int( ty:TType )
		Return TIntType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True,,,,SCOPE_CLASS_HEIRARCHY )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TIntType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) Or (WORD_SIZE=4 And TLParamType(ty)<>Null)
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TIntType(ty)<>Null And (ty._flags & T_VAR)) Or TLongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or (WORD_SIZE=8 And TLParamType(ty)<>Null)
	End Method
	
	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TIntType(ty)<>Null Then
			Return 0
		End If
		
		If WORD_SIZE = 4 And TLParamType(ty)<>Null Then
			Return 0
		End If
		
		If TLongType(ty)<>Null Then
			Return 2
		End If

		If WORD_SIZE = 8 And TLParamType(ty)<>Null Then
			Return 2
		End If
		
		If TFloatType(ty)<>Null Then
			Return 4
		End If

		If TDoubleType(ty)<>Null Then
			Return 6
		End If
		
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TIntType
	End Method

	Method ToString$()
		Return "Int" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return 4
	End Method

End Type

Type TUIntType Extends TIntegralType
	
	Method EqualsType:Int( ty:TType )
		Return TUIntType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TUIntType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) Or (WORD_SIZE=4 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null))
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TUIntType(ty)<>Null And (ty._flags & T_VAR)) Or TIntType(ty)<> Null Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or (WORD_SIZE=8 And TWParamType(ty)<>Null)
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If WORD_SIZE = 4 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 0
		End If
		
		If TUIntType(ty)<>Null Then
			Return 0
		End If

		If TIntType(ty)<>Null Then
			Return 1
		End If
		
		If WORD_SIZE = 8 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 2
		End If
		
		If TULongType(ty)<>Null Then
			Return 2
		End If

		If TLongType(ty)<>Null Then
			Return 3
		End If

		If TFloatType(ty)<>Null Then
			Return 4
		End If

		If TDoubleType(ty)<>Null Then
			Return 6
		End If
		
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TUIntType
	End Method

	Method ToString$()
		Return "UInt" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return 4
	End Method

End Type

Type TSizeTType Extends TIntegralType
	
	Method EqualsType:Int( ty:TType )
		Return TSizeTType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TSizeTType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) Or (WORD_SIZE=4 And TUIntType(ty)<>Null) Or (WORD_SIZE=8 And TULongType(ty)<>Null)
	End Method

	Method WidensToType:Int( ty:TType )
		If WORD_SIZE = 4 Then
			Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or ((TSizeTType(ty)<>Null Or TUIntType(ty)<>Null) And (ty._flags & T_VAR)) Or TIntType(ty)<>Null Or TUIntType(ty)<>Null Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TWParamType(ty)<>Null Or TLParamType(ty)<>Null
		Else
			Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or ((TSizeTType(ty)<>Null Or TULongType(ty)<>Null) And (ty._flags & T_VAR)) Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TFloat64Type(ty)<>Null Or TWParamType(ty)<>Null Or TLParamType(ty)<>Null
		End If
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TSizeTType(ty)<>Null Then
			Return 0
		End If

		If TWParamType(ty)<>Null Then
			Return 0
		End If

		If WORD_SIZE = 4 Then
			If TUIntType(ty)<>Null Then
				Return 0
			End If

			If TIntType(ty)<>Null Then
				Return 2
			End If
			
			If TLParamType(ty)<>Null Then
				Return 2
			End If

			If TULongType(ty)<>Null Then
				Return 3
			End If

			If TLongType(ty)<>Null Then
				Return 4
			End If

			If TFloatType(ty)<>Null Then
				Return 5
			End If
	
			If TDoubleType(ty)<>Null Then
				Return 6
			End If
			
		Else
			If TULongType(ty)<>Null Then
				Return 0
			End If

			If TLongType(ty)<>Null Then
				Return 2
			End If

			If TLParamType(ty)<>Null Then
				Return 2
			End If

			If TFloatType(ty)<>Null Then
				Return 4
			End If
	
			If TDoubleType(ty)<>Null Then
				Return 6
			End If

			If TFloat64Type(ty)<>Null Then
				Return 8
			End If

		End If
	
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TSizeTType
	End Method

	Method ToString$()
		Return "size_t" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return WORD_SIZE
	End Method

End Type

Type TByteType Extends TIntegralType
	
	Method EqualsType:Int( ty:TType )
		Return TByteType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If (_flags & T_VARPTR) And (TByteType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TByteVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TByteType(ty)<>Null And (ty._flags & T_VAR)) Or TShortType(ty)<>Null Or TIntType(ty)<>Null Or TUIntType(ty)<>Null Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TWParamType(ty)<>Null Or TLParamType(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TByteType(ty)<>Null Then
			Return 0
		End If

		If TShortType(ty)<>Null Then
			Return 2
		End If

		If WORD_SIZE = 4 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 4
		End If
		
		If TUIntType(ty)<>Null Then
			Return 4
		End If

		If TIntType(ty)<>Null Then
			Return 5
		End If

		If WORD_SIZE = 4 And TLParamType(ty)<>Null Then
			Return 5
		End If
		
		If WORD_SIZE = 8 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 6
		End If
		
		If TULongType(ty)<>Null Then
			Return 6
		End If

		If TLongType(ty)<>Null Then
			Return 7
		End If

		If WORD_SIZE = 8 And TLParamType(ty)<>Null Then
			Return 7
		End If

		If TFloatType(ty)<>Null Then
			Return 8
		End If

		If TDoubleType(ty)<>Null Then
			Return 10
		End If
		
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TByteType
	End Method

	Method ToString$()
		Return "Byte" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return 1
	End Method

End Type

Type TShortType Extends TIntegralType

	Method EqualsType:Int( ty:TType )
		Return TShortType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TShortType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TShortVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TShortType(ty)<>Null And (ty._flags & T_VAR)) Or TIntType(ty)<>Null Or TUIntType(ty)<>Null Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TWParamType(ty)<>Null Or TLParamType(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TShortType(ty)<>Null Then
			Return 0
		End If

		If WORD_SIZE = 4 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 2
		End If
		
		If TUIntType(ty)<>Null Then
			Return 2
		End If

		If TIntType(ty)<>Null Then
			Return 3
		End If

		If WORD_SIZE = 4 And TLParamType(ty)<>Null Then
			Return 3
		End If
		
		If WORD_SIZE = 8 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 4
		End If

		If TULongType(ty)<>Null Then
			Return 4
		End If

		If TLongType(ty)<>Null Then
			Return 5
		End If

		If WORD_SIZE = 8 And TLParamType(ty)<>Null Then
			Return 5
		End If

		If TFloatType(ty)<>Null Then
			Return 6
		End If

		If TDoubleType(ty)<>Null Then
			Return 8
		End If
		
		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TShortType
	End Method

	Method ToString$()
		Return "Short" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return 2
	End Method

End Type

Type TLongType Extends TIntegralType ' BaH Long
	
	Method EqualsType:Int( ty:TType )
		Return TLongType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TLongType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TLongVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TLongType(ty)<>Null And (ty._flags & T_VAR)) Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TFloat64Type(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TLongType(ty)<>Null Then
			Return 0
		End If
		
		If WORD_SIZE = 8 And TLParamType(ty)<>Null Then
			Return 0
		End If

		If TFloatType(ty)<>Null Then
			Return 2
		End If

		If TDoubleType(ty)<>Null Then
			Return 4
		End If

		If TFloat64Type(ty)<>Null Then
			Return 6
		End If
		
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TLongType
	End Method

	Method ToString$()
		Return "Long" + ToStringParts()
	End Method
End Type

Type TULongType Extends TIntegralType
	
	Method EqualsType:Int( ty:TType )
		Return TULongType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TULongType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TLongVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TULongType(ty)<>Null And (ty._flags & T_VAR)) Or TDoubleType(ty)<>Null Or TFloat64Type(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TULongType(ty)<>Null Then
			Return 0
		End If

		If WORD_SIZE = 8 And (TSizeTType(ty)<>Null Or TWParamType(ty)<>Null) Then
			Return 0
		End If
		
		If TLongType(ty)<>Null Then
			Return 1
		End If

		If TFloatType(ty)<>Null Then
			Return 2
		End If

		If TDoubleType(ty)<>Null Then
			Return 4
		End If

		If TFloat64Type(ty)<>Null Then
			Return 6
		End If

		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TULongType
	End Method

	Method ToString$()
		Return "ULong" + ToStringParts()
	End Method
End Type

Type TDecimalType Extends TNumericType
End Type

Type TFloatType Extends TDecimalType
	
	Method EqualsType:Int( ty:TType )
		Return TFloatType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf	
		If _flags & T_VARPTR And (TFloatType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TFloatVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TFloatType(ty)<>Null And (ty._flags & T_VAR)) Or TDoubleType(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TFloatType(ty)<>Null Then
			Return 0
		End If

		If TDoubleType(ty)<>Null Then
			Return 2
		End If
		
		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TFloatType
	End Method
	
	Method ToString$()
		Return "Float" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return 4
	End Method

End Type

Type TDoubleType Extends TDecimalType
	
	Method EqualsType:Int( ty:TType )
		Return TDoubleType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf	
		If _flags & T_VARPTR And (TDoubleType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TDoubleVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TDoubleType(ty)<>Null And (ty._flags & T_VAR))
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TDoubleType(ty)<>Null Then
			Return 0
		End If
		
		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TDoubleType
	End Method

	Method ToString$()
		Return "Double" + ToStringParts()
	End Method

End Type

Type TIntrinsicType Extends TNumericType
End Type

Type TInt128Type Extends TIntrinsicType
	
	Method EqualsType:Int( ty:TType )
		Return TInt128Type( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf
		If _flags & T_VARPTR And (TLongType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TLongVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TInt128Type(ty)<>Null And (ty._flags & T_VAR)) Or TFloat128Type(ty)<>Null Or TDouble128Type(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TInt128Type(ty)<>Null Then
			Return 0
		End If

		If TFloat128Type(ty)<>Null Then
			Return 2
		End If

		If TDouble128Type(ty)<>Null Then
			Return 4
		End If
		
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TInt128Type
	End Method

	Method ToString$()
		Return "Int128" + ToStringParts()
	End Method
End Type

Type TFloat64Type Extends TIntrinsicType
	
	Method EqualsType:Int( ty:TType )
		Return TFloat64Type( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf	
		If _flags & T_VARPTR And (TFloat64Type(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TDoubleVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TFloat64Type(ty)<>Null And (ty._flags & T_VAR))
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TFloat64Type(ty)<>Null Then
			Return 0
		End If
		
		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TFloat64Type
	End Method

	Method ToString$()
		Return "Float64" + ToStringParts()
	End Method

End Type

Type TFloat128Type Extends TIntrinsicType
	
	Method EqualsType:Int( ty:TType )
		Return TFloat128Type( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf	
		If _flags & T_VARPTR And (TFloat128Type(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TDoubleVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TFloat128Type(ty)<>Null And (ty._flags & T_VAR)) Or TInt128Type(ty)<>Null Or TDouble128Type(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TFloat128Type(ty)<>Null Then
			Return 0
		End If

		If TDouble128Type(ty)<>Null Then
			Return 2
		End If
		
		If TInt128Type(ty)<>Null Then
			Return 4
		End If
	
		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TFloat128Type
	End Method

	Method ToString$()
		Return "Float128" + ToStringParts()
	End Method

End Type

Type TDouble128Type Extends TIntrinsicType
	
	Method EqualsType:Int( ty:TType )
		Return TDouble128Type( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		'If TObjectType( ty )
		'	Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
		'	Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True )
		'	Return ctor And ctor.IsCtor()
		'EndIf	
		If _flags & T_VARPTR And (TDouble128Type(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TDoubleVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or (TDouble128Type(ty)<>Null And (ty._flags & T_VAR)) Or TInt128Type(ty)<>Null Or TFloat128Type(ty)<>Null
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TDouble128Type(ty)<>Null Then
			Return 0
		End If

		If TFloat128Type(ty)<>Null Then
			Return 2
		End If

		If TInt128Type(ty)<>Null Then
			Return 4
		End If
		
		Return T_MAX_DISTANCE
	End Method

	Method OnCopy:TType()
		Return New TDouble128Type
	End Method

	Method ToString$()
		Return "Double128" + ToStringParts()
	End Method

End Type

Type TStringType Extends TType

	Field cdecl:TClassDecl

	Method EqualsType:Int( ty:TType )
		Return TStringType( ty )<>Null And (_flags = ty._flags Or (_flags & T_VAR))
	End Method

	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )	
		Return EqualsType( ty ) Or (TObjectType( ty ) And TObjectType( ty ).classDecl.ident="Object") Or (TStringType(ty) And (_flags & T_VAR)) ..
			Or (TStringType(ty) And (ty._flags & T_VAR)) Or (TStringType(ty) And (ty._flags & T_CHAR_PTR)) Or (TStringType(ty) And (ty._flags & T_SHORT_PTR)) ..
			Or IsPointerType(ty) Or (TStringType(ty) And (_flags & T_CHAR_PTR)) Or (TStringType(ty) And (_flags & T_SHORT_PTR))
	End Method

	Method GetClass:TClassDecl()
		If cdecl Return cdecl
		
		Local modid$="brl.classes"
		Local mdecl:TModuleDecl=_env.FindModuleDecl( modid )
		If Not mdecl Err "Module '"+modid+"' not found"
		'clsid=ident[i+1..] ' BaH
	'DebugStop
		cdecl=TClassDecl(mdecl.FindDecl( "string" ))

		'Return _env.FindClassDecl( "brl.classes.string" )
		Return cdecl
	End Method
	
	Method Semant:TType(option:Int = 0)
		GetClass()
		Return Self
	End Method

	Method OnCopy:TType()
		Local ty:TStringType = New TStringType
		ty.cdecl = cdecl
		If _flags & T_CHAR_PTR Then
			ty._flags :| T_CHAR_PTR
		End If
		If _flags & T_SHORT_PTR Then
			ty._flags :| T_SHORT_PTR
		End If
		Return ty
	End Method

	Method ToString$()
		Return "String" + ToStringParts()
	End Method
End Type

Type TArrayType Extends TType
	Field elemType:TType
	Field dims:Int
	
	Method Create:TArrayType( elemType:TType, dims:Int = 1 )
		Self.elemType=elemType
		Self.dims = dims
		Return Self
	End Method
	
	Method ActualType:TType()
		Local ty:TType=elemType.ActualType()
		If ty=elemType Return Self
		Return New TArrayType.Create( ty )
	End Method
		
	Method EqualsType:Int( ty:TType )
		Local arrayType:TArrayType=TArrayType( ty )
		Return arrayType And elemType.EqualsType( arrayType.elemType ) And dims = arrayType.dims
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		Local arrayType:TArrayType=TArrayType( ty )
		Return (arrayType And ( TVoidType( elemType ) Or elemType.EqualsType( arrayType.elemType ) Or elemType.ExtendsType( arrayType.elemType ) )) Or IsPointerType(ty, 0, TType.T_POINTER) <> Null Or (TObjectType( ty ) And TObjectType( ty ).classDecl.ident="Object")
	End Method
	
	Method Semant:TType(option:Int = False)
		Local ty:TType=elemType.Semant()
		If ty<>elemType Return New TArrayType.Create( ty, dims )
		Return Self
	End Method
	
	Method GetClass:TClassDecl()
		'Return _env.FindClassDecl( "array" )
		Return TClassDecl( _env.FindDecl( "___array" ) )
	End Method

	Method OnCopy:TType()
		Local ty:TArrayType = New TArrayType
		ty.elemType = elemType
		ty.dims = dims
		Return ty
	End Method

	Method ToString$()
		Return elemType.ToString()+" Array"
	End Method
End Type

Type TObjectType Extends TType
	Field classDecl:TClassDecl
	Field instance:Int
	
	Method Create:TObjectType( classDecl:TClassDecl )
		Self.classDecl=classDecl
		Return Self
	End Method
	
	Method ActualType:TType()
		If classDecl.actual=classDecl Return Self
		Return New TObjectType.Create( TClassDecl(classDecl.actual) )
	End Method
	
	Method EqualsType:Int( ty:TType )
		Local objty:TObjectType=TObjectType( ty )
		Return TNullDecl(classDecl) <> Null Or (objty And (classDecl=objty.classDecl))' Or classDecl.ExtendsClass( objty.classDecl ))) 'Or TObjectVarPtrType(ty) <> Null
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		If classDecl.IsStruct() Return False
		Local objty:TObjectType=TObjectType( ty )
		If objty Return classDecl.ExtendsClass( objty.classDecl )
		If IsPointerType( ty, T_BYTE ) Return True
	End Method
	
	Method GetClass:TClassDecl()
		Return classDecl
	End Method
	
	Method ToString$()
		Return classDecl.ToTypeString()
	End Method

	Method OnCopy:TType()
		Local ty:TObjectType = New TObjectType
		ty.classDecl = classDecl
		ty.instance = instance
		Return ty
	End Method

End Type

Type TClassType Extends TType

	Field classDecl:TClassDecl
	Field instance:Int
	
	Method Create:TClassType( classDecl:TClassDecl )
		Self.classDecl=classDecl
		Return Self
	End Method

	Method GetClass:TClassDecl()
		Return classDecl
	End Method

	Method OnCopy:TType()
		Local ty:TClassType = New TClassType
		ty.classDecl = classDecl
		ty.instance = instance
		Return ty
	End Method

	Method ToString:String()
		Return "Type"
	End Method
	
End Type

Type TIdentType Extends TType
	Field ident$
	Field args:TType[]
	
	Method Create:TIdentType( ident$,args:TType[] = Null )
		Self.ident=ident
		If args = Null Then
			Self.args = New TType[0]
		Else
			Self.args=args
		End If
		Return Self
	End Method
	
	Method CopyToDest:TIdentType(dst:TIdentType)
		dst.ident = ident
		dst.args = args
		Return dst
	End Method

	Method CopyToPointer:TIdentType(dst:TIdentType)
		dst = TIdentType(MapToPointerType(dst))
		dst.ident = ident
		dst.args = args
		Return dst
	End Method
	
	Method ActualType:TType()
		InternalErr
	End Method
	
	Method EqualsType:Int( ty:TType )
		InternalErr
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		InternalErr
	End Method
	
	'Method Semant:TType()
	'	If ident Return New TObjectType.Create( FindClass() )
	'	Return New TObjectType.Create( TClassDecl.nullObjectClass )
	'End Method
	
	
	Method Semant:TType(ignoreNotFoundError:Int = 0)
'If ident="obj" DebugStop
		If Not ident Return TType.nullObjectType

		Local targs:TType[args.Length]
		For Local i:Int=0 Until args.Length
			targs[i]=args[i].Semant()
		Next
		
		Local tyid$,ty:TType
		Local i:Int=ident.FindLast( "." )
		
		If i=-1
			tyid=ident.ToLower()
			
			If tyid = "self" Then
				' find owning class
				Local scope:TClassDecl = _env.ClassScope()
				If scope Then
					tyid = scope.ident
					ty = New TClassType.Create(scope)
					
					' test for method scope - self is already an instance
					Local funcScope:TFuncDecl = _env.FuncScope()
					If funcScope.IsAnyMethod() Then
						TClassType(ty).instance = True
					End If
				Else
					Err "'Self' can only be used within methods."
				End If
			End If
			
			If Not ty Then
				ty=_env.FindType( tyid,targs )
			End If

			' finally scan all modules for it
			If Not ty Then
				For Local mdecl:TModuleDecl = EachIn _appInstance.globalImports.Values()
					ty=mdecl.FindType( tyid,targs )
					If ty Exit
				Next
			End If
		Else
			Local id:String = ident.ToLower()
			i = id.Find( "." )
						
			' try scope search first
			tyid=id[..i]
			
			If tyid = "self" Then
				' find owning class
				Local scope:TClassDecl = _env.ClassScope()
				If scope Then
					tyid = scope.ident
					ty = New TClassType.Create(scope)
					
					' test for method scope - self is already an instance
					Local funcScope:TFuncDecl = _env.FuncScope()
					If funcScope.IsAnyMethod() Then
						TClassType(ty).instance = True
					End If
				Else
					Err "'Self' can only be used within methods."
				End If
			End If
			
			If Not ty Then
				ty=_env.FindType( tyid,targs )
			End If
			
			If Not ty Then
				i = id.FindLast( "." )
		
				' try scope search first
				tyid=id[..i]
				ty=_env.FindType( tyid,targs )				

				If Not ty Then
					' no? now try module search
					Local modid$=id[..i]
					Local mdecl:TModuleDecl=_env.FindModuleDecl( modid )
					If Not mdecl Err "Module '"+modid+"' not found"
					tyid=id[i+1..]
					ty=mdecl.FindType( tyid,targs )
				End If
			End If
		EndIf
		If Not ty Then
			If ignoreNotFoundError Then
				Return Null
			End If
			Err "Type '"+tyid+"' not found"
		End If
		
		If (_flags & T_VAR) And TObjectType(ty) Then
			ty = New TObjectType.Create(TObjectType(ty).classDecl)
			ty._flags :| T_VAR
		End If

		If (_flags & T_POINTER) And TObjectType(ty) Then
			' FIXME #200
			'If Not TObjectType(ty).classDecl.IsExtern() Then
			'	Err "Invalid Pointer type."
			'End If
			ty = New TObjectType.Create(TObjectType(ty).classDecl)
			ty._flags :| (_flags & T_POINTER)
		End If
		
		Return ty
	End Method

	Method SemantClass:TClassDecl()
		Local ty:TObjectType=TObjectType( Semant() )
		If Not ty Err "Type is not a class"
		Return ty.classDecl
	End Method

	Method ToString$()
		Local t$
		For Local arg:TIdentType=EachIn args
			If t t:+","
			t:+arg.ToString()
		Next
		If t Return "$"+ident+"<"+t.Replace("$","")+">"
		Return "$"+ident
	End Method

	Method OnCopy:TType()
		Local ty:TIdentType = New TIdentType
		ty.ident = ident
		ty.args = args
		Return ty
	End Method

End Type

Type TExternObjectType Extends TType
	Field classDecl:TClassDecl
	
	Method Create:TExternObjectType( classDecl:TClassDecl )
		Self.classDecl=classDecl
		Return Self
	End Method
	
	Method ActualType:TType()
		If classDecl.actual=classDecl Return Self
		Return New TExternObjectType.Create( TClassDecl(classDecl.actual) )
	End Method
	
	Method EqualsType:Int( ty:TType )
		Local objty:TObjectType=TObjectType( ty )
		Return TNullDecl(classDecl) <> Null Or (objty And (classDecl=objty.classDecl Or classDecl.ExtendsClass( objty.classDecl ))) Or TObjectType(ty)
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		Local objty:TObjectType=TObjectType( ty )
		If objty Return classDecl.ExtendsClass( objty.classDecl )
		If IsPointerType( ty, T_BYTE ) Return True
		Local op$
		If TBoolType( ty )
			op="ToBool"
		Else If TIntType( ty ) 
			op="ToInt"
		Else If TFloatType( ty )
			op="ToFloat"
		Else If TStringType( ty )
			op="ToString"
		Else If TLongType( ty ) ' BaH Long
			op="ToLong"
		Else
			Return False
		EndIf
		Local fdecl:TFuncDecl=GetClass().FindFuncDecl( op,Null,True,,,,SCOPE_CLASS_HEIRARCHY )
		Return fdecl And fdecl.IsMethod() And fdecl.retType.EqualsType( ty )
	End Method
	
	Method GetClass:TClassDecl()
		Return classDecl
	End Method
	
	Method ToString$()
		Return classDecl.ToTypeString()
	End Method

	Method OnCopy:TType()
		Local ty:TExternObjectType = New TExternObjectType
		ty.classDecl = classDecl
		Return ty
	End Method
End Type

Type TFunctionPtrType Extends TType

	Field func:TFuncDecl
	
	Method Create:TFunctionPtrType(func:TFuncDecl)
		Self.func = func
		Return Self
	End Method

	Method EqualsType:Int( ty:TType )
' TODO : compare function decl
		Return TFunctionPtrType( ty )<>Null
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		If TObjectType( ty )
			Local expr:TExpr=New TConstExpr.Create( Self,"" ).Semant()
			Local ctor:TFuncDecl=ty.GetClass().FindFuncDecl( "new",[expr],True,,,,SCOPE_CLASS_HEIRARCHY )
			Return ctor And ctor.IsCtor()
		EndIf
		Return IsPointerType( ty, 0, T_POINTER )<>Null
	End Method
	
	Method equalsDecl:Int(fdecl:TFuncDecl)

		func.Semant
		fdecl.Semant
	
		' same number of args?
		If func.argDecls.length <> fdecl.argDecls.length Then
			Return False
		End If
		
		' same arg types?
		For Local i:Int = 0 Until func.argDecls.length
			If Not func.argDecls[i].ty.equalsType(fdecl.argDecls[i].ty) Return False
		Next
		
		' same return type?
		If Not func.retType.equalsType(fdecl.retType) Then
			' if function pointer specifies Int return type, our function can specify void...
			If TIntType(func.retType) And TVoidType(fdecl.retType) Then
				Return True
			End If
			Return False
		End If
		
		Return True
	End Method
	
	Method ToString$()
		Return func.ToTypeString()
	End Method

	Method OnCopy:TType()
		Local ty:TFunctionPtrType = New TFunctionPtrType
		ty.func = func
		Return ty
	End Method

	Method Semant:TType(option:Int = False)
		func.Semant()
		Return Self
	End Method

End Type

' a holder during parsing which becomes the "real" var ptr type during semanting
Type TVarPtrType Extends TType
	Method OnCopy:TType()
		Return New TVarPtrType
	End Method
End Type

Type TParamType Extends TIntegralType
End Type

Type TWParamType Extends TParamType

	Method EqualsType:Int( ty:TType )
		Return TWParamType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		If _flags & T_VARPTR And (TWParamType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TIntVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		If WORD_SIZE = 4 Then
			Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or ((TWParamType(ty)<>Null Or TSizeTType(ty)<>Null Or TUIntType(ty)<>Null) And (ty._flags & T_VAR)) Or TIntType(ty)<>Null Or TUIntType(ty)<>Null Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null
		Else
			Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or ((TWParamType(ty)<>Null Or TSizeTType(ty)<>Null Or TULongType(ty)<>Null) And (ty._flags & T_VAR)) Or TLongType(ty)<>Null Or TULongType(ty)<>Null Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TFloat64Type(ty)<>Null
		End If
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TWParamType(ty)<>Null Then
			Return 0
		End If

		If TSizeTType(ty)<>Null Then
			Return 0
		End If

		If WORD_SIZE = 4 Then
			If TUIntType(ty)<>Null Then
				Return 0
			End If

			If TIntType(ty)<>Null Then
				Return 2
			End If

			If TULongType(ty)<>Null Then
				Return 3
			End If

			If TLongType(ty)<>Null Then
				Return 4
			End If

			If TFloatType(ty)<>Null Then
				Return 5
			End If
	
			If TDoubleType(ty)<>Null Then
				Return 6
			End If
			
		Else
			If TULongType(ty)<>Null Then
				Return 0
			End If

			If TLongType(ty)<>Null Then
				Return 2
			End If

			If TFloatType(ty)<>Null Then
				Return 4
			End If
	
			If TDoubleType(ty)<>Null Then
				Return 6
			End If

			If TFloat64Type(ty)<>Null Then
				Return 8
			End If

		End If
	
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TWParamType
	End Method

	Method ToString$()
		Return "WPARAM" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return WORD_SIZE
	End Method

End Type

Type TLParamType Extends TParamType

	Method EqualsType:Int( ty:TType )
		Return TLParamType( ty )<>Null And (_flags = ty._flags Or ..
			(_flags & T_VARPTR And ty._flags & T_PTR) Or (ty._flags & T_VARPTR And _flags & T_PTR) Or (_flags & T_VAR))
	End Method
	
	Method ExtendsType:Int( ty:TType, noExtendString:Int = False, widensTest:Int = False )
		If _flags & T_VARPTR And (TLParamType(ty) <> Null Or IsPointerType(ty, 0, T_POINTER)) Return True
		Return (widensTest And WidensToType(ty)) Or (Not widensTest And TNumericType( ty )<>Null) Or (Not noExtendString And TStringType( ty )<>Null) 'Or TIntVarPtrType( ty )<> Null
	End Method

	Method WidensToType:Int( ty:TType )
		If WORD_SIZE = 4 Then
			Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or ((TIntType(ty)<>Null Or TLParamType(ty)<>Null) And (ty._flags & T_VAR)) Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TFloat64Type(ty)<>Null
		Else
			Return (IsPointerType(ty, 0, T_POINTER) And IsPointerType(Self, 0, T_POINTER)) Or ((TLongType(ty)<>Null Or TLParamType(ty)<>Null) And (ty._flags & T_VAR)) Or TFloatType(ty)<>Null Or TDoubleType(ty)<>Null Or TFloat64Type(ty)<>Null
		End If
	End Method

	Method DistanceToType:Int(ty:TType)
		If IsPointerType(ty, 0, T_POINTER) Then
			If IsPointerType(Self, 0, T_POINTER) Then
				Return 0
			Else
				Return T_MAX_DISTANCE
			End If
		End If

		If TLParamType(ty)<>Null Then
			Return 0
		End If

		If WORD_SIZE = 4 Then
		
			If TIntType(ty)<>Null Then
				Return 0
			End If
			
			If TLongType(ty)<>Null Then
				Return 2
			End If
			
			If TFloatType(ty)<>Null Then
				Return 4
			End If
			
			If TDoubleType(ty)<>Null Then
				Return 6
			End If
			
		Else
			If TLongType(ty)<>Null Then
				Return 0
			End If
	
			If TFloatType(ty)<>Null Then
				Return 2
			End If
	
			If TDoubleType(ty)<>Null Then
				Return 4
			End If
	
			If TFloat64Type(ty)<>Null Then
				Return 6
			End If

		End If
	
		Return T_MAX_DISTANCE
	End Method
	
	Method OnCopy:TType()
		Return New TLParamType
	End Method

	Method ToString$()
		Return "LPARAM" + ToStringParts()
	End Method

	Method GetSize:Int()
		Return WORD_SIZE
	End Method

End Type
